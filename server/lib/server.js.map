{"version":3,"sources":["webpack:///webpack/bootstrap 986537cb4dc449ab8c58","webpack:///external \"co\"","webpack:///external \"lodash\"","webpack:///./src/modules/logger.js","webpack:///external \"assert\"","webpack:///external \"lodash/fp\"","webpack:///./src/config/index.js","webpack:///./src/modules/sender.js","webpack:///./src/modules/errors/BaseError.class.js","webpack:///external \"util\"","webpack:///./src/models/Environment.js","webpack:///external \"bluebird\"","webpack:///./src/Enums.js","webpack:///./src/modules/sns/EnvironmentManagerEvents/index.js","webpack:///./src/modules/awsResourceNameProvider.js","webpack:///./src/modules/amazon-client/childAccountClient.ts","webpack:///./src/modules/data-access/dynamoVersion.js","webpack:///./src/modules/amazon-client/masterAccountClient.ts","webpack:///./src/modules/data-access/dynamoAudit.js","webpack:///./src/modules/data-access/configEnvironments.js","webpack:///./src/models/AutoScalingGroup.js","webpack:///./src/api/api-utils/requestMetadata.js","webpack:///./src/api/api-utils/requestParam.js","webpack:///./src/modules/data-access/cachedSingleAccountDynamoTable.js","webpack:///./src/modules/functional.js","webpack:///./src/api/api-utils/ifNotFound.js","webpack:///./src/modules/resourceFactories/asgResourceFactory.js","webpack:///./src/modules/service-targets/index.js","webpack:///external \"fs\"","webpack:///./src/modules/data-access/services.js","webpack:///external \"aws-sdk\"","webpack:///external \"js-joda\"","webpack:///./src/modules/awsAccounts.ts","webpack:///./src/modules/provisioning/namingConventionProvider.js","webpack:///./src/modules/errors/AwsError.class.js","webpack:///./src/modules/cacheManager.js","webpack:///./src/modules/data-access/deployments.js","webpack:///./src/modules/errors/ConfigurationError.class.js","webpack:///./src/modules/errors/ResourceNotFoundError.class.js","webpack:///./src/modules/data-access/loadBalancerUpstreams.js","webpack:///./src/commands/deployments/DeploymentCommandHandlerLogger.js","webpack:///external \"path\"","webpack:///external \"uuid/v1\"","webpack:///external \"ms\"","webpack:///./src/models/EnvironmentType.js","webpack:///./src/modules/consul-client/index.js","webpack:///./src/modules/data-access/opsEnvironment.js","webpack:///./src/modules/find-in-ancestor.ts","webpack:///./src/modules/data-access/dynamoTableDescription.js","webpack:///./src/modules/data-access/dynamoTable.js","webpack:///./src/modules/amazon-client/pages.js","webpack:///./src/modules/user-service/index.js","webpack:///./src/modules/utilities.js","webpack:///./src/modules/provisioning/infrastructureConfigurationProvider.js","webpack:///./src/queryHandlers/ScanCrossAccountImages.js","webpack:///./src/modules/environmentDatabase.js","webpack:///./src/modules/data-access/configEnvironmentTypes.js","webpack:///./src/queryHandlers/GetAutoScalingGroup.js","webpack:///./src/modules/configurationCache.js","webpack:///./src/modules/resourceFactories/launchConfigurationResourceFactory.js","webpack:///./src/modules/DeploymentLogger.js","webpack:///./src/models/Instance.js","webpack:///./src/queryHandlers/ScanAutoScalingGroups.js","webpack:///./src/modules/errors/InvalidOperationError.class.js","webpack:///external \"url\"","webpack:///./src/modules/service-discovery/index.js","webpack:///./src/queryHandlers/ScanInstances.js","webpack:///./src/modules/data-access/permissions.js","webpack:///./src/modules/data-access/singleAccountDynamoTable.js","webpack:///./src/modules/data-access/describeDynamoTable.js","webpack:///./src/modules/awsDynamo/dynamodbExpression.js","webpack:///external \"express\"","webpack:///./shared/user.js","webpack:///./src/modules/authentications/cookieAuthenticationConfiguration.js","webpack:///./src/commands/utils/metadata.js","webpack:///./src/modules/provisioning/launchConfiguration/imageProvider.js","webpack:///./src/modules/errors/AutoScalingGroupNotFoundError.class.js","webpack:///external \"moment\"","webpack:///./src/modules/errors/HttpRequestError.class.js","webpack:///./src/models/TaggableMixin.js","webpack:///./src/queryHandlers/services/GetTargetState.js","webpack:///./src/modules/queryHandlersUtil/scanCrossAccountFn.js","webpack:///./src/modules/provisioning/launchConfiguration/instanceDevicesProvider.js","webpack:///./src/commands/asg/SetAutoScalingGroupSize.js","webpack:///./src/modules/resourceFactories/ec2InstanceResourceFactory.js","webpack:///./src/modules/errors/DeploymentValidationError.class.js","webpack:///./src/queryHandlers/services/GetServerRoles.js","webpack:///./src/modules/health-checks/resultCodes.js","webpack:///external \"newrelic\"","webpack:///./src/modules/memoize.js","webpack:///./src/modules/data-access/dynamoItemFilter.js","webpack:///external \"ioredis\"","webpack:///external \"timers\"","webpack:///./src/modules/emCrypto.js","webpack:///./src/modules/miniStack.js","webpack:///./src/modules/errors/ActiveDirectoryError.class.js","webpack:///./src/modules/userSessionStore.js","webpack:///./src/modules/sslComponentsRepository/index.js","webpack:///./src/modules/S3GetObjectRequest.js","webpack:///./src/modules/authentications/cookieAuthentication.js","webpack:///./src/modules/monitoring/activeDeploymentsStatusProvider.js","webpack:///./src/modules/data-access/accounts.js","webpack:///./src/modules/queryHandlersUtil/applyFuncToAccounts.js","webpack:///./src/modules/machineImage/imageSummary.js","webpack:///./src/modules/resourceFactories/ec2ImageResourceFactory.js","webpack:///./src/modules/data-access/deploymentMaps.js","webpack:///./src/modules/data-access/clusters.js","webpack:///./src/modules/resourceFactories/AsgResourceBase.js","webpack:///./src/modules/service-targets/consul/index.js","webpack:///external \"retry\"","webpack:///./src/modules/schema/schema.js","webpack:///external \"ajv\"","webpack:///./src/modules/DeploymentLogsStreamer.js","webpack:///./src/commands/services/UpdateTargetState.js","webpack:///./src/modules/queryHandlersUtil/deployments-helper.js","webpack:///./src/modules/authorizers/environmentProtection.js","webpack:///./src/modules/resourceFactories/InstanceResourceBase.js","webpack:///./src/models/Service.js","webpack:///./src/api/swagger-doc.js","webpack:///./src/modules/data-access/asgips.js","webpack:///./src/models/SecurityGroup.js","webpack:///./src/modules/provisioning/launchConfiguration/securityGroupsProvider.js","webpack:///./src/queryHandlers/GetInstanceProfile.js","webpack:///./src/modules/provisioning/autoScaling/subnetsProvider.js","webpack:///./src/modules/base64.js","webpack:///./src/modules/data-access/loadBalancerSettings.js","webpack:///./src/api/api-utils/logicalTableName.js","webpack:///./src/queryHandlers/deployments/GetNodeDeploymentLog.js","webpack:///./src/modules/toggleServiceStatus.js","webpack:///./src/modules/s3PackageLocator.js","webpack:///./src/modules/amazon-client/s3Url.js","webpack:///./src/models/OpsEnvironment.js","webpack:///./src/modules/scheduling/index.js","webpack:///external \"later\"","webpack:///external \"http\"","webpack:///external \"https\"","webpack:///./src/modules/environment-state/getASGState.js","webpack:///./src/modules/environment-state/getInstanceState.js","webpack:///./src/modules/autoScalingGroupSizePredictor.js","webpack:///external \"request\"","webpack:///./src/api/controllers/package-upload-url/dynamicResponseCreator.js","webpack:///./src/modules/queryHandlersUtil/getSlices.js","webpack:///./src/commands/utils/toggleSlices.js","webpack:///./src/modules/environment-state/serverRoleFilters.js","webpack:///./src/modules/serviceName.js","webpack:///./src/index.js","webpack:///(webpack)/buildin/module.js","webpack:///external \"nconf\"","webpack:///./src/config/version.js","webpack:///./package.json","webpack:///external \"winston\"","webpack:///./src/modules/configuration/ConfigurationProvider.js","webpack:///./src/modules/configuration/LocalConfigurationProvider.js","webpack:///external \"console\"","webpack:///./src/modules/configuration/S3ConfigurationProvider.js","webpack:///./src/modules/checkAppPrerequisites.js","webpack:///external \"deep-freeze-strict\"","webpack:///./src/modules/data-access/dynamoSoftDelete.js","webpack:///./src/modules/data-access/dynamoTableCache.js","webpack:///external \"cache-manager\"","webpack:///./src/modules/data-access/cacheManagerEncryptedRedis.js","webpack:///external \"crypto\"","webpack:///./src/modules/MainServer.js","webpack:///external \"body-parser\"","webpack:///external \"cookie-parser\"","webpack:///external \"compression\"","webpack:///external \"express-request-id\"","webpack:///./src/modules/serverFactoryConfiguration.js","webpack:///./src/modules/authentications/tokenAuthentication.js","webpack:///./src/modules/user-service/userService.mock.js","webpack:///./src/modules/user-service/userService.prod.js","webpack:///external \"jsonwebtoken\"","webpack:///./src/modules/userRolesProvider.js","webpack:///./src/modules/active-directory-adapter/index.js","webpack:///./src/modules/active-directory-adapter/activeDirectoryAdapter.mock.js","webpack:///./src/modules/active-directory-adapter/activeDirectoryAdapter.prod.js","webpack:///external \"activedirectory\"","webpack:///./src/modules/errors/InvalidCredentialsError.class.js","webpack:///./src/modules/active-directory-adapter/activeDirectoryAdapterConfiguration.js","webpack:///external \"md5\"","webpack:///./src/modules/data-access/encryptedRedisStore.js","webpack:///./src/modules/sslComponentsRepository/sslComponentsRepository.mock.js","webpack:///./src/modules/sslComponentsRepository/sslComponentsRepository.prod.js","webpack:///external \"async\"","webpack:///./src/modules/sslComponentsRepository/sslComponentsRepository.prod.config.js","webpack:///./src/modules/authentication.js","webpack:///./src/modules/monitoring/DeploymentMonitorScheduler.js","webpack:///./src/modules/monitoring/DeploymentMonitor.js","webpack:///./src/modules/errors/DynamoItemNotFoundError.class.js","webpack:///./src/modules/provisioning/Image.class.js","webpack:///./src/modules/errors/ImageNotFoundError.class.js","webpack:///external \"semver\"","webpack:///./src/models/DeploymentMap.js","webpack:///./src/modules/queryHandlersUtil/getASG.js","webpack:///./src/modules/resourceFactories/AsgResource.js","webpack:///./src/modules/errors/AutoScalingGroupAlreadyExistsError.class.js","webpack:///./src/modules/service-targets/consul/consulMacroManager.js","webpack:///./src/modules/service-targets/consul/ConsulManager.js","webpack:///external \"consul\"","webpack:///./src/modules/consul-client/clientConfig.mock.js","webpack:///./src/modules/consul-client/clientConfig.prod.js","webpack:///./src/modules/consulSecretCache.js","webpack:///./src/modules/service-targets/consul/keyValueStore.js","webpack:///./src/modules/errors/LaunchConfigurationAlreadyExistsError.class.js","webpack:///./src/modules/systemUser.js","webpack:///./src/api/v1.js","webpack:///external \"swagger-tools\"","webpack:///./src/modules/express-middleware/swaggerAuthorizerMiddleware.js","webpack:///./src/modules/authorization.js","webpack:///./src/modules/authorizer.js","webpack:///external \"glob-intersection\"","webpack:///./src/modules/authorizers/index.js","webpack:///./src/modules/authorizers/allow-authenticated.js","webpack:///./src/modules/authorizers/asgs.js","webpack:///./src/modules/authorizers/deploy-authorizer.js","webpack:///./src/modules/errors/BadRequestError.class.js","webpack:///./src/modules/authorizers/deployments.js","webpack:///./src/models/Deployment.js","webpack:///./src/modules/authorizers/environments.js","webpack:///./src/modules/authorizers/environments-schedule.js","webpack:///./src/modules/authorizers/instances.js","webpack:///./src/modules/errors/InstanceNotFoundError.class.js","webpack:///./src/modules/authorizers/load-balancer-settings.js","webpack:///./src/modules/authorizers/package-upload-url.js","webpack:///./src/modules/authorizers/services.js","webpack:///./src/modules/authorizers/simple.js","webpack:///./src/modules/authorizers/toggle-service-status.js","webpack:///./src/modules/authorizers/upstreams.js","webpack:///./src/modules/express-middleware/swaggerNewRelicMiddleware.js","webpack:///external \"js-yaml\"","webpack:///./src/modules/new-relic/check.js","webpack:///./src/api/error-handler/defaultErrorHandler.js","webpack:///./src/api/controllers/index.js","webpack:///./src/api/controllers/asgs/asgController.js","webpack:///./src/queryHandlers/ScanCrossAccountAutoScalingGroups.js","webpack:///./src/modules/queryHandlersUtil/scanCrossAccount.js","webpack:///./src/queryHandlers/GetLaunchConfiguration.js","webpack:///./src/models/Image.js","webpack:///./src/queryHandlers/ScanSecurityGroups.js","webpack:///./src/modules/resourceFactories/securityGroupResourceFactory.js","webpack:///./src/modules/resourceFactories/SecurityGroupResource.js","webpack:///./src/commands/launch-config/SetLaunchConfiguration.js","webpack:///./src/commands/launch-config/launchConfigUpdater.js","webpack:///./src/modules/resourceFactories/iamInstanceProfileResourceFactory.js","webpack:///./src/modules/errors/InstanceProfileNotFoundError.class.js","webpack:///./src/commands/asg/SetAutoScalingGroupSchedule.js","webpack:///./src/commands/asg/UpdateAutoScalingGroup.js","webpack:///./src/queryHandlers/GetAutoScalingGroupScheduledActions.js","webpack:///./src/modules/resourceFactories/asgScheduledActionsResourceFactory.js","webpack:///./src/modules/resourceFactories/AsgScheduledActionsResource.js","webpack:///./src/queryHandlers/GetAutoScalingGroupLifeCycleHooks.js","webpack:///./src/modules/resourceFactories/asgLifeCycleHooksResourceFactory.js","webpack:///./src/modules/resourceFactories/AsgLifeCycleHooksResource.js","webpack:///./src/modules/environment-state/getASGReady.js","webpack:///./src/modules/sns/EnvironmentManagerEvents/createTopic.js","webpack:///./src/modules/sns/EnvironmentManagerEvents/getTargetArn.js","webpack:///./src/modules/sns/EnvironmentManagerEvents/createEvent.js","webpack:///./src/modules/sns/EnvironmentManagerEvents/publishEvent.js","webpack:///./src/api/controllers/audit/auditController.js","webpack:///./src/api/api-utils/notImplemented.js","webpack:///./src/modules/auditLogReader.js","webpack:///external \"buffer\"","webpack:///./src/modules/weblink.js","webpack:///./src/api/controllers/config/accounts/accountsController.js","webpack:///./src/commands/validators/awsAccountValidator.js","webpack:///./src/api/controllers/config/clusters/clusterController.js","webpack:///./src/api/controllers/config/deployment-maps/deploymentMapController.js","webpack:///./src/api/controllers/config/environment-types/environmentTypeController.js","webpack:///./src/api/controllers/config/environments/environmentsConfigController.js","webpack:///./src/api/controllers/config/export/exportController.js","webpack:///./src/api/controllers/config/import/importController.js","webpack:///./src/modules/data-access/dynamoImport.js","webpack:///./src/api/controllers/config/lb-settings/lbSettingsController.js","webpack:///./src/modules/data-access/lbSettingsAdapter.js","webpack:///./src/api/controllers/config/notification-settings/notificationSettingsController.js","webpack:///./src/modules/data-access/notificationSettings.js","webpack:///./src/api/controllers/config/permissions/permissionsController.js","webpack:///./src/api/controllers/config/server-roles/serverRoleController.js","webpack:///./src/api/controllers/config/services/servicesConfigController.js","webpack:///./src/api/controllers/config/upstreams/upstreamsConfigController.js","webpack:///./src/modules/data-access/lbUpstreamAdapter.js","webpack:///./src/commands/validators/lbUpstreamValidator.js","webpack:///./src/modules/errors/InvalidItemSchemaError.class.js","webpack:///./src/api/controllers/deployments/deploymentsController.js","webpack:///./src/commands/services/ToggleTargetStatus.js","webpack:///./src/commands/deployments/DeployService.js","webpack:///./src/modules/deployment/DeploymentContract.js","webpack:///./src/modules/deployment/deploymentValidators.js","webpack:///./src/modules/deployment/validators/blueGreenDeploymentValidator.js","webpack:///./src/modules/deployment/validators/uniqueServiceVersionDeploymentValidator.js","webpack:///./src/modules/PackagePathProvider.js","webpack:///./src/modules/deployment/S3PathContract.js","webpack:///./src/modules/scheduling/parseSchedule.js","webpack:///external \"moment-timezone\"","webpack:///./src/modules/errors/ResourceLockedError.js","webpack:///./src/queryHandlers/GetServicePortConfig.js","webpack:///./src/commands/deployments/GetInfrastructureRequirements.js","webpack:///./src/modules/provisioning/launchConfigurationTemplatesProvider.js","webpack:///./src/modules/provisioning/launchConfiguration/iamInstanceProfileNameProvider.js","webpack:///./src/modules/provisioning/launchConfiguration/userDataProvider.js","webpack:///./src/modules/provisioning/launchConfiguration/UserDataBuilder.js","webpack:///./src/modules/provisioning/launchConfiguration/userData/linux-user-data.ts","webpack:///./src/modules/provisioning/launchConfiguration/userData/windows-user-data.ts","webpack:///./src/modules/provisioning/launchConfiguration/keyNameProvider.js","webpack:///./src/queryHandlers/GetKeyPair.js","webpack:///./src/modules/factories/keypairFactory.js","webpack:///./src/modules/errors/KeyPairNotFoundError.class.js","webpack:///./src/modules/provisioning/autoScalingTemplatesProvider.js","webpack:///./src/modules/provisioning/autoScaling/topicNotificationMappingProvider.js","webpack:///./src/queryHandlers/GetTopic.js","webpack:///./src/modules/clientFactories/snsTopicClientFactory.js","webpack:///./src/modules/clientFactories/SNSTopicClient.js","webpack:///./src/modules/errors/TopicNotFoundError.class.js","webpack:///./src/modules/provisioning/autoScaling/tagsProvider.js","webpack:///./src/queryHandlers/ScanLaunchConfigurations.js","webpack:///./src/commands/deployments/PushDeployment.js","webpack:///./src/modules/deployment/serverRoleDefinition.js","webpack:///./src/modules/deployment/serviceInstallationDefinition.js","webpack:///./src/modules/deployment/serviceDefinition.js","webpack:///./src/modules/deployment/serviceDeploymentDefinition.js","webpack:///./src/modules/deployment/deploymentDefinition.js","webpack:///./src/commands/deployments/PreparePackage.js","webpack:///./src/commands/deployments/packageMover.js","webpack:///./src/modules/simple-http.js","webpack:///./src/commands/deployments/PreparePackageCommand.schema.js","webpack:///./src/commands/deployments/ProvideInfrastructure.js","webpack:///./src/commands/deployments/CreateLaunchConfiguration.js","webpack:///./src/commands/deployments/CreateAutoScalingGroup.js","webpack:///./src/api/controllers/diagnostics/diagnosticsController.js","webpack:///./src/api/controllers/environments/environmentsController.js","webpack:///./src/queryHandlers/GetASGState.js","webpack:///./src/modules/service-discovery/consul/index.js","webpack:///./src/modules/service-discovery/consul/consulCatalog.js","webpack:///./src/modules/environment-state/serviceStateUtils.js","webpack:///./src/modules/environment-state/getServicesState.js","webpack:///./src/modules/environment-state/getAWSInstances.js","webpack:///./src/queryHandlers/ScanServersStatus.js","webpack:///./src/queryHandlers/services/GetNode.js","webpack:///./src/api/controllers/images/imagesController.js","webpack:///./src/queryHandlers/ScanImages.js","webpack:///./src/api/controllers/instances/instancesController.js","webpack:///./src/queryHandlers/ScanCrossAccountInstances.js","webpack:///./src/commands/asg/EnterAutoScalingGroupInstancesToStandby.js","webpack:///./src/commands/asg/ExitAutoScalingGroupInstancesFromStandby.js","webpack:///./src/queryHandlers/ScanInstancesScheduleStatus.js","webpack:///./src/modules/merge.js","webpack:///./src/api/controllers/load-balancer/loadBalancerController.js","webpack:///./src/queryHandlers/ScanNginxUpstreams.js","webpack:///./src/modules/resourceFactories/nginxUpstreamsResourceFactory.js","webpack:///./src/api/controllers/package-upload-url/packageUploadUrlController.js","webpack:///./src/modules/validate/rule/environmentExists.js","webpack:///./src/modules/validate/index.js","webpack:///./src/modules/validate/rule/serviceExists.js","webpack:///./src/api/controllers/services/servicesController.js","webpack:///./src/queryHandlers/slices/GetSlicesByService.js","webpack:///./src/commands/slices/ToggleSlicesByService.js","webpack:///./src/modules/errors/InconsistentSlicesStatusError.class.js","webpack:///./src/modules/environment-state/getServiceHealth.js","webpack:///./src/modules/environment-state/healthReporter.js","webpack:///./src/modules/consulDataStructures.js","webpack:///./src/modules/environment-state/getOverallServiceHealth.js","webpack:///./src/api/controllers/target-state/targetStateController.js","webpack:///./src/modules/environment-state/deleteTargetState.js","webpack:///./src/api/controllers/token/tokenController.js","webpack:///./src/modules/authentications/tokenAuthenticationConfiguration.js","webpack:///./src/api/controllers/upstreams/upstreamsController.js","webpack:///./src/queryHandlers/slices/GetSlicesByUpstream.js","webpack:///./src/commands/slices/ToggleSlicesByUpstream.js","webpack:///./src/api/controllers/user/userController.js","webpack:///./src/api/em-internal/controllers/initial-data.js","webpack:///external \"os\"","webpack:///./src/modules/http-server-factory/index.js","webpack:///./src/modules/http-server-factory/HttpsServerFactory.js","webpack:///./src/modules/http-server-factory/HttpServerFactory.js","webpack:///./src/modules/express-middleware/loggingMiddleware.js","webpack:///./src/modules/express-middleware/deprecateMiddleware.js","webpack:///./src/modules/cacheRouter.js","webpack:///./src/modules/remoteCacheFlush.js","webpack:///./src/modules/httpHealthChecks.js","webpack:///./src/modules/health-checks/index.js","webpack:///./src/modules/health-checks/library/ping.js","webpack:///./src/modules/health-checks/library/redis.js","webpack:///./src/routes/home.js","webpack:///./src/modules/renderer.js","webpack:///external \"es6-template-strings/compile\"","webpack:///external \"es6-template-strings/resolve-to-string\"","webpack:///./src/routes/deploymentNodeLogs.js"],"names":[],"mappings":";;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AC7DA,+B;;;;;;ACAA,mC;;;;;;;ACAA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,2EAA2E,mBAAmB;AAC9F;AACA,GAAG;AACH;;AAEA,8CAA8C,aAAa;;AAE3D;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;;;;;;;ACtDA,mC;;;;;;ACAA,sC;;;;;;;ACAA;;AAEA;;AAEA;AACA;AACA,KAAK,aAAa;;AAElB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gBAAgB;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,IAAI;AAC/B;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,IAAI;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,qBAAqB,IAAI,GAAG,eAAe;AAC3C,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;;;;;;;;AClGA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;;AAE9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ,oBAAoB;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ,oBAAoB;AAC5B;AACA;AACA;AACA;AACA;;;;;;;;AC3FA;;AAEA;;AAEA;AACA,uBAAuB,YAAY,SAAS,WAAW,IAAI,cAAc;AACzE;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;ACnCA,iC;;;;;;;ACAA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;ACpCA,qC;;;;;;;ACAA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;;;;;;;AC7DA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,WAAW,IAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3EA;;AAEA;;AAEA;AACA;;AAEA;AACA,gCAAgC,eAAe,EAAE,UAAU;AAC3D;;;;;;;;ACTA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA,sCAAsC,cAAc;AACpD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzCA;;AAEA;;AAEA;;AAEA;;AAEA,wCAAwC,uCAAuC;AAC/E;AACA;AACA;AACA,8BAA8B,iBAAiB,+BAA+B;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,WAAW,eAAe;AACxD,mCAAmC;AACnC;AACA,GAAG;AACH;AACA,8BAA8B,WAAW,eAAe;AACxD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,uCAAuC;AAClD;AACA;AACA;AACA,gCAAgC,iBAAiB,+BAA+B;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,WAAW,eAAe;AAC1D,qCAAqC;AACrC;AACA,KAAK;AACL;AACA,gCAAgC,WAAW,eAAe;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,sBAAsB;AACjC,gCAAgC,iBAAiB,aAAa;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,WAAW,eAAe;AAC1D,qCAAqC;AACrC;AACA,KAAK;AACL;AACA,gCAAgC,WAAW,eAAe;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,oCAAoC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC,oCAAoC;AAC3E;AACA;AACA;AACA,OAAO,wCAAwC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC;AACjC;AACA,OAAO,6GAA6G;AACpH,OAAO,2DAA2D;AAClE;AACA;;AAEA,6BAA6B,mBAAmB;AAChD,OAAO,wCAAwC;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC;AACjC;AACA,6BAA6B,sBAAsB,KAAK;AACxD,OAAO,2DAA2D;AAClE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxKA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACXA;;AAEA;;AAEA,8BAA8B,8BAA8B,sBAAsB,EAAE;AACpF;AACA;AACA;AACA;AACA;AACA;;AAEA,8BAA8B,oBAAoB,sBAAsB,EAAE;AAC1E,8BAA8B;AAC9B;AACA;AACA;AACA,GAAG;AACH,yBAAyB,WAAW,eAAe;AACnD;;AAEA;AACA;AACA;;AAEA;AACA,0BAA0B;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpCA;;AAEA;;AAEA;AACA,gBAAgB;;AAEhB;AACA;;AAEA,wFAAwF,WAAW;;;;;;;;ACVnG;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kEAAkE,0BAA0B;AAC5F;AACA,0EAA0E,iCAAiC;AAC3G,yBAAyB,OAAO;AAChC,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,cAAc;AACtG,+CAA+C,0BAA0B,uCAAuC,6BAA6B;;AAE7I,gCAAgC,+CAA+C;AAC/E;AACA;AACA,2CAA2C,qCAAqC;AAChF;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,6BAA6B;AAC7D;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,mBAAmB;AACrD;AACA,+DAA+D,SAAS;AACxE;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,CAAC;;AAED;;;;;;;;AC9FA;;AAEA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;;;;;;;ACXA;;AAEA;;AAEA;;AAEA;;;;;;;;ACNA;;AAEA;;AAEA;AACA;;AAEA,qCAAqC,MAAM;AAC3C,yDAAyD,MAAM;AAC/D;AACA;;AAEA;;;;;;;;ACZA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACXA;;AAEA,KAAK,iBAAiB;;AAEtB;;AAEA;AACA,qCAAqC,eAAe,aAAa,iBAAiB;;AAElF;AACA;AACA;AACA;;;;;;;;ACZA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,oDAAoD,uBAAuB;;AAE3E;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;AC3BA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;ACVA,+B;;;;;;;ACAA;;AAEA;;AAEA;AACA,gBAAgB;;AAEhB;AACA;;AAEA,mFAAmF,WAAW;;AAE9F;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,kCAAkC,+BAA+B;AACjE;AACA;;AAEA;AACA,kCAAkC,gBAAgB;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,UAAU;AACV;;AAEA,iCAAiC,UAAU,qBAAqB;;;;;;;ACzChE,oC;;;;;;ACAA,oC;;;;;;;ACAA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA,gCAAgC,YAAY,uBAAuB,IAAI;AACvE;AACA,qBAAqB,+EAA+E,YAAY,GAAG,EAAE;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,YAAY;AACvE;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/BA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gDAAgD,qBAAqB;AACrE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,wCAAwC,GAAG,UAAU;AAC9D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;ACjDA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;ACfA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP,8DAA8D,8BAA8B,OAAO,2BAA2B;AAC9H;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP,mDAAmD,iBAAiB,QAAQ,cAAc;AAC1F,oCAAoC,oBAAoB;AACxD,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,wCAAwC,oCAAoC;AAC5E;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA,qDAAqD,GAAG;AACxD;;AAEA;AACA,gCAAgC,KAAK;AACrC;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA,8BAA8B,KAAK;AACnC,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,KAAK,UAAU,IAAI;AAC/D;AACA,KAAK,GAAG,wDAAwD;AAChE;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACjLA;;AAEA;;AAEA,KAAK,kCAAkC;AACvC;AACA;AACA;AACA,KAAK,uBAAuB;AAC5B,KAAK,8CAA8C;AACnD,KAAK,eAAe;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,8EAA8E;AAChG;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,qEAAqE;AACrE;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,SAAS;AACT,0DAA0D;AAC1D;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU,wBAAwB;AAClC;AACA,wBAAwB;AACxB,SAAS;AACT;AACA;AACA;AACA;;AAEA,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;ACvJD;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;ACfA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;ACfA;;AAEA;;AAEA;;AAEA;AACA;AACA,CAAC;AACD;AACA,KAAK,UAAU;AACf,KAAK,sBAAsB;AAC3B,KAAK,qCAAqC;AAC1C;AACA;AACA,KAAK,qBAAqB;;AAE1B;;AAEA;;AAEA,qCAAqC,6CAA6C,KAAK;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,8BAA8B,oBAAoB,KAAK;AACvD,kBAAkB,QAAQ,KAAK;AAC/B,wEAAwE,mBAAmB,KAAK;AAChG,iBAAiB,yBAAyB;AAC1C;AACA,KAAK;AACL;AACA,oCAAoC,0BAA0B,OAAO,0BAA0B;AAC/F,gEAAgE,WAAW;AAC3E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,iBAAiB,yBAAyB;AAC1C,+EAA+E,WAAW;AAC1F,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,WAAW;AACzF,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,4DAA4D,mBAAmB;AAC/E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvIA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;AC7BA,iC;;;;;;ACAA,oC;;;;;;ACAA,+B;;;;;;;ACAA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;;;;;;;ACnBA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB;;;;;;;;ACnBlB;;AAEA;;AAEA;AACA,iBAAiB;;AAEjB;AACA;;AAEA,mFAAmF,WAAW;;AAE9F,sBAAsB,0BAA0B;AAChD;AACA;AACA,uBAAuB,kCAAkC;AACzD;;AAEA,yBAAyB,iCAAiC;AAC1D;AACA;AACA;AACA,uBAAuB,kCAAkC;AACzD;;AAEA,4BAA4B,0BAA0B;AACtD;AACA;AACA;AACA,uBAAuB,kCAAkC;AACzD;;AAEA,iCAAiC,UAAU,iDAAiD;;;;;;;;AChC5F;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnBA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,WAAW,kBAAkB;AAC7B;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzCA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK,qCAAqC;AAC1C;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,YAAY;AAC1C;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,YAAY;AAC1C;AACA;AACA;AACA;;AAEA,4BAA4B,sBAAsB;AAClD;AACA,gCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA;AACA;AACA,gHAAgH,UAAU,SAAS,OAAO;AAC1I;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEA,6BAA6B,sBAAsB;AACnD;AACA,gCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA;AACA;AACA,4FAA4F,UAAU,SAAS,OAAO;AACtH;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEA,4BAA4B,mBAAmB;AAC/C;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA,4FAA4F,UAAU,SAAS,OAAO;AACtH;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEA,6BAA6B,mBAAmB;AAChD;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA,4FAA4F,UAAU,SAAS,OAAO;AACtH;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5HA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,IAAI;AACf,WAAW,OAAO;AAClB;AACA,aAAa,IAAI;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,WAAW,OAAO;AAClB;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACnEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;;AAEA;;;;;;;;ACfA;;AAEA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;;;;;;;AC7BlB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,gBAAgB;AAC3E;AACA;AACA,+DAA+D,iCAAiC;;AAEhG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,yBAAyB,2BAA2B;AACpD;AACA;AACA;AACA,0DAA0D,YAAY;AACtE;AACA,2DAA2D,YAAY,aAAa,cAAc;AAClG,KAAK;AACL;;AAEA;AACA,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,yCAAyC,YAAY;AACrD,qDAAqD,YAAY,aAAa,cAAc;AAC5F;AACA;;;;;;;;ACzEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,cAAc,yCAAyC,2BAA2B;AAC9H;AACA;AACA,+CAA+C,iCAAiC;AAChF;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB;AACA,oCAAoC,uBAAuB;AAC3D;;;;;;;;ACvBA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAiC,mCAAmC;AACpE;AACA;AACA;AACA,OAAO;AACP,qEAAqE,gBAAgB;AACrF;AACA,KAAK;AACL;;AAEA;AACA,qCAAqC,uCAAuC;AAC5E;AACA;AACA;AACA,OAAO;AACP,0EAA0E,oBAAoB;AAC9F;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;;;;;;;ACjCA;;AAEA;;AAEA;AACA,gBAAgB;;AAEhB;AACA;;AAEA,wFAAwF,WAAW;;;;;;;;ACVnG;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;ACZA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,sFAAsF,sBAAsB;AAC5G,8FAA8F,sBAAsB;;AAEpH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;ACjCA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,8BAA8B,wBAAwB;AACtD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,UAAU,OAAO;AACjB,mBAAmB;;AAEnB;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;AC/FA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,yCAAyC,8BAA8B,eAAe,eAAe;;AAErG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO,sBAAsB;AAC7B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,OAAO,8CAA8C,oBAAoB;AACtG;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8BAA8B;AACtD;AACA;;AAEA,gDAAgD,4BAA4B;AAC5E;;;;;;;;AChGA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA,oCAAoC,gBAAgB;AACpD;AACA;AACA,sDAAsD,UAAU,4BAA4B,EAAE;AAC9F;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,UAAU,qCAAqC,EAAE;AACzG;AACA;AACA;AACA,mEAAmE,SAAS;AAC5E;AACA,SAAS;AACT,KAAK;AACL;AACA;;AAEA,wDAAwD;;AAExD;;;;;;;;ACvEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB;AACpB;;AAEA,uBAAuB,qCAAqC;AAC5D;;AAEA;;;;;;;;AChBA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;ACfA,gC;;;;;;;ACAA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;ACVA;;AAEA;;AAEA;;AAEA,qDAAqD,sBAAsB;AAC3E,uDAAuD,cAAc;AACrE,sBAAsB,SAAS;AAC/B;;;;;;;;ACTA;;AAEA;;AAEA;AACA,gBAAgB;;AAEhB;AACA;;AAEA,wFAAwF,WAAW;;;;;;;;ACVnG;;AAEA;;AAEA,KAAK,2CAA2C;AAChD;AACA,KAAK,uBAAuB;AAC5B,KAAK,eAAe;AACpB;AACA,KAAK,aAAa;AAClB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;;AAEA,2CAA2C,sBAAsB,KAAK;AACtE,SAAS,gBAAgB;AACzB,uCAAuC,iCAAiC;AACxE;AACA,WAAW,cAAc;AACzB;AACA;AACA;AACA,yDAAyD,MAAM;AAC/D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qCAAqC;AAC7D;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACjGA;;AAEA;;AAEA,KAAK,uCAAuC;AAC5C;;AAEA;AACA;AACA,wCAAwC,YAAY;AACpD,UAAU,QAAQ,OAAO,QAAQ;AACjC;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;;AAEA;;;;;;;;ACpBA;;AAEA;AACA,4BAA4B,EAAE;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,KAAK;AACzB,wCAAwC,OAAO,EAAE,IAAI;AACrD,KAAK;AACL,oBAAoB,KAAK;AACzB;AACA,wCAAwC,OAAO,GAAG,IAAI;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8CAA8C,GAAG;AACjD,8CAA8C,SAAS;AACvD;AACA,qCAAqC,GAAG,GAAG,6BAA6B;AACxE;AACA;AACA,uCAAuC,6BAA6B;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,wBAAwB,KAAK;AAC7B;AACA;AACA,KAAK,IAAI;AACT,8CAA8C,kBAAkB,GAAG,aAAa;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,cAAc,KAAK;AACnB;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AClHA,oC;;;;;;;ACAA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,sCAAsC,eAAe;;AAErD;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,C;;;;;;;ACpGA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjCA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gCAAgC;;AAEhC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;AClDA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;;AAEA;AACA,uBAAuB,0BAA0B;AACjD;;AAEA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,EAAE;AAC9C;;AAEA;AACA;;AAEA;AACA;;AAEA,eAAe;;AAEf;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA,+DAA+D,yBAAyB;AACxF;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4DAA4D,UAAU;AACtE,KAAK;AACL;;;;;;;;AClEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;ACfA,mC;;;;;;;ACAA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;ACfA;;AAEA;;AAEA;;AAEA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;AACA,2CAA2C,IAAI;AAC/C,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;;;;;;;ACjCA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,mEAAmE,eAAe;AAClF,GAAG;AACH;;;;;;;;ACjBA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;ACZA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oCAAoC,aAAa;AACjD;AACA;;AAEA,sCAAsC,eAAe;AACrD;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC1DA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,IAAI,mDAAmD,IAAI;AACzF;AACA;;AAEA;AACA;AACA,kCAAkC,QAAQ,mDAAmD,IAAI;AACjG;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,IAAI,gDAAgD,IAAI;AACtF;AACA;;AAEA;AACA;AACA,kCAAkC,QAAQ,gDAAgD,IAAI;AAC9F;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;AC3DA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,eAAe,cAAc,KAAK;AAClC;;;;;;;;ACtBA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;ACjBA;;AAEA;;AAEA;AACA;AACA,KAAK,yBAAyB;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,kDAAkD;AAC3E;AACA,4BAA4B,8BAA8B;AAC1D,yDAAyD,eAAe;AACxE;AACA;AACA,kEAAkE,iCAAiC;AACnG,KAAK;AACL;;AAEA;;;;;;;;AClCA;;AAEA;;AAEA;AACA;AACA;AACA;;;;;;;ACPA,qC;;;;;;;ACAA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACrCA;AACA,iDAAiD;AACjD;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAI;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,EAAE;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AC9CA,oC;;;;;;ACAA,mC;;;;;;;ACAA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD,UAAU;AACjE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wDAAwD,WAAW;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACjFA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,kCAAkC;AACnD;AACA;AACA;AACA,iBAAiB,KAAK,EAAE,SAAS;AACjC,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,QAAQ,OAAO,uBAAuB;AACzE;AACA,mBAAmB,sCAAsC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS,gCAAgC;AACzC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,qCAAqC;AACtD;;AAEA;;;;;;;;AC5FA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;ACfA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,cAAc,6CAA6C;AAC3D;;;;;;;;AChBA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,CAAC;AACD;AACA;;AAEA;;;;;;;;AChBA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2DAA2D,YAAY,eAAe,eAAe,eAAe,cAAc;AAClI;AACA,OAAO;;AAEP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;;;;;;;ACnCA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;;;;;;;ACrBA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,yCAAyC,yBAAyB;;AAElE;AACA,KAAK;AACL;AACA,2FAA2F,QAAQ;;AAEnG;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mBAAmB;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB,YAAY,YAAY,GAAG,eAAe;AAClF;AACA;AACA;AACA;AACA,uBAAuB,aAAa;AACpC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC,oBAAoB;AACrD;AACA;AACA;;AAEA,mDAAmD,aAAa,uCAAuC,gCAAgC;;AAEvI;AACA,GAAG;AACH,mEAAmE,aAAa,YAAY,qBAAqB;AACjH;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA,2CAA2C,OAAO;AAClD;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,YAAY;AACZ;AACA,gCAAgC;AAChC;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,eAAe;AAC3F,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,0EAA0E,QAAQ;AAClF;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2CAA2C,QAAQ;AACnD;;;;;;;;ACpLA;;AAEA;;AAEA;AACA,gBAAgB;;AAEhB;AACA;;AAEA,wFAAwF,WAAW;;;;;;;;ACVnG;;AAEA;;AAEA;;AAEA;AACA,wCAAwC,6BAA6B;AACrE,4BAA4B,6BAA6B;AACzD;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AClBA;;AAEA;;AAEA;AACA,KAAK,6BAA6B;AAClC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA,cAAc;AACd,oBAAoB;AACpB,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACtKA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU,SAAS,MAAM,qBAAqB,GAAG,qBAAqB;AACtE,4CAA4C,qCAAqC;AACjF;;AAEA,kBAAkB,uCAAuC;AACzD,kBAAkB,uCAAuC;AACzD,kBAAkB,0CAA0C;;AAE5D,8CAA8C,kBAAkB;AAChE;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,mFAAmF,kBAAkB;;AAErG;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACtEA;;AAEA;;AAEA;AACA,gBAAgB;;AAEhB;AACA;;AAEA,wFAAwF,WAAW;;;;;;;;ACVnG;;AAEA;;AAEA;AACA,iBAAiB;;AAEjB;AACA;;AAEA,wFAAwF,WAAW;;;;;;;;ACVnG;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kDAAkD,UAAU;AAC5D,2CAA2C,+BAA+B;AAC1E;AACA;AACA;AACA;;AAEA,gFAAgF,aAAa;;AAE7F;AACA;;AAEA;AACA;AACA;AACA;AACA,oEAAoE,qBAAqB;AACzF;;AAEA;AACA,yCAAyC,qBAAqB;AAC9D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,gBAAgB;AACnF,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;;AAEA,2BAA2B,cAAc;AACzC,gDAAgD,KAAK;AACrD,qEAAqE,iDAAiD;AACtH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,yEAAyE;AACzE;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;ACtMA;;AAEA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC3BA,kC;;;;;;;ACAA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,yDAAyD,SAAS;AAClE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC3DA,gC;;;;;;;ACAA;;AAEA;;AAEA,KAAK,mBAAmB;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,yEAAyE,oBAAoB;AAC7F,EAAE,6BAA6B;AAC/B;AACA;AACA;;AAEA;AACA,eAAe;;AAEf;AACA;AACA,6BAA6B,kBAAkB;AAC/C,oBAAoB,eAAe;AACnC,sCAAsC,kCAAkC;AACxE;;AAEA;AACA;AACA;AACA;AACA,0EAA0E,cAAc;AACxF;AACA;AACA,GAAG;;AAEH;AACA;AACA,4CAA4C,UAAU,IAAI,QAAQ;AAClE;;AAEA;AACA;;;;;;;;AC1DA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO,oCAAoC;AAC3C;AACA;AACA,yEAAyE,YAAY;AACrF,oEAAoE,sBAAsB;AAC1F;;;;;;;;ACfA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK,oCAAoC;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,MAAM;AAChC,0BAA0B,oBAAoB;AAC9C;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,cAAc;AACd,KAAK;AACL,cAAc;AACd;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,IAAI;AAC5B;AACA;AACA;AACA;;AAEA,2CAA2C,qBAAqB;AAChE;;AAEA;AACA;AACA;AACA,wBAAwB,IAAI;AAC5B;AACA;AACA;AACA;;AAEA,2CAA2C,qBAAqB;AAChE;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;AC1IA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACzBA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,QAAQ,SAAS,MAAM,qBAAqB,GAAG,qBAAqB;AACpE,8CAA8C,wCAAwC;AACtF,YAAY;AACZ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;AC/DA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;;AAEA;;;;;;;;ACnBA;;AAEA;AACA;AACA;;AAEA;;AAEA;;;;;;;;ACRA;;AAEA;;AAEA;;AAEA,KAAK,qCAAqC;AAC1C,KAAK,kCAAkC;;AAEvC,oCAAoC,mDAAmD;;AAEvF;AACA,8BAA8B,WAAW;AACzC;AACA;AACA,YAAY,OAAO;AACnB;;AAEA;AACA,8BAA8B,aAAa;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;AC3BA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iDAAiD,QAAQ;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iDAAiD,QAAQ;AACzD;AACA;;AAEA,kEAAkE;;AAElE;;;;;;;;AC3CA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM,SAAS;AACf;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA,2CAA2C,kBAAkB,kBAAkB,MAAM;AACrF,iEAAiE;AACjE;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,sEAAsE,cAAc;AACpF;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,sEAAsE,cAAc;AACpF,KAAK;AACL;;AAEA;AACA;;;AAGA;AACA,gBAAgB,eAAe;AAC/B;;AAEA;AACA,gBAAgB,eAAe;AAC/B;;AAEA;AACA,kBAAkB,aAAa,EAAE,eAAe;AAChD;;AAEA;AACA,kBAAkB,aAAa;AAC/B;;;;;;;;ACnHA;;AAEA;;AAEA;;AAEA;AACA,oBAAoB;AACpB;AACA,kBAAkB,iDAAiD;AACnE;AACA;;;;;;;;ACXA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,6CAA6C,kCAAkC,KAAK,cAAc;AAClG,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,iDAAiD,eAAe;AAChE;;AAEA;AACA,uDAAuD,eAAe;AACtE;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,KAAK;AAC3C;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA,wBAAwB,eAAe;AACvC;;AAEA;AACA;;;;;;;;AC3FA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;;;;;;;ACbA;;AAEA;;AAEA;AACA,gBAAgB;;AAEhB,KAAK,kCAAkC;AACvC;;AAEA,wFAAwF,WAAW;;;;;;;;ACVnG;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;AClBA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,qDAAqD;AACvE;AACA;AACA,wBAAwB,aAAa,SAAS,WAAW;AACzD;AACA;AACA;AACA;;AAEA,2CAA2C,QAAQ;AACnD;AACA;AACA,GAAG;AACH;AACA,gDAAgD,aAAa,+BAA+B,WAAW;AACvG,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;;;;;;;AClDA;;AAEA;;AAEA;AACA;;AAEA,8BAA8B,wDAAwD;AACtF;AACA,mBAAmB;AACnB,iDAAiD,gBAAgB;AACjE;;AAEA;AACA;AACA;;;;;;;;ACfA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,cAAc,gCAAgC;AAC9C;AACA;AACA;AACA;AACA,OAAO,uBAAuB;AAC9B;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;ACvEA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,iBAAiB;AAC/B;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA,uBAAuB,SAAS;AAChC,oDAAoD,YAAY;AAChE,YAAY,iBAAiB,EAAE,kBAAkB,GAAG,0BAA0B,EAAE,sBAAsB;AACtG;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA,+EAA+E,IAAI;AACnF;AACA,6BAA6B,eAAe;AAC5C,sCAAsC;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;ACxFA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B;AAC5B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,mCAAmC;AAClE;AACA;AACA;;AAEA;;;;;;;;ACvDA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,wCAAwC,4BAA4B,aAAa,kBAAkB;AACnG;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,UAAU;AACV;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,mCAAmC,4BAA4B,aAAa,kBAAkB;AAC9F;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,qDAAqD,wCAAwC;;AAE7F;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gCAAgC;;AAEhC;AACA;AACA,6BAA6B;AAC7B;;AAEA,UAAU;AACV;;AAEA;AACA;AACA,YAAY,2BAA2B,wBAAwB;AAC/D;;AAEA;AACA,YAAY,2BAA2B,uBAAuB;AAC9D;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA,8BAA8B,SAAS,oBAAoB;;AAE3D;AACA;;AAEA;AACA;AACA,YAAY,iBAAiB;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACrcA,kC;;;;;;ACAA,iC;;;;;;ACAA,kC;;;;;;;ACAA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA,uCAAuC,6CAA6C;AACpF,oCAAoC,0CAA0C;AAC9E,oCAAoC,0CAA0C;;AAE9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,gCAAgC,oBAAoB;AACpD;AACA;AACA,KAAK;;AAEL;AACA;AACA,+CAA+C,kCAAkC;AACjF;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;AACH;;AAEA;;AAEA;;;;;;;;ACvFA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gCAAgC;AAChC;AACA;;AAEA;AACA,gEAAgE,wDAAwD;AACxH;AACA,wDAAwD,6CAA6C;AACrG;AACA,mCAAmC,gEAAgE,EAAE;;AAErG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,aAAa,OAAO;AACpB;AACA;AACA,OAAO,wEAAwE;AAC/E;;AAEA;AACA,wFAAwF;;AAExF;;AAEA,kCAAkC;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,iBAAiB;AACvD;AACA,mBAAmB,OAAO;AAC1B,yBAAyB,OAAO;AAChC;AACA;AACA,OAAO,wDAAwD;;AAE/D,wBAAwB,uDAAuD;AAC/E;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,2BAA2B,OAAO;AAClC;AACA;AACA,OAAO,6CAA6C;AACpD;AACA;AACA;AACA;AACA,iDAAiD,2DAA2D;;AAE5G;AACA;AACA,0DAA0D,sBAAsB;AAChF;AACA,GAAG;AACH;AACA,kCAAkC,sBAAsB,mBAAmB,mBAAmB;AAC9F;AACA;AACA;;AAEA;;;;;;;;ACrIA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB,oBAAoB,sCAAsC;AACnG;AACA;;AAEA;AACA;;AAEA,iBAAiB,uCAAuC;AACxD;;AAEA;AACA;;AAEA;AACA,gEAAgE;;AAEhE;AACA;AACA,yBAAyB,oBAAoB,0DAA0D,wBAAwB;AAC/H;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB,oBAAoB,sCAAsC;AACnG;AACA;;AAEA;AACA;;AAEA,iBAAiB,uCAAuC;AACxD;;AAEA;AACA;;AAEA;AACA,gEAAgE;;AAEhE;AACA;AACA,yBAAyB,oBAAoB,2DAA2D,wBAAwB;AAChI;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACpFA,oC;;;;;;;ACAA;;AAEA;AACA;AACA,oHAAoH;AACpH,4DAA4D,aAAa;AACzE,GAAG;AACH;;;;;;;;ACPA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,gFAAgF,cAAc;AAC9F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;;;;;;;ACvFA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,6DAA6D,oDAAoD,EAAE;AACnH;AACA,0FAA0F,YAAY;AACtG;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qCAAqC,kBAAkB,qBAAqB,iBAAiB,gBAAgB,qBAAqB,gBAAgB,OAAO;AACzJ;AACA;AACA;;AAEA;AACA,yBAAyB,2BAA2B;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB,aAAa,6DAA6D,KAAK;AACxG;AACA;;AAEA;AACA;AACA,yCAAyC,kBAAkB,qBAAqB,iBAAiB,gBAAgB,qBAAqB;AACtI;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO,6CAA6C;;AAEpD;AACA,qDAAqD,aAAa;AAClE;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,6FAA6F,cAAc;AAC3G;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpJA;;AAEA,KAAK,iBAAiB,UAAU,EAAE;AAClC,KAAK,SAAS;AACd;;AAEA,iCAAiC,iCAAiC;AAClE;AACA;AACA;;AAEA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA,0BAA0B,WAAW;AACrC;;AAEA,WAAW,iBAAiB;AAC5B;;AAEA,mCAAmC,kDAAkD;AACrF;AACA,8BAA8B,EAAE;AAChC,sCAAsC,EAAE;AACxC,mDAAmD,EAAE;AACrD,2DAA2D,EAAE;AAC7D;AACA;AACA;AACA;;AAEA,wCAAwC,sCAAsC;AAC9E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;AC3CA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mCAAmC,aAAa,KAAK,8BAA8B,OAAO;AACnH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8EAA8E,MAAM;AACpF,YAAY,YAAY,GAAG,QAAQ,EAAE,mBAAmB;AACxD;;AAEA;AACA;AACA;;;;;;;;ACvBA;;AAEA;;AAEA;AACA;AACA,0BAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,eAAe;AACtD,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,CAAC;;AAED;;AAEA;AACA,mBAAmB;AACnB;AACA,uBAAuB,sCAAsC;AAC7D;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;ACrBA,kC;;;;;;;ACAA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH,cAAc,oBAAoB;AAClC;AACA;;AAEA;AACA;AACA;;;;;;;ACnBA,kBAAkB,+JAA+J,gHAAgH,WAAW,wBAAwB,eAAe,0EAA0E,8BAA8B,4dAA4d,WAAW,8EAA8E,wCAAwC,+uBAA+uB,oBAAoB,0tBAA0tB,YAAY,kCAAkC,iDAAiD,yBAAyB,gLAAgL,iC;;;;;;ACA7xF,oC;;;;;;;ACAA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;AC3BA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;;;;;;ACvBA,oC;;;;;;;ACAA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtBA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA,4CAA4C,WAAW;AACvD;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,kCAAkC;AACzD,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;ACzDA,+C;;;;;;;ACAA;;AAEA;;AAEA,KAAK,sBAAsB;AAC3B,KAAK,mDAAmD;AACxD,KAAK,OAAO;;AAEZ,qBAAqB,iCAAiC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,OAAO;AACP;AACA;AACA,iCAAiC,kCAAkC;AACnE;;AAEA;AACA;AACA;;;;;;;;ACjCA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ,UAAU,UAAU;AAChD;AACA;AACA;;AAEA,6CAA6C,MAAM;AACnD,uEAAuE,cAAc;;AAErF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACpEA,0C;;;;;;;ACAA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,mFAAmF,EAAE;AACrF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qBAAqB,EAAE;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,gDAAgD,SAAS,UAAU,EAAE,UAAU,QAAQ,0BAA0B,EAAE;AACnH,KAAK;AACL;AACA;AACA,iCAAiC,eAAe,EAAE;AAClD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA,yBAAyB,gBAAgB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,sBAAsB,KAAK,UAAU,QAAQ,GAAG,KAAK;AACrD;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA,8BAA8B,sCAAsC;AACpE,gCAAgC,sDAAsD;AACtF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,wDAAwD,IAAI;AAC5D;AACA,OAAO;;AAEP;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,wDAAwD,IAAI;AAC5D;AACA,OAAO;;AAEP;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,mDAAmD,iBAAiB;;AAEpE;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA,wDAAwD,IAAI;AAC5D;AACA,OAAO;;AAEP;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACzLA,mC;;;;;;;ACAA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,mCAAmC,iCAAiC;AACpE,6BAA6B,iCAAiC;;AAE9D;AACA;AACA;AACA,gDAAgD,oCAAoC;;AAEpF;AACA;AACA;;AAEA;AACA,8CAA8C,WAAW;AACzD,0CAA0C,UAAU;;AAEpD;AACA;;AAEA;AACA;;AAEA,uGAAuG;;AAEvG,sEAAsE,WAAW;;AAEjF;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,mCAAmC;AAChF,iDAAiD,gBAAgB;AACjE;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,sCAAsC,YAAY;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;ACxIA,wC;;;;;;ACAA,0C;;;;;;ACAA,wC;;;;;;ACAA,+C;;;;;;;ACAA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACrBA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;;;;;;;;AC5BA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kCAAkC;AACxD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;AC5CA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA,sBAAsB,UAAU;AAChC;;AAEA;AACA,qBAAqB,MAAM,WAAW,cAAc;AACpD;AACA;;;;;;;AC1KA,yC;;;;;;;ACAA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,aAAa;AAC3C;AACA;AACA;;;;;;;;AC3DA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;;;;;;;ACVA;;AAEA;;AAEA;AACA,0BAA0B;;AAE1B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,cAAc;AAC1C;AACA;;;;;;;;AC5BA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;;;;;;ACjDA,4C;;;;;;;ACAA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;ACfA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AChBA,gC;;;;;;;ACAA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qFAAqF,EAAE;AACvF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,sBAAsB,KAAK,UAAU,iBAAiB,GAAG,cAAc;AACvE;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL,4DAA4D,8BAA8B,OAAO,2BAA2B;AAC5H;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;ACxHA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;AC9BA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;;;ACzEA,kC;;;;;;;ACAA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9BA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;;;;;;;;ACxBA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,kEAAkE,SAAS;;AAE3E;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA,kEAAkE,qBAAqB;AACvF;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;ACpDA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,4CAA4C;AACrH;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mDAAmD,8BAA8B,oBAAoB,0BAA0B;;AAE/H;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,8BAA8B,8BAA8B;AAC5D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gBAAgB,GAAG,aAAa;AAC7E;AACA;;AAEA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;;AC/JA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;ACfA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpBA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;ACfA,mC;;;;;;;ACAA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,+BAA+B,uCAAuC;AACtE;AACA;AACA,sEAAsE,kBAAkB;AACxF;AACA,yDAAyD,kBAAkB,oBAAoB,cAAc;AAC7G;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,4DAA4D,YAAY;AACxE;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;;;;;;;ACxCA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB;AACpB;;AAEA;AACA,uBAAuB,iEAAiE;AACxF;;AAEA;;;;;;;;ACjBA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACnBA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;ACfA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;ACjBA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wDAAwD,OAAO;AAC/D,wEAAwE,6BAA6B;AACrG,wBAAwB,uEAAuE;AAC/F,4DAA4D,YAAY;AACxE,KAAK;AACL;AACA;;;;;;;ACnBA,mC;;;;;;;ACAA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;;;;;;;;ACbA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;ACpCA;;AAEA;;AAEA;AACA;AACA;;AAEA,oBAAoB;;AAEpB,iDAAiD,cAAc;;AAE/D;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,sDAAsD,SAAS;AAC/D;AACA,KAAK;AACL;;AAEA;AACA;AACA;;;;;;;;AClCA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iHAAiH,mDAAmD;AACpK,iFAAiF,cAAc;AAC/F,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,eAAe;AAC3D,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,4BAA4B,gBAAgB,SAAS,kBAAkB;AACvE,0CAA0C,qBAAqB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;;AAEA;AACA,2BAA2B,aAAa,SAAS,WAAW;AAC5D,0CAA0C,qBAAqB;AAC/D;;AAEA;AACA,2BAA2B,aAAa,SAAS,WAAW;AAC5D;AACA;;AAEA,0CAA0C,qBAAqB;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,cAAc;AAC5E;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;;AAEA;AACA;AACA,yBAAyB,gBAAgB,SAAS,sBAAsB;AACxE;AACA,GAAG;AACH;;AAEA,yCAAyC,eAAe;AACxD;AACA;AACA;AACA,6BAA6B,eAAe;AAC5C,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA;AACA,8DAA8D,iBAAiB;AAC/E;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,GAAG;AACH;;AAEA;AACA,8BAA8B,+BAA+B;AAC7D;;AAEA;AACA,oDAAoD,UAAU,GAAG,IAAI,IAAI,MAAM;AAC/E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5KA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;ACfA;;AAEA;;AAEA;AACA,gDAAgD,kCAAkC;;AAElF;;;;;;;;ACPA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sBAAsB;;AAEtB;AACA;AACA;AACA,mDAAmD,8DAA8D;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,+CAA+C;AAC7F;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;AC5CA,0C;;;;;;;ACAA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;;;;;;;AC7BA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,yCAAyC,QAAQ,yBAAyB,OAAO;AACjF;;AAEA;AACA,0DAA0D,cAAc;AACxE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,kBAAkB,KAAK,oBAAoB;AAC/D;AACA,iCAAiC,+BAA+B;AAChE;AACA;AACA,0CAA0C,uCAAuC;AACjF;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG,iBAAiB,eAAe,GAAG,YAAY;;AAElD;AACA;AACA;AACA;AACA;AACA,KAAK,iBAAiB,uBAAuB;AAC7C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;AC5GA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA,iGAAiG,qBAAqB;;AAEtH;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA,iHAAiH,6BAA6B;;AAE9I;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACnLA,8C;;;;;;;ACAA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AClCA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;;;;;;;ACTA;;AAEA;;AAEA;;AAEA;AACA,iCAAiC,wBAAwB;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,gBAAgB;AACnE,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;AC3CA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wDAAwD,eAAe,6CAA6C,YAAY,sBAAsB,uBAAuB;AAC7K;AACA,OAAO;AACP,+GAA+G,YAAY,KAAK,uBAAuB;AACvJ,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChFA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;ACfA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,oDAAoD,MAAM;;AAE1D;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;;;;;;;ACrBA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,sBAAsB,+BAA+B;AACrD;AACA;;AAEA;AACA,4BAA4B,oBAAoB;AAChD;AACA;;AAEA;;;;;;;;ACrBA;;AAEA;;AAEA;AACA;;AAEA;AACA,iCAAiC,wBAAwB;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;;;;;;;AC/DA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,iCAAiC,wBAAwB;AACzD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5CA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;;;;;;;ACpBA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;ACfA;;AAEA;;AAEA;;AAEA;AACA,iCAAiC,wBAAwB;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mDAAmD,gBAAgB;AACnE,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;;;;;;;ACzCA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,GAAG;AACH;AACA;AACA;AACA,qCAAqC;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;;;;;;ACrCA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;;;;;;;AClBA;;AAEA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;;;;;;;ACZA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gDAAgD,mCAAmC;;AAEnF;AACA,wCAAwC,2BAA2B;;AAEnE;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;;;;;;;ACzBA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,oBAAoB;AACxD;;AAEA;AACA,iCAAiC,wBAAwB;AACzD;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kDAAkD,aAAa;AAC/D,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C,yBAAyB;AACnE;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,uBAAuB,qBAAqB,SAAS;AACxE;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;;;;;;;;ACvEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yCAAqC;AACrC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;;;;;;ACnBA,oC;;;;;;;ACAA;;AAEA;;AAEA;;;;;;;;ACJA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,WAAW,IAAI,cAAc;AAC7G,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;ACnEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0FAA0F,KAAK,WAAW,GAAG,WAAW,SAAS,KAAK;AACtI,KAAK;AACL,qDAAqD;AACrD;AACA;;;;;;;;AC5EA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS,8DAA8D,gBAAgB;AACvF;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,WAAW,0BAA0B,4BAA4B,KAAK,EAAE;AACxE;AACA;AACA;AACA,aAAa,2DAA2D,gBAAgB;AACxF;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;;AAEA;AACA;AACA,4CAA4C,uBAAuB;AACnE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,kEAAkE,oCAAoC;AACtG,mBAAmB,oCAAoC;AACvD,+BAA+B,SAAS,iCAAiC;AACzE,KAAK;AACL,GAAG;AACH;;;AAGA;AACA,cAAc,KAAK;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;;AAGA;AACA,cAAc,KAAK;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,eAAe;AAC5C,GAAG;AACH;;AAEA;AACA,cAAc,KAAK;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,oCAAoC;AAChE,GAAG;AACH;;AAEA;AACA,cAAc,KAAK;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,oCAAoC;AAC7E,GAAG;AACH;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,mCAAmC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA,6BAA6B,mCAAmC;AAChE;AACA;AACA;AACA;AACA;AACA,uBAAuB,WAAW,aAAa,EAAE,EAAE;AACnD;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,cAAc,KAAK;AACnB;AACA;AACA,SAAS,iCAAiC;AAC1C;AACA;;AAEA,6BAA6B,mCAAmC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,cAAc,KAAK;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,mCAAmC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,cAAc,KAAK;AACnB;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,mCAAmC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChWA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;ACTA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,oCAAoC,8DAA8D;AAClG,6BAA6B,mCAAmC;AAChE;AACA;AACA;;AAEA;;;;;;;;ACfA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;;;;;;;;AC1CA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,kCAAkC,cAAc;AAChD;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;;;;;;;;AC9BA;;AAEA;;AAEA;;AAEA;AACA,oBAAoB;;AAEpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;;;;;;;AClBA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;ACfA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,0BAA0B,gDAAgD;AAC1E;;AAEA;AACA,0BAA0B,oCAAoC;AAC9D,0BAA0B,mDAAmD;AAC7E;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AChCA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD,WAAW,oCAAoC,WAAW,KAAK,qBAAqB;AAC3I;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,iCAAiC,qBAAqB,SAAS,wBAAwB;;AAEvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,+CAA+C,QAAQ;AACvD;;;;;;;;ACpGA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kGAAkG,cAAc;AAChH,+EAA+E,cAAc;;AAE7F;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sDAAsD;AACtD;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,8CAA8C,4DAA4D;;AAE1G;AACA;AACA;AACA;;AAEA,uDAAuD;AACvD;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,8CAA8C,0DAA0D;AACxG,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACpFA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,mEAAmE,4BAA4B;AAC/F,KAAK;AACL,iFAAiF,cAAc;AAC/F;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;AC3CA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;ACfA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,2KAA2K;AAC3K;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,yDAAyD,SAAS;AAClE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA,0DAA0D,cAAc;AACxE;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,oDAAoD,UAAU;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qDAAqD,cAAc;AACnE;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;;;;;;;ACrIA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,SAAS,mDAAmD,SAAS;AACnG;AACA;;AAEA;AACA;AACA,kCAAkC,aAAa,mDAAmD,SAAS;AAC3G;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,SAAS,gDAAgD,SAAS;AAChG;AACA;;AAEA;AACA;AACA,kCAAkC,aAAa,gDAAgD,SAAS;AACxG;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACjHA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;;AAEA;AACA,uBAAuB,mCAAmC;AAC1D;;AAEA;;;;;;;;ACrBA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,oDAAoD,uBAAuB;AAC3E;AACA;AACA;;AAEA;;;;;;;;AClBA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,4CAA4C,6BAA6B;AACzE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,gBAAgB;AACnF,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;;;;;;;;ACjCA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;;AAEA;AACA,uBAAuB,mCAAmC;AAC1D;;AAEA;;;;;;;;ACrBA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,oDAAoD,uBAAuB;AAC3E;AACA;AACA;;AAEA;;;;;;;;AClBA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,0CAA0C,6BAA6B;AACvE;;AAEA;AACA;AACA;AACA;AACA;AACA,mEAAmE,gBAAgB;AACnF,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;;;;;;;;ACxBA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,wCAAwC;AAC/D;AACA;AACA,mBAAmB,oCAAoC;AACvD;AACA,oDAAoD,qDAAqD;AACzG;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;;;;;;;;AC3BA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,KAAK;AAClE;;AAEA,qBAAqB,aAAa;AAClC;AACA;AACA,KAAK;AACL,GAAG;AACH;;;;;;;;ACtCA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACVA;;AAEA;;AAEA;;AAEA;AACA;AACA,oCAAoC,qBAAqB,cAAc,EAAE;;AAEzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA,sDAAsD,kCAAkC;AACxF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;;;;;;;AC/BA;;AAEA;;AAEA;AACA,KAAK,eAAe;;AAEpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,IAAI;AAC3E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oDAAoD,MAAM;AAC1D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,gCAAgC;AAC9E;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACtHA;;AAEA;;AAEA;AACA;AACA,gEAAgE,OAAO;AACvE;;AAEA;;;;;;;;ACTA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,cAAc;AACd,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8CAA8C,YAAY;AAC1D;;AAEA;AACA;AACA;;;;;;;AC5HA,mC;;;;;;;ACAA;;AAEA;AACA;;AAEA;AACA,0CAA0C,iBAAiB,YAAY,IAAI,WAAW;AACtF;AACA;;AAEA,kBAAkB;;;;;;;;ACVlB;;AAEA;;AAEA;AACA,KAAK,4BAA4B;AACjC;AACA,KAAK,WAAW;AAChB,KAAK,YAAY;AACjB,KAAK,sBAAsB;AAC3B;;AAEA;AACA;AACA;AACA,kCAAkC,UAAU;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mBAAmB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,eAAe,sBAAsB;AACrC;AACA,KAAK;AACL;AACA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,gBAAgB;;AAEvD;AACA,kCAAkC,mBAAmB;AACrD;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA,KAAK;AACL;AACA;;AAEA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,OAAO,gBAAgB,YAAY;AAC7D;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnHA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uDAAuD,EAAE;AACzD,KAAK;;AAEL;AACA,aAAa,iFAAiF,EAAE;AAChG,KAAK;;AAEL;AACA,wEAAwE,EAAE;AAC1E,KAAK;;AAEL;;AAEA;AACA;AACA,KAAK;AACL,sDAAsD,oBAAoB,iBAAiB,gBAAgB;AAC3G,qDAAqD,gBAAgB;AACrE;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;;;;;;;AC5ClB;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,iBAAiB;AACtB,KAAK,8BAA8B;;AAEnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC,UAAU;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,0BAA0B,mBAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C,cAAc;AACxD;;AAEA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA,mCAAmC,IAAI;AACvC;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;;AAEA;AACA;;AAEA,0BAA0B,gBAAgB;AAC1C;AACA;AACA;AACA;AACA,mCAAmC,IAAI;AACvC;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1IA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,iBAAiB;AACtB,KAAK,8BAA8B;;AAEnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC,UAAU;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mBAAmB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C,cAAc;AACxD;;AAEA,iCAAiC,mBAAmB;AACpD;AACA;AACA;AACA;AACA,0CAA0C,IAAI;AAC9C;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;;AAEA,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA;AACA,0CAA0C,IAAI;AAC9C;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvIA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK,YAAY;AACjB;AACA,KAAK,iBAAiB;AACtB,KAAK,8BAA8B;;AAEnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,UAAU;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,wCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C,cAAc;AACxD;;AAEA,yCAAyC,mBAAmB;AAC5D;AACA;AACA;AACA;AACA,4CAA4C,IAAI;AAChD;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,qCAAqC;AACrC;AACA;AACA;;AAEA;AACA;;AAEA,wCAAwC,gBAAgB;AACxD;AACA;AACA;AACA;AACA,4CAA4C,YAAY;AACxD;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxIA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,KAAK,iBAAiB;AACtB,KAAK,8BAA8B;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,sCAAsC,2BAA2B;AACjE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8BAA8B;AAC7D,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc;;AAEjD,qCAAqC,mBAAmB;AACxD;AACA;AACA;AACA;AACA,uCAAuC,gBAAgB;AACvD;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAuC,gBAAgB;AACvD,2CAA2C,gBAAgB;AAC3D;AACA;AACA;AACA;AACA,uCAAuC,gBAAgB;AACvD;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,oDAAoD,sBAAsB,gBAAgB,kBAAkB;AAC5G;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,qCAAqC,2BAA2B,EAAE;AAC1G,mCAAmC,OAAO,6BAA6B,YAAY;AACnF;;AAEA;AACA;AACA,YAAY,QAAQ,0BAA0B,cAAc,2BAA2B,EAAE;AACzF,oCAAoC,OAAO,MAAM,YAAY;AAC7D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnMA;;AAEA;;AAEA,KAAK,kCAAkC;AACvC;AACA;AACA;;AAEA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;ACvBA;;AAEA;;AAEA;AACA,KAAK,eAAe;AACpB;AACA;;AAEA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iCAAiC,SAAS;AAC1C;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;;;;;;;AC3CA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK,2EAA2E;AAChF,KAAK,gCAAgC;;AAErC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB,yDAAyD;AAC/E;AACA;AACA,oDAAoD,YAAY;AAChE;AACA;AACA;AACA,0BAA0B,wBAAwB;AAClD,wBAAwB,2CAA2C;AACnE,yBAAyB,2CAA2C;AACpE;;AAEA;AACA;AACA,6BAA6B,sBAAsB;AACnD,wBAAwB,8CAA8C;AACtE,yBAAyB,8CAA8C;AACvE;;AAEA;AACA;AACA;AACA;AACA,sDAAsD,EAAE;AACxD,wEAAwE,EAAE;AAC1E,SAAS;AACT;AACA;;AAEA;AACA,yCAAyC,kBAAkB;AAC3D,uEAAuE,kBAAkB;AACzF;;AAEA;AACA,KAAK;AACL;;;AAGA;;;;;;;;AC1DA;;AAEA;;AAEA;AACA,KAAK,gBAAgB;AACrB,KAAK,uCAAuC;AAC5C;AACA,KAAK,4BAA4B;AACjC;AACA,KAAK,YAAY;AACjB,KAAK,sBAAsB;AAC3B,KAAK,iBAAiB;AACtB,KAAK,8BAA8B;;AAEnC;;AAEA;AACA;AACA;AACA,kCAAkC,UAAU;AAC5C;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,SAAS;AAClB;AACA;AACA,KAAK;AACL;AACA,cAAc;AACd,KAAK;AACL;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA,4BAA4B,YAAY,EAAE;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;;AAEA;AACA,4BAA4B,YAAY,EAAE;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+CAA+C,QAAQ;AACvD,8CAA8C,mBAAmB;AACjE;AACA;AACA;AACA;AACA,sCAAsC,oBAAoB,GAAG,cAAc;AAC3E;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,+BAA+B,YAAY,EAAE;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC,gBAAgB;AACtD;AACA;AACA;AACA;AACA,sCAAsC,oBAAoB,GAAG,cAAc;AAC3E;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClNA;;AAEA;;AAEA,KAAK,eAAe;AACpB;AACA;;AAEA;AACA;AACA,2BAA2B,mCAAmC;AAC9D,qDAAqD,gBAAgB;AACrE,YAAY,SAAS,kBAAkB,EAAE,2BAA2B,kBAAkB;AACtF,4DAA4D,gBAAgB;AAC5E;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU,kBAAkB;AAC5B;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;;;;;;;AChCA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,iBAAiB;AACtB,KAAK,8BAA8B;;AAEnC;AACA;AACA;AACA,kCAAkC,UAAU;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,sCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ,cAAc;AACrD;AACA,uCAAuC,mBAAmB;AAC1D;AACA;AACA;AACA;AACA,gDAAgD,uBAAuB;AACvE;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,gBAAgB;AACtD;AACA;AACA;AACA;AACA,gDAAgD,uBAAuB;AACvE;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrIA;;AAEA;;AAEA;AACA,iBAAiB;;AAEjB;AACA;;AAEA,wFAAwF,WAAW;;;;;;;;ACVnG;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,iBAAiB;AACtB,KAAK,8BAA8B;;AAEnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC,UAAU;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,6BAA6B,mBAAmB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C,oBAAoB;AAC9D;;AAEA,8BAA8B,mBAAmB;AACjD;AACA;AACA;AACA;AACA,sCAAsC,IAAI;AAC1C;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;;AAEA;AACA;;AAEA,6BAA6B,gBAAgB;AAC7C;AACA;AACA;AACA;AACA,sCAAsC,IAAI;AAC1C;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1IA;;AAEA;;AAEA;AACA,cAAc,IAAI,IAAI;AACtB;;AAEA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzBA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK,iBAAiB;AACtB,KAAK,8BAA8B;;AAEnC;AACA;AACA;AACA,kCAAkC,UAAU;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,KAAK,EAAE;AAChC;AACA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,0BAA0B,mBAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA,KAAK;AACL;AACA;;AAEA;AACA,yBAAyB,KAAK,EAAE;AAChC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,mCAAmC,+BAA+B,GAAG,cAAc;AACnF;;AAEA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA,mCAAmC,YAAY,GAAG,cAAc;AAChE;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,eAAe,YAAY,GAAG,cAAc;AAC5C;AACA,KAAK;AACL;AACA;;AAEA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,kCAAkC;AAC5D;AACA;AACA;AACA;AACA,mCAAmC,YAAY;AAC/C;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,4BAA4B,KAAK,EAAE,QAAQ;AAC3C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,kCAAkC,oBAAoB,8EAA8E;AAC9J;AACA;AACA;AACA;AACA,mCAAmC,YAAY,GAAG,cAAc;AAChE;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,eAAe,YAAY,GAAG,cAAc;AAC5C;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3LA;;AAEA;;AAEA;AACA;AACA,KAAK,mCAAmC;AACxC,KAAK,YAAY;AACjB,KAAK,sBAAsB;AAC3B,KAAK,uCAAuC;AAC5C;AACA;AACA,KAAK,4BAA4B;AACjC;AACA,KAAK,WAAW;AAChB,KAAK,wBAAwB;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC,UAAU;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,WAAW,QAAQ;AACxB;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,oCAAoC,MAAM;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,YAAY;AAC/C,+BAA+B,2CAA2C;;AAE1E;AACA;AACA;AACA;AACA,gDAAgD,mBAAmB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,sDAAsD,cAAc;AACpE;AACA,mCAAmC,YAAY;AAC/C,+BAA+B,2CAA2C;;AAE1E;AACA;AACA;AACA;AACA,iDAAiD,mBAAmB;AACpE;AACA;AACA;AACA;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,KAAK;AACL;AACA;;AAEA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA,uCAAuC,gBAAgB;AACvD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1LA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,2BAA2B,mCAAmC;AAC9D,qDAAqD,gBAAgB;AACrE,YAAY,SAAS,kBAAkB,EAAE,2BAA2B,kBAAkB;AACtF,4DAA4D,gBAAgB;AAC5E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;;;;;;;ACzEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,uBAAuB,sBAAsB;;AAE7C;AACA;AACA;;AAEA;AACA,uBAAuB,QAAQ;AAC/B;;AAEA;AACA;;AAEA;AACA,uBAAuB,QAAQ;AAC/B;;AAEA;;AAEA;AACA,uBAAuB,QAAQ;AAC/B;;AAEA;AACA,2CAA2C,QAAQ;;AAEnD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,SAAS,wCAAwC,oBAAoB;AAClG;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;AC1EA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;ACfA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,8BAA8B;AACnC,OAAO,sBAAsB;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA,gCAAgC,MAAM;AACtC;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,GAAG;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA,kDAAkD,4BAA4B;AAC9E;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4FAA4F,IAAI;AAChG;;AAEA,qCAAqC,0BAA0B;AAC/D;AACA;AACA;AACA,KAAK;AACL;AACA,2BAA2B,uBAAuB,uBAAuB,cAAc;AACvF;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uDAAuD,YAAY,kCAAkC,GAAG;AACxG,gBAAgB,QAAQ;AACxB;AACA;AACA;;AAEA;AACA,oDAAoD,MAAM;AAC1D;AACA;AACA;;AAEA;AACA;AACA,kEAAkE,mBAAmB;AACrF;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP,4CAA4C,OAAO;AACnD;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,+BAA+B,IAAI;AACnC;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,gCAAgC,MAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC,wDAAwD;AACxF,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtNA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,YAAY,SAAS,WAAW,YAAY,YAAY,GAAG,MAAM;AAC7F,gEAAgE,MAAM;AACtE;AACA;;AAEA;;AAEA;AACA,sDAAsD,sBAAsB;AAC5E;AACA,GAAG;AACH;AACA,yEAAyE,YAAY,yCAAyC,eAAe;AAC7I;AACA;;AAEA;;;;;;;;ACjCA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA,WAAW,mEAAmE;;AAE9E;AACA;AACA;AACA;AACA,wCAAwC,KAAK,2BAA2B,oCAAoC;AAC5G;AACA;AACA,yCAAyC,aAAa,4BAA4B,+BAA+B;AACjH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,2FAA2F,YAAY,WAAW,eAAe;AACjI;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,uDAAuD,gBAAgB;AACvE;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,4DAA4D,iCAAiC;AAC7F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oDAAoD,iCAAiC;AACrF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6CAA6C,iCAAiC;AAC9E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6CAA6C,iCAAiC;AAC9E;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;ACzMA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;AAGA;;;;;;;;ACrBA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;ACZA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT,cAAc,uBAAuB;AACrC,yCAAyC;AACzC,oCAAoC,wBAAwB,eAAe;AAC3E;AACA;AACA;;;;;;;;ACrBA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,6CAA6C;AACxD;AACA,gBAAgB,QAAQ,0CAA0C,KAAK;AACvE;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpCA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2BAA2B,GAAG,uBAAuB;AAC/E,0BAA0B,uBAAuB,GAAG,0BAA0B;;AAE9E;AACA;AACA,kBAAkB,SAAS,GAAG,SAAS;AACvC,SAAS;AACT,OAAO;AACP;AACA;;;;;;;;ACrBA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;ACRA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA,kCAAkC,eAAe;;AAEjD;AACA;AACA;;AAEA;;AAEA;AACA,8DAA8D,kBAAkB;AAChF;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA,4CAA4C;AAC5C;AACA;;AAEA;AACA;AACA;;AAEA;AACA,YAAY;AACZ,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,2BAA2B,mBAAmB;AACxD;;AAEA;AACA,UAAU;AACV;;AAEA;AACA,UAAU,2BAA2B,aAAa;AAClD;;AAEA;;;;;;;ACjFA,4C;;;;;;;ACAA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;ACfA;;AAEA;AACA;;AAEA;;AAEA,iEAAiE,OAAO;;AAExE;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;;AAEpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;;;;;;;AC5BA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iHAAiH,mBAAmB,oCAAoC,oBAAoB,KAAK,cAAc;AAC/M;AACA,KAAK;;AAEL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,qBAAqB,oCAAoC;AACzD;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,MAAM,GAAG;AAC1C,OAAO;;AAEP;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,8DAA8D,iCAAiC;AAC/F;AACA;AACA;AACA;AACA;;AAEA,2EAA2E,QAAQ;AACnF;AACA;AACA;AACA;AACA,iEAAiE,4BAA4B;AAC7F;;AAEA;AACA;AACA;AACA;AACA,sEAAsE,2BAA2B;AACjG,KAAK;AACL;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,iEAAiE,oCAAoC;AACrG;AACA;AACA;AACA;AACA;;AAEA,iFAAiF,QAAQ;AACzF;AACA;AACA;AACA;AACA,oEAAoE,4CAA4C;AAChH;;AAEA;AACA;AACA;AACA;AACA,yEAAyE,2CAA2C;AACpH,KAAK;AACL;AACA;;AAEA;AACA,GAAG;AACH;;;;;;;;ACzKA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,2BAA2B;AACpD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;AC7DA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,0BAA0B;AAC1E;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,gDAAgD,oBAAoB;AACpE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mCAAmC,YAAY,EAAE,eAAe;;AAEhE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,+CAA+C,QAAQ;AACvD;;;;;;;;ACrDA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACnDA;;AAEA;;AAEA;AACA;AACA,KAAK,sCAAsC;AAC3C,KAAK,wCAAwC;;AAE7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,aAAa,+BAA+B,EAAE,yBAAyB;AACtG;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;;;;;;;AChCA;AACA,8CAA8C,cAAc;AAC5D,yBAAyB,0GAA0G;AACnI;AACA,0DAA0D,gBAAgB,eAAe,YAAY,gBAAgB,aAAa,iBAAiB,cAAc,QAAQ,KAAK,gBAAgB,aAAa,eAAe,YAAY,GAAG,WAAW,0BAA0B;AAC9Q;AACA;;;;;;;;ACNA;AACA,8CAA8C,cAAc;AAC5D,yBAAyB,uHAAuH;AAChJ;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,YAAY;AACZ,gBAAgB;AAChB,UAAU;AACV,SAAS;AACT,eAAe;AACf;AACA,kBAAkB;AAClB,oBAAoB;AACpB,iBAAiB;AACjB,iBAAiB;AACjB,gBAAgB;AAChB,gBAAgB,YAAY;AAC5B;AACA;;;;;;;;ACvBA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,cAAc;AAC9D;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC,QAAQ;AAC/C;;;;;;;;AClDA;;AAEA;;AAEA;AACA;;AAEA,kDAAkD,uBAAuB;AACzE;AACA;;AAEA,oBAAoB;AACpB;AACA,oCAAoC,UAAU;AAC9C;;;;;;;;ACdA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,OAAO,UAAU;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,oDAAoD,QAAQ;AAC5D;AACA,KAAK;AACL,4EAA4E,cAAc;AAC1F,KAAK;AACL;AACA;;AAEA;AACA;AACA;;;;;;;;ACnCA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;ACfA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,2BAA2B;AACpD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,KAAK;AACL;AACA;;;;;;;;ACtDA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,QAAQ;AAC7C;;;;;;;;AC9CA;;AAEA;;AAEA;;AAEA;AACA;AACA,aAAa,iCAAiC;AAC9C,gCAAgC,6BAA6B;AAC7D;;;;;;;;ACVA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;ACbA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,qBAAqB;AACxE;AACA;AACA,2CAA2C,qBAAqB;AAChE;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,kCAAkC,WAAW,GAAG,cAAc,GAAG,UAAU;AAC3E;AACA;AACA;;;;;;;;ACnCA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;ACfA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2CAA2C;AAC3C;AACA;;;;;;;;AChCA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB;AACpB;;AAEA;AACA,uBAAuB,wCAAwC;AAC/D;;AAEA;;;;;;;;ACjBA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,wDAAwD,0CAA0C;AAClG;;AAEA,4DAA4D,WAAW;;AAEvE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;;;;;;;;AC5DA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,gBAAgB,SAAS,WAAW,YAAY,YAAY,GAAG,aAAa;AAChG,oBAAoB,gBAAgB,SAAS,WAAW,YAAY,YAAY;;AAEhF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;ACnCA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,gBAAgB,YAAY,YAAY,GAAG,eAAe;AACnF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;ACvBA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gBAAgB,YAAY,YAAY,GAAG,eAAe;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oBAAoB;AAClD,yBAAyB,gBAAgB;AACzC,4BAA4B,YAAY;AACxC,qBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;AC7CA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;AC3BA;;AAEA;;AAEA;AACA;AACA;AACA,wBAAwB,aAAa;AACrC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;AChBA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,2BAA2B,mCAAmC;AAC9D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;ACrCA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,4DAA4D,IAAI;AAChE;AACA;AACA;AACA;AACA,oDAAoD,UAAU;AAC9D,SAAS;AACT;AACA,OAAO;AACP,KAAK;AACL,oDAAoD,IAAI;AACxD;AACA;AACA;AACA;AACA,oEAAoE,IAAI;AACxE,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,sDAAsD,aAAa;AACnE;AACA,OAAO;AACP;AACA,gDAAgD,YAAY;AAC5D;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;;;;;;;AChEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,IAAI,2BAA2B,oBAAoB,IAAI,uBAAuB;AACxH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA,kBAAkB;;;;;;;;AC5BlB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,kBAAkB,sCAAsC;AACxD,aAAa;AACb,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,cAAc;AACd,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,6BAA6B;;AAEhD;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,iCAAiC,oBAAoB,+BAA+B;AAC7H,KAAK;;AAEL,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,wDAAwD,iCAAiC;AACzF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qDAAqD,iCAAiC;AACtF;AACA;AACA;AACA;AACA;;;;;;;;ACnEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,6BAA6B,wBAAwB;;AAErD,gGAAgG,cAAc;;AAE9G;AACA;;AAEA,wCAAwC,wBAAwB;AAChE,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9CA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,6BAA6B,qBAAqB;;AAElD;AACA;AACA,KAAK;;AAEL;AACA;;AAEA,qCAAqC,qBAAqB;;AAE1D,gCAAgC,qBAAqB;AACrD;AACA;AACA,qCAAqC,qBAAqB;AAC1D,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,qBAAqB;AAC9C;AACA;;AAEA,8BAA8B,qBAAqB;;AAEnD;;AAEA,wBAAwB,qBAAqB;AAC7C,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;;;;;;;;AC/HA;;AAEA;;AAEA;;AAEA;AACA,YAAY,+CAA+C;AAC3D;;AAEA;AACA;AACA;;;;;;;;ACZA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO;AACZ,KAAK,8BAA8B;;AAEnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,KAAK;AAC3B;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,cAAc;AACjD;;AAEA;AACA,sBAAsB,KAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;;AAEA;AACA,sBAAsB,KAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2CAA2C,0BAA0B;AACrE;AACA;AACA;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,sBAAsB,KAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;;AAEA;AACA,sBAAsB,KAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wCAAwC,iCAAiC;AACzE;AACA;AACA;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,sBAAsB,KAAK;AAC3B;AACA;AACA;;AAEA,qBAAqB,4BAA4B,EAAE;AACnD;;AAEA;AACA,sBAAsB,KAAK,UAAU;AACrC;AACA;AACA;AACA;;AAEA,eAAe,2BAA2B;AAC1C;;AAEA;AACA,sBAAsB,KAAK;AAC3B;AACA;AACA;;AAEA,0BAA0B;AAC1B;AACA;AACA,GAAG;AACH;;AAEA;AACA,sBAAsB,KAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;;AAEA;AACA,sBAAsB,KAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,qCAAqC,0BAA0B;AAC/D;AACA;AACA;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;AAGA;AACA,sBAAsB,KAAK;AAC3B;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,oCAAoC;AACvD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3QA;;AAEA;;AAEA;;AAEA;AACA;AACA;;;;;;;;ACRA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpBA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,YAAY,GAAG,aAAa;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,mBAAmB,YAAY,GAAG,aAAa;AAC/C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG,IAAI;AACP;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA,8BAA8B,+BAA+B;AAC7D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtHA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,IAAI;AACP;;AAEA;AACA,8BAA8B,wBAAwB;AACtD;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA,uBAAuB,oBAAoB;AAC3C;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA,yCAAyC,uBAAuB;AAChE;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG,6BAA6B,8CAA8C;AAC9E;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gDAAgD,UAAU;AAC1D;;AAEA;AACA;AACA,2BAA2B,aAAa,eAAe,YAAY,YAAY,WAAW;AAC1F;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxIA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qBAAqB;AACpD,MAAM;AACN;;AAEA;AACA,+BAA+B,qBAAqB;AACpD;;AAEA;AACA;AACA;AACA,mBAAmB,UAAU,GAAG,aAAa,GAAG,KAAK;AACrD,2BAA2B,WAAW,OAAO,WAAW;AACxD;AACA;;AAEA;AACA,gDAAgD,UAAU;AAC1D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA,sFAAsF,2CAA2C;AACjI;AACA;;AAEA;AACA;AACA,yDAAyD,2CAA2C;;AAEpG;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,8BAA8B,uDAAuD;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;;;;;;;AC5JA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,qEAAqE,cAAc;;AAEnF;AACA;AACA;;AAEA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;;AAEA;;;;;;;;ACjCA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C,qCAAqC;;AAElF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,6DAA6D,SAAS;;AAEtE;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA,gCAAgC,IAAI;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,6DAA6D,SAAS;AACtE;AACA,GAAG;AACH;;;;;;;;;ACxNA;;AAEA;;AAEA;;AAEA;AACA;AACA;;;;;;;;ACRA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,QAAQ;AACjE,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;;AAEA;AACA;AACA,+BAA+B,mBAAmB;AAClD,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;;;;;;;ACxCA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;;AAEA,mCAAmC,uBAAuB;AAC1D;AACA;;AAEA;;;;;;;;;ACtBA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8BAA8B,sBAAsB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,6CAA6C,YAAY;AACzD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iHAAiH,oBAAoB;AACrI;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX,OAAO;;AAEP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,GAAG;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+CAA+C,8BAA8B;AAC7E;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,mCAAmC,wDAAwD;;AAE3F;AACA;AACA;AACA;AACA;AACA,qBAAqB,iDAAiD;AACtE,KAAK;AACL;AACA,2BAA2B,qBAAqB,YAAY,GAAG,gDAAgD,OAAO;AACtH,OAAO;AACP;AACA;AACA;;AAEA,+BAA+B,+CAA+C;;AAE9E;AACA;AACA;AACA;;AAEA,cAAc,WAAW;AACzB,GAAG;AACH;AACA;AACA;AACA,6BAA6B,GAAG;AAChC;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,mBAAmB,GAAG;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,oBAAoB,GAAG;AAChE,KAAK;AACL,+BAA+B,0BAA0B;AACzD,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/PA;;AAEA;;AAEA;AACA;;AAEA;AACA,4BAA4B,gBAAgB,MAAM,+BAA+B,UAAU,6BAA6B,GAAG,EAAE;AAC7H;;;;;;;;ACTA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mCAAmC,oBAAoB;;AAEvD;AACA;AACA,+CAA+C,uEAAuE;;AAEtH;AACA;AACA;AACA,mCAAmC,oBAAoB;;AAEvD;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sDAAsD,iCAAiC;AACvF;;;;;;;;AC7DA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,yCAAyC;;AAEhG;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,yCAAyC;;AAEhG,YAAY;AACZ,GAAG;AACH;;;;;;;;AC9DA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;AC3IA;;AAEA;AACA;AACA;AACA,WAAW,EAAE;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA,KAAK,IAAI;AACT;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;;;;;;;ACjCA;;AAEA;;AAEA;AACA;;AAEA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,+CAA+C,QAAQ;AACvD;;AAEA;AACA;AACA;;;;;;;;ACvBA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,yEAAyE;;AAEzE;AACA,kBAAkB;;AAElB;AACA;;AAEA;;;;;;;;ACjBA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,sDAAsD,eAAe;AACrE;AACA,oDAAoD,WAAW;AAC/D;AACA;;AAEA;AACA,gDAAgD,oBAAoB;AACpE;;AAEA;AACA,8DAA8D,MAAM;AACpE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA,8DAA8D,cAAc;AAC5E,aAAa,uDAAuD;AACpE;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;AC5FA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iCAA6C;AAC7C;AACA,kDAAwF;AACxF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,yEAAyE,YAAY,IAAI,UAAU;AACnG;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,kDAAkD,iBAAiB,kBAAkB;AAClG;AACA;AACA;;AAEA;AACA;AACA,gEAAgE,gBAAgB;AAChF;;AAEA;AACA;AACA,wEAAwE,gBAAgB;AACxF;;AAEA;AACA;AACA;AACA;AACA,mDAAmD,SAAS;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACpGA;;AAEA;;AAEA;AACA;AACA,iCAAkC;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,YAAY;AACjD;AACA,KAAK;AACL;;AAEA;;;;;;;;ACxBA;;AAEA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB;;AAEA;AACA,aAAa,SAAS;AACtB,WAAW,IAAI;AACf,aAAa,WAAW;AACxB;;AAEA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AClCA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,QAAQ;AACrC,GAAG;AACH,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;;;;;;;ACvBA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA,yDAAyD,UAAU;AACnE;;AAEA;AACA;;AAEA;AACA;AACA,wBAAwB;AACxB,oDAAoD,sBAAsB;AAC1E;AACA,OAAO;AACP,KAAK;;AAEL;AACA,cAAc;AACd,KAAK;AACL,GAAG;AACH;;AAEA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA,gFAAgF,8BAA8B;AAC9G;AACA;;AAEA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;;AAEA,+BAA+B,+BAA+B;AAC9D;;AAEA;AACA,kBAAkB,QAAQ,SAAS;AACnC;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,sCAAsC;AAC9D;;AAEA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,uCAAuC;AAC3D;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA,4CAA4C,kDAAkD;AAC9F;AACA;AACA;AACA;AACA;AACA,8BAA8B,YAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7JA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;ACdA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,wCAAwC,oBAAoB,gBAAgB,wBAAwB;AACpG;AACA;AACA;;AAEA;AACA,GAAG;AACH;;;;;;;;AC3BA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;ACfA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,KAAK,kBAAkB;AACvB,KAAK,gCAAgC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,KAAK,+BAA+B;;AAEpC;AACA;AACA,MAAM,oBAAoB;AAC1B;AACA;;AAEA;AACA;AACA;AACA,uCAAuC,QAAQ,EAAE,YAAY,MAAM,OAAO;AAC1E;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,YAAY,yBAAyB,WAAW,OAAO,OAAO,2CAA2C;AACzG;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;;AAE3B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;ACxGA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,KAAK,aAAa;AAClB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,iBAAiB,WAAW,cAAc;AACxD;AACA,OAAO;AACP;AACA;AACA,+BAA+B,yCAAyC;AACxE;AACA;AACA;AACA;AACA,KAAK,IAAI,YAAY;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,yEAAyE;AACjH;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,UAAU;AACxB;;AAEA;AACA;;AAEA;AACA,cAAc,iBAAiB,OAAO,EAAE;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,6DAA6D;AACrF;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,wEAAwE;AAC7F;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,0BAA0B,eAAe;AACzC;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,KAAK;AACL;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;;AAEA;AACA,UAAU,QAAQ,OAAO,YAAY,UAAU,UAAU;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,cAAc,UAAU;AACxB,qEAAqE;AACrE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,wDAAwD,UAAU;AAClE,4DAA4D,cAAc;AAC1E;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B,oBAAoB,WAAW;AAC/B,sCAAsC,oEAAoE,KAAK;AAC/G;AACA,qCAAqC,UAAU;AAC/C;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB,OAAO;AAC3B,sCAAsC,yFAAyF,KAAK;AACpI;AACA,qCAAqC,UAAU;AAC/C;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,4BAA4B,UAAU;AACtC;AACA;;AAEA;AACA;AACA;AACA,mCAAmC,6BAA6B;AAChE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,+BAA+B;AAC/C;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrQA;;AAEA,KAAK,gDAAgD;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;;;;;;ACtBA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,+BAA+B;AAClE,4CAA4C,kBAAkB;AAC9D;AACA,6CAA6C,oBAAoB;AACjE,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,+BAA+B,yBAAyB;AACxD;AACA,SAAS;AACT;AACA;AACA;AACA,uFAAuF,oBAAoB;AAC3G,+CAA+C,oBAAoB;;AAEnE;AACA;AACA,yDAAyD,oBAAoB;AAC7E,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,6BAA6B,uCAAuC;AACpE;AACA,KAAK,8BAA8B,uCAAuC;AAC1E;AACA,KAAK,8BAA8B,qCAAqC;AACxE;AACA,KAAK,8BAA8B,uCAAuC;AAC1E;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC7EA;;AAEA;;AAEA;AACA;AACA,OAAO,sBAAsB;AAC7B;;AAEA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA,mCAAmC,kBAAkB;AACrD;AACA;AACA;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,yBAAyB,YAAY,EAAE;AACvC;AACA;AACA;AACA;;AAEA,+BAA+B,+BAA+B;AAC9D;AACA;AACA;AACA;AACA,gCAAgC,gBAAgB,GAAG,YAAY;AAC/D;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,eAAe,gBAAgB,GAAG,YAAY;AAC9C;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,yBAAyB,YAAY,EAAE,QAAQ,EAAE;AACjD;AACA;AACA;AACA;AACA;;AAEA,sCAAsC,+CAA+C;AACrF;AACA;AACA;AACA;AACA,gCAAgC,gBAAgB,GAAG,YAAY,GAAG,eAAe;AACjF;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,eAAe,gBAAgB,GAAG,YAAY,GAAG,eAAe;AAChE;AACA,KAAK;AACL;AACA;;AAEA;AACA,sBAAsB,YAAY,EAAE,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,wDAAwD;AAC/E,qBAAqB,gBAAgB,EAAE;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvHA;;AAEA;;AAEA;AACA;AACA;;AAEA,wBAAwB,wCAAwC;AAChE;AACA,8EAA8E,gCAAgC;AAC9G;AACA;AACA;AACA,gEAAgE,wBAAwB;AACxF,KAAK;;AAEL;AACA,GAAG;AACH;;AAEA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA,iCAAiC,gBAAgB;AACjD;AACA,KAAK;;AAEL;AACA;AACA,iCAAiC,gBAAgB;AACjD;AACA,KAAK;;AAEL;AACA,GAAG;AACH;;AAEA,oBAAoB,+BAA+B;AACnD;AACA;AACA;AACA;AACA;AACA,iCAAiC,gBAAgB,YAAY,YAAY;AACzE;AACA,KAAK;;AAEL;AACA;AACA,iCAAiC,gBAAgB;AACjD;AACA,4DAA4D,YAAY;AACxE,KAAK;;AAEL;AACA,GAAG;AACH;;AAEA,2BAA2B,+CAA+C;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gBAAgB,YAAY,YAAY,GAAG,eAAe;AAC3F;AACA,KAAK;;AAEL;AACA;AACA,iCAAiC,gBAAgB;AACjD;AACA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;ACxFA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACvDA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvBA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,KAAK;AACxB;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,wCAAwC;AAC5D;;AAEA;AACA,mBAAmB,KAAK;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC,mDAAmD;AAC3F;AACA;AACA;AACA;AACA;AACA,6BAA6B,aAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACtEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;ACdA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,0CAA0C,qBAAqB,QAAQ,wBAAwB;AAC/F;AACA;AACA;;AAEA;AACA,GAAG;AACH;;;;;;;;AC5BA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,WAAW;AACzB,GAAG;AACH;;AAEA;AACA;AACA;AACA;;;;;;;;AClDA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,kCAAkC;AAC/C;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,YAAY,EAAE;AAC5C,6CAA6C,yBAAyB;;AAEtE;AACA;AACA,6BAA6B,uBAAuB;AACpD,qCAAqC,SAAS,EAAE;AAChD;;AAEA;AACA;AACA;AACA,qCAAqC,GAAG,GAAG,WAAW,EAAE;AACxD;;AAEA;AACA;;;;;;;AChDA,+B;;;;;;;ACAA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;;AAEA;;;;;;;;ACfA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;AChCA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;;;;;;;AChBA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,eAAe;AACtD,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;AChHA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,QAAQ,IAAI,IAAI;AACnE;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;;;;;;;ACzBA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,+CAA+C,YAAY,WAAW,mBAAmB;AACzF;AACA;AACA,KAAK;AACL;AACA,CAAC;;AAED;AACA;AACA;;;;;;;;AC5BA;;AAEA;AACA;AACA,iDAA2C,mBAAmB;AAC9D;AACA;AACA;;AAEA;AACA;AACA;;AAEA,8BAA8B,+BAA+B;AAC7D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,0BAA0B,iDAAiD,EAAE;AAC7E;AACA,yDAAyD,YAAY;AACrE;AACA,2BAA2B,qDAAqD;AAChF;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,cAAc;AACd,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,gCAAgC,GAAG,GAAG,UAAU;AAChD;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yCAAyC,oCAAoC;AAC7E,yBAAyB,0BAA0B;AACnD;AACA;AACA,SAAS;AACT,0CAA0C,oCAAoC;AAC9E,yBAAyB,6BAA6B;AACtD;AACA;AACA,SAAS;AACT,kDAAkD,oCAAoC;AACtF,yBAAyB,6BAA6B;AACtD;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;;AAEH;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,8CAA8C,gBAAgB;AAC9D;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;ACvKA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;ACvDA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACjBA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;ACbA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;AC5BA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,6BAA6B,WAAW;;AAExC;AACA,4BAA4B;AAC5B;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,sBAAsB,cAAc;;AAEpC,0BAA0B,kBAAkB;;AAE5C,+BAA+B,mBAAmB;;AAElD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;;;;;;ACvDA,yD;;;;;;ACAA,mE;;;;;;;ACAA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0CAA0C,4BAA4B;AACtE;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH","file":"server.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 144);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 986537cb4dc449ab8c58","module.exports = require(\"co\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"co\"\n// module id = 0\n// module chunks = 0","module.exports = require(\"lodash\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash\"\n// module id = 1\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet winston = require('winston');\nlet AWS = require('aws-sdk');\nlet config = require('../config');\nlet fp = require('lodash/fp');\n\nconst EM_LOG_LEVEL = config.get('EM_LOG_LEVEL').toLowerCase();\nconst IS_PROD = config.get('IS_PRODUCTION');\nconst IS_REMOTE_DEBUG = config.get('IS_REMOTE_DEBUG');\n\nlet transportOpts = { level: EM_LOG_LEVEL, showLevel: false };\nif (IS_PROD) transportOpts.formatter = formatter;\n\nfunction formatter(options) {\n  let entry = {\n    message: options.message,\n    level: options.level,\n    name: 'environment-manager',\n    eventtype: fp.compose(fp.defaultTo('default'), fp.get(['meta', 'eventtype']))(options),\n    releaseversion: process.env.RELEASE_VERSION || config.get('APP_VERSION'),\n    meta: fp.compose(fp.omit('eventtype'), fp.get('meta'))(options)\n  };\n  return JSON.stringify(entry);\n}\n\nconst logger = new (winston.Logger)({\n  transports: [\n    new (winston.transports.Console)(transportOpts)\n  ]\n});\n\nif (IS_PROD) {\n  // Globally configure aws-sdk to log all activity.\n  AWS.config.update({\n    logger: {\n      log: (level, message, meta) => logger.log(level, message, fp.assign({ eventtype: 'aws' })(meta))\n    }\n  });\n}\n\nlogger.info(`Starting logger with log level ${EM_LOG_LEVEL}`);\n\nif (IS_REMOTE_DEBUG) {\n  /**\n   * The remote debugger will *only* pick-up messages sent via console.{log|info|warn|error}\n   * The Winston console transport currently uses process.stdout.write which will not work.\n   * @see https://github.com/winstonjs/winston/issues/981\n   */\n  module.exports = console;\n} else {\n  module.exports = logger;\n}\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/logger.js\n// module id = 2\n// module chunks = 0","module.exports = require(\"assert\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"assert\"\n// module id = 3\n// module chunks = 0","module.exports = require(\"lodash/fp\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/fp\"\n// module id = 4\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet nconf = require('nconf');\nlet fs = require('fs');\nlet { getVersion } = require('./version');\n\nconst REQUIRED_VALUES = ['EM_AWS_REGION', 'EM_PACKAGES_BUCKET'];\nconst LOGGED_VALUES = [...REQUIRED_VALUES, 'EM_AWS_RESOURCE_PREFIX', 'EM_AWS_S3_BUCKET', 'EM_PACKAGES_KEY_PREFIX'];\n\nfunction init() {\n  const APP_VERSION = getVersion();\n\n  /**\n   * ENV is default but allow argument overrides\n   */\n  nconf.env().argv();\n  nconf.use('memory');\n\n  /**\n   * If an `EM_PROFILE` value is set, override values with that profile\n   */\n  const profileOverride = nconf.get('EM_PROFILE');\n  if (profileOverride !== undefined) {\n    if (fs.existsSync(profileOverride) === false) {\n      throw Error(`File EM_PROFILE=${profileOverride} doesn't exist.`);\n    }\n    nconf.file(profileOverride);\n  }\n\n  /**\n   * Defaults if not previously set via ENV, args or profile\n   */\n  nconf.defaults({\n    EM_AWS_RESOURCE_PREFIX: '',\n    EM_LOG_LEVEL: 'Debug',\n    EM_AWS_S3_BUCKET: 'S3 Bucket value not set',\n    EM_AWS_S3_KEY: 'S3 Key value not set',\n    EM_PACKAGES_KEY_PREFIX: 'PACKAGES'\n  });\n\n  /**\n   * Convenience values\n   */\n  const isProduction = nconf.get('NODE_ENV') === 'production';\n  const isRemoteDebug = nconf.get('REMOTE_DEBUG') === 'true';\n  const useDevSources = nconf.get('DEV_SOURCES') === 'true';\n  const publicDir = isProduction || useDevSources ? './dist' : '../client';\n\n  nconf.set('IS_PRODUCTION', isProduction);\n  nconf.set('IS_REMOTE_DEBUG', isRemoteDebug);\n  nconf.set('APP_VERSION', APP_VERSION);\n  nconf.set('PUBLIC_DIR', publicDir);\n\n  /**\n   * Ensure required values are set\n   */\n  REQUIRED_VALUES.filter(v => nconf.get(v) === undefined).forEach((missing) => {\n    throw new Error(`${missing} value is not set.`);\n  });\n}\n\n/**\n * Set user namespaced config value\n */\nfunction userSet(key, value) {\n  return nconf.set(`user:${key}`, value);\n}\n\n/**\n * Get user namespaced config value\n */\nfunction userGet(key) {\n  return nconf.get(`user:${key}`);\n}\n\nlet afterInit = (() => {\n  let isInitialised = false;\n  return fn => (...args) => {\n    if (!isInitialised) {\n      init();\n      isInitialised = true;\n    }\n    return fn(...args);\n  };\n})();\n\nmodule.exports = {\n  logBootstrapValues: () => {\n    LOGGED_VALUES.forEach((key) => {\n      console.log(`${key}=${nconf.get(key)}`);\n    });\n  },\n  get: afterInit(nconf.get.bind(nconf)),\n  set: afterInit(nconf.set.bind(nconf)),\n  setUserValue: afterInit(userSet),\n  getUserValue: afterInit(userGet)\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/config/index.js\n// module id = 5\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet assert = require('assert');\nlet guid = require('uuid/v1');\nlet logger = require('./logger');\nlet commandMetadata = require('../commands/utils/metadata');\n\nconst COMMAND_TYPE = 'Command';\nconst QUERY_TYPE = 'Query';\n\nmodule.exports = {\n  sendCommand(handler, parameters, callback) {\n    assert(typeof handler === 'function');\n    assert(typeof parameters === 'object' && parameters !== null);\n    let command = commandMetadata.createFromParameters(parameters);\n    let message = getLogMessage(command);\n    logger.info(message);\n\n    let type = COMMAND_TYPE;\n    let promise = handler(command);\n    return promiseOrCallback(promise, command, type, callback);\n  },\n\n  sendQuery(handler, parameters, callback) {\n    assert(typeof handler === 'function');\n    assert(typeof parameters === 'object' && parameters !== null);\n    let query = prepareQuery(parameters);\n    let type = QUERY_TYPE;\n    let promise = handler(query);\n    return promiseOrCallback(promise, query, type, callback);\n  }\n};\n\nfunction prepareQuery(parameters) {\n  let query = Object.assign({}, parameters.query);\n\n  if (parameters.parent) {\n    query.queryId = parameters.parent.queryId;\n    query.username = parameters.parent.username;\n  }\n\n  if (parameters.user) {\n    query.queryId = guid();\n    query.username = parameters.user.getName();\n  }\n\n  query.timestamp = new Date().toISOString();\n  return query;\n}\n\nfunction promiseOrCallback(promise, commandOrQuery, type, callback) {\n  promise.catch((error) => {\n    if (commandOrQuery.suppressError !== true) {\n      let errorMessage = getErrorMessage(commandOrQuery, error);\n      logger.error(errorMessage, {\n        error: {\n          name: error.name,\n          message: error.message,\n          stack: error.toString(true)\n        },\n        command: type === COMMAND_TYPE ? commandOrQuery : undefined,\n        query: type === QUERY_TYPE ? commandOrQuery : undefined\n      });\n    }\n  });\n\n  if (!callback) return promise;\n\n  return promise.then(\n    result => callback(null, result),\n    error => callback(error)\n  );\n}\n\nfunction getLogMessage(commandOrQuery) {\n  return [\n    `[${commandOrQuery.name}]`,\n    JSON.stringify(commandOrQuery, null, '  ')\n  ].join('\\n');\n}\n\nfunction getErrorMessage(commandOrQuery, error) {\n  return [\n    'Error executing:',\n    `[${commandOrQuery.name}]`,\n    JSON.stringify(commandOrQuery, null, '  '),\n    error.toString(true),\n    JSON.stringify(error)\n  ].join('\\n');\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/sender.js\n// module id = 6\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet stringifyError = function (error, detailed) {\n  return detailed ? `${error.stack}/n` : `${error.name}: ${error.message}`;\n};\n\nclass BaseError extends Error {\n\n  constructor(message, innerError) {\n    super();\n    this.name = this.constructor.name;\n    this.message = message;\n    this.innerError = innerError;\n    Error.captureStackTrace(this, this.constructor);\n  }\n\n  toString(detailed) {\n    let errors = [];\n    let currentError = this;\n\n    while (currentError) {\n      errors.push(currentError);\n      currentError = currentError.innerError;\n    }\n    return errors.map(error => stringifyError(error, detailed)).join('/n');\n  }\n}\n\n// eslint-disable-next-line no-extend-native\nError.prototype.toString = function (detailed) {\n  return stringifyError(this, detailed);\n};\n\nmodule.exports = BaseError;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/errors/BaseError.class.js\n// module id = 7\n// module chunks = 0","module.exports = require(\"util\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"util\"\n// module id = 8\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet _ = require('lodash');\nlet environmentDatabase = require('../modules/environmentDatabase');\nlet DeploymentMap = require('./DeploymentMap');\nlet EnvironmentType = require('./EnvironmentType');\n\nclass Environment {\n\n  constructor(data) {\n    _.assign(this, data);\n  }\n\n  getEnvironmentType() {\n    return EnvironmentType.getByName(this.EnvironmentType);\n  }\n\n  getDeploymentMap() {\n    return DeploymentMap.getByName(this.DeploymentMap);\n  }\n\n  getAccountName() {\n    return EnvironmentType.getByName(this.EnvironmentType).then(data => data.AWSAccountName);\n  }\n\n  static getAccountNameForEnvironment(name) {\n    return Environment.getByName(name).then(environment => environment.getAccountName());\n  }\n\n  static getByName(name) {\n    return environmentDatabase.getEnvironmentByName(name).then(obj => new Environment(obj));\n  }\n}\n\nmodule.exports = Environment;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/models/Environment.js\n// module id = 9\n// module chunks = 0","module.exports = require(\"bluebird\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"bluebird\"\n// module id = 10\n// module chunks = 0","'use strict';\n\nmodule.exports = {\n\n  DEPLOYMENT_INSTANCES_LIST_MAXIMUM_LENGTH: 300,\n\n  DeploymentMode: {\n    Overwrite: 'overwrite',\n    BlueGreen: 'bg'\n  },\n\n  SliceName: {\n    Blue: 'blue',\n    Green: 'green'\n  },\n\n  DIFF_STATE: {\n    Ignored: 'Ignored',\n    Missing: 'Missing',\n    Unexpected: 'Unexpected'\n  },\n\n  HEALTH_STATUS: {\n    Healthy: 'Healthy',\n    Warning: 'Warning',\n    Error: 'Error',\n    NoData: 'NoData',\n    Unknown: 'Unknown',\n    Missing: 'Missing'\n  },\n\n  ASGLifecycleState: {\n    IN_SERVICE: 'InService'\n  },\n\n  NodeDeploymentStatus: {\n    NotStarted: 'Not Started',\n    InProgress: 'In Progress',\n    Success: 'Success',\n    Failed: 'Failed'\n  },\n\n  DEPLOYMENT_STATUS: {\n    InProgress: 'In Progress',\n    Success: 'Success',\n    Failed: 'Failed',\n    Cancelled: 'Cancelled',\n    Unknown: 'Unknown'\n  },\n\n  AutoScalingNotificationType: {\n    InstanceLaunch: 'autoscaling:EC2_INSTANCE_LAUNCH',\n    InstanceLaunchError: 'autoscaling:EC2_INSTANCE_LAUNCH_ERROR',\n    InstanceTerminate: 'autoscaling:EC2_INSTANCE_TERMINATE',\n    InstanceTerminateError: 'autoscaling:EC2_INSTANCE_TERMINATE_ERROR'\n  },\n\n  ServiceAction: {\n    INSTALL: 'Install',\n    IGNORE: 'Ignore'\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Enums.js\n// module id = 11\n// module chunks = 0","/* Copyright (c) Trainline Limited. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nconst createTopic = require('./createTopic');\nconst getTargetArn = require('./getTargetArn');\nconst createEvent = require('./createEvent');\nconst publishEvent = require('./publishEvent');\n\n/**\n * @param {any} event\n *\n * event: {\n *  topic: 'string' = topic name,\n *  message: 'string' = message content,\n *  attributes: 'object' = {\n *    key: 'object' = {\n *      DataType: 'string' = 'String',\n *      StringValue: 'string' = 'Value of the attribute'\n *    }\n *  }\n * }\n *\n * Valid topics:\n * EnvironmentManagerConfigurationChange\n *  optional extras for the topic: EnvironmentManagerConfigurationChange/somethingElse/SomethingElse\n * EnvironmentManagerOperationsChange\n *  optional extras for the topic: EnvironmentManagerOperationsChange/somethingElse/SomethingElse\n *\n * Valid keys for attributes:\n *  'EnvironmentType',\n    'Environment',\n    'OwningCluster',\n    'User',\n    'Result',\n    'Timestamp',\n    'Action',\n    'ID',\n    'EntityURL'\n *\n * Example use:\n * sns.publish({\n *  topic: 'EnvironmentManagerConfigurationChange',\n *  message: 'This is what will be sent as message content to the consumer',\n *  attributes: {\n *    ID: {\n *      DataType: 'String',\n *      StringValue: 'ThisIsMyIdValue'\n *    }\n *  }\n * })\n */\nexports.publish = (event) => {\n  createTopic(event.topic)\n    .then(getTargetArn)\n    .then(createEvent(event))\n    .then(publishEvent)\n    .catch((reason) => {\n      console.log(reason);\n    });\n};\n\nexports.TOPICS = {\n  CONFIGURATION_CHANGE: 'EnvironmentManagerConfigurationChange',\n  OPERATIONS_CHANGE: 'EnvironmentManagerOperationsChange'\n};\n\nexports.ACTIONS = {\n  DELETE: 'delete',\n  REMOVE: 'delete',\n  UPDATE: 'update',\n  PUT: 'update',\n  CREATE: 'create',\n  POST: 'create',\n  PATCH: 'patch'\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/sns/EnvironmentManagerEvents/index.js\n// module id = 12\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet config = require('../config');\nlet resourcePrefix = config.get('EM_AWS_RESOURCE_PREFIX');\n\nmodule.exports = {\n  getTableName: tableName => `${resourcePrefix}${tableName}`\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/awsResourceNameProvider.js\n// module id = 13\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst AWS = require(\"aws-sdk\");\nconst guid = require(\"uuid/v1\");\nconst awsAccounts = require(\"../awsAccounts\");\nconst createLowLevelDynamoClient = createClientWithRole(AWS.DynamoDB);\nexports.createLowLevelDynamoClient = createLowLevelDynamoClient;\nconst createDynamoClient = createClientWithRole(AWS.DynamoDB.DocumentClient);\nexports.createDynamoClient = createDynamoClient;\nconst createASGClient = createClientWithRole(AWS.AutoScaling);\nexports.createASGClient = createASGClient;\nconst createEC2Client = createClientWithRole(AWS.EC2);\nexports.createEC2Client = createEC2Client;\nconst createIAMClient = createClientWithRole(AWS.IAM);\nexports.createIAMClient = createIAMClient;\nconst createS3Client = createClientWithRole(AWS.S3);\nexports.createS3Client = createS3Client;\nconst createSNSClient = createClientWithRole(AWS.SNS);\nexports.createSNSClient = createSNSClient;\nfunction createClientWithRole(ClientType) {\n    return (accountName) => awsAccounts.getByName(accountName)\n        .then(({ RoleArn }) => (getCredentials(RoleArn)))\n        .then((credentials) => ({ credentials }))\n        .then((options) => new ClientType(options));\n}\nfunction getCredentials(roleARN) {\n    return assumeRole(roleARN).then(({ Credentials }) => {\n        if (Credentials === undefined) {\n            throw new Error(\"Credentials was undefined\");\n        }\n        return new AWS.Credentials(Credentials.AccessKeyId, Credentials.SecretAccessKey, Credentials.SessionToken);\n    });\n}\nfunction assumeRole(roleARN) {\n    const stsClient = new AWS.STS();\n    const stsParameters = {\n        RoleArn: roleARN,\n        RoleSessionName: guid(),\n    };\n    return stsClient.assumeRole(stsParameters).promise();\n}\nexports.assumeRole = assumeRole;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/amazon-client/childAccountClient.ts\n// module id = 14\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet fp = require('lodash/fp');\n\nlet versionOf = fp.get(['Audit', 'Version']);\n\nfunction compareAndSetVersionOnReplace({ record, expectedVersion, expressions }) {\n  if (expectedVersion === undefined) {\n    throw new Error('expectedVersion is required');\n  }\n  let audit = Object.assign({}, record.Audit, { Version: expectedVersion + 1 });\n  let condition =\n    ['=',\n      ['at', 'Audit', 'Version'],\n      ['val', expectedVersion]];\n  if (expressions && expressions.ConditionExpression) {\n    let newExpressions = {\n      ConditionExpression: ['and', expressions.ConditionExpression, condition]\n    };\n    return {\n      record: Object.assign({}, record, { Audit: audit }),\n      expressions: Object.assign({}, expressions, newExpressions)\n    };\n  } else {\n    return {\n      record: Object.assign({}, record, { Audit: audit }),\n      expressions: {\n        ConditionExpression: condition\n      }\n    };\n  }\n}\n\nfunction compareAndSetVersionOnPut(hashKeyAttributeName) {\n  return ({ record, expectedVersion, expressions }) => {\n    if (expectedVersion === undefined) {\n      throw new Error('expectedVersion is required');\n    }\n    let audit = Object.assign({}, record.Audit, { Version: expectedVersion + 1 });\n    let condition =\n      ['or',\n        ['attribute_not_exists', ['at', hashKeyAttributeName]],\n        ['=', ['at', 'Audit', 'Version'], ['val', expectedVersion]]];\n    if (expressions && expressions.ConditionExpression) {\n      let newExpressions = {\n        ConditionExpression: ['and', expressions.ConditionExpression, condition]\n      };\n      return {\n        record: Object.assign({}, record, { Audit: audit }),\n        expressions: Object.assign({}, expressions, newExpressions)\n      };\n    } else {\n      return {\n        record: Object.assign({}, record, { Audit: audit }),\n        expressions: {\n          ConditionExpression: condition\n        }\n      };\n    }\n  };\n}\n\nfunction compareAndSetVersionOnCreate(hashKeyAttributeName) {\n  return ({ record, expressions }) => {\n    let audit = Object.assign({}, record.Audit, { Version: 1 });\n    let condition =\n      ['attribute_not_exists', ['at', hashKeyAttributeName]];\n    if (expressions && expressions.ConditionExpression) {\n      let newExpressions = {\n        ConditionExpression: ['and', expressions.ConditionExpression, condition]\n      };\n      return {\n        record: Object.assign({}, record, { Audit: audit }),\n        expressions: Object.assign({}, expressions, newExpressions)\n      };\n    } else {\n      return {\n        record: Object.assign({}, record, { Audit: audit }),\n        expressions: {\n          ConditionExpression: condition\n        }\n      };\n    }\n  };\n}\n\nfunction compareVersionOnDelete(hashKeyAttributeName) {\n  return ({ key, expectedVersion, expressions }) => {\n    if (expectedVersion === undefined) {\n      throw new Error('expectedVersion is required');\n    }\n    let condition =\n      ['or',\n        ['attribute_not_exists', ['at', hashKeyAttributeName]],\n        ['=',\n          ['at', 'Audit', 'Version'],\n          ['val', expectedVersion]]\n      ];\n    if (expressions && expressions.ConditionExpression) {\n      let newExpressions = {\n        ConditionExpression: ['and', expressions.ConditionExpression, condition]\n      };\n      return {\n        key,\n        expressions: Object.assign({}, expressions, newExpressions)\n      };\n    } else {\n      return {\n        key,\n        expressions: {\n          ConditionExpression: condition\n        }\n      };\n    }\n  };\n}\n\nfunction compareAndSetVersionOnUpdate({ key, expectedVersion, expressions }) {\n  if (expectedVersion === undefined) {\n    throw new Error('expectedVersion is required');\n  }\n  let { ConditionExpression, UpdateExpression } = expressions;\n  let optimisticCheck =\n    ['=',\n      ['at', 'Audit', 'Version'],\n      ['val', expectedVersion]];\n  let updateVersion = [['set',\n    ['at', 'Audit', 'Version'],\n    ['+',\n      ['at', 'Audit', 'Version'],\n      ['val', 1]]]];\n\n  return {\n    key,\n    expressions: Object.assign({},\n      expressions,\n      { ConditionExpression: ConditionExpression ? ['and', ConditionExpression, optimisticCheck] : optimisticCheck },\n      { UpdateExpression: UpdateExpression.concat(updateVersion) })\n  };\n}\n\nfunction setVersionOnUpdate({ key, expressions }) {\n  let { ConditionExpression, UpdateExpression } = expressions;\n  let updateVersion = [['set',\n    ['at', 'Audit', 'Version'],\n    ['+',\n      ['at', 'Audit', 'Version'],\n      ['val', 1]]]];\n\n  return {\n    key,\n    expressions: Object.assign({},\n      expressions,\n      ConditionExpression ? { ConditionExpression } : {},\n      { UpdateExpression: UpdateExpression.concat(updateVersion) })\n  };\n}\n\nmodule.exports = {\n  compareAndSetVersionOnReplace,\n  compareAndSetVersionOnCreate,\n  compareAndSetVersionOnPut,\n  compareVersionOnDelete,\n  compareAndSetVersionOnUpdate,\n  setVersionOnUpdate,\n  versionOf\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/data-access/dynamoVersion.js\n// module id = 15\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst AWS = require(\"aws-sdk\");\nmodule.exports = {\n    createASGClient: () => Promise.resolve(new AWS.AutoScaling()),\n    createDynamoClient: () => Promise.resolve(new AWS.DynamoDB.DocumentClient()),\n    createEC2Client: () => Promise.resolve(new AWS.EC2()),\n    createIAMClient: () => Promise.resolve(new AWS.IAM()),\n    createLowLevelDynamoClient: () => Promise.resolve(new AWS.DynamoDB()),\n    createS3Client: () => Promise.resolve(new AWS.S3()),\n    createSNSClient: () => Promise.resolve(new AWS.SNS()),\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/amazon-client/masterAccountClient.ts\n// module id = 16\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nfunction updateAuditMetadata({ updateExpression, metadata: { TransactionID, User } }) {\n  return updateExpression.concat([\n    ['set', ['at', 'Audit', 'LastChanged'], ['val', (new Date()).toISOString()]],\n    ['set', ['at', 'Audit', 'TransactionID'], ['val', TransactionID]],\n    ['set', ['at', 'Audit', 'User'], ['val', User]]\n  ]);\n}\n\nfunction attachAuditMetadata({ record, metadata: { TransactionID, User } }) {\n  let audit = Object.assign({}, record.Audit, {\n    LastChanged: (new Date()).toISOString(),\n    TransactionID,\n    User\n  });\n  return Object.assign({}, record, { Audit: audit });\n}\n\nfunction getAuditMetadata(record) {\n  return record.Audit;\n}\n\nfunction removeAuditMetadata(record) {\n  let t = Object.assign({}, record);\n  delete t.Audit;\n  return t;\n}\n\nmodule.exports = {\n  attachAuditMetadata,\n  getAuditMetadata,\n  removeAuditMetadata,\n  updateAuditMetadata\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/data-access/dynamoAudit.js\n// module id = 17\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nconst LOGICAL_TABLE_NAME = 'ConfigEnvironments';\nconst TTL = 600; // seconds\n\nlet physicalTableName = require('../awsResourceNameProvider').getTableName;\nlet cachedSingleAccountDynamoTable = require('./cachedSingleAccountDynamoTable');\n\nmodule.exports = cachedSingleAccountDynamoTable(physicalTableName(LOGICAL_TABLE_NAME), { ttl: TTL });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/data-access/configEnvironments.js\n// module id = 18\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet _ = require('lodash');\nlet moment = require('moment');\nlet co = require('co');\nlet EnvironmentType = require('./EnvironmentType');\nlet Environment = require('./Environment');\nlet serviceTargets = require('../modules/service-targets');\nlet logger = require('../modules/logger');\nlet TaggableMixin = require('./TaggableMixin');\nlet AsgResourceBase = require('../modules/resourceFactories/AsgResourceBase');\nlet launchConfigurationResourceFactory = require('../modules/resourceFactories/launchConfigurationResourceFactory');\n\nconst AutoScalingGroup = TaggableMixin(class {\n\n  constructor(data) {\n    _.assign(this, data);\n  }\n\n  getLaunchConfiguration() {\n    let self = this;\n    return co(function* () {\n      let name = self.LaunchConfigurationName;\n      if (name === undefined) {\n        throw new Error(`Launch configuration doesn't exist for ${self.AutoScalingGroupName}`);\n      }\n      let client = yield launchConfigurationResourceFactory.create(null, { accountName: self.$accountName });\n      return client.get({ name });\n    });\n  }\n\n  getEnvironmentType() {\n    return EnvironmentType.getByName(this.getTag('EnvironmentType'));\n  }\n\n  getRuntimeServerRoleName() {\n    return this.getTag('Role');\n  }\n\n  deleteASG() {\n    let environmentName = this.getTag('Environment');\n    let self = this;\n    return co(function* () {\n      let accountName = yield Environment.getAccountNameForEnvironment(environmentName);\n      let asgResource = yield new AsgResourceBase(accountName);\n      let launchConfigResource = yield launchConfigurationResourceFactory.create(null, { accountName });\n      logger.info(`Deleting AutoScalingGroup ${self.AutoScalingGroupName} and associated Launch configuration ${self.LaunchConfigurationName}`);\n\n      yield asgResource.delete({ name: self.AutoScalingGroupName, force: true });\n      if (self.LaunchConfigurationName !== undefined) {\n        // If not present it means that this ASG is already being deleted\n        yield launchConfigResource.delete({ name: self.LaunchConfigurationName });\n      }\n\n      yield serviceTargets.removeRuntimeServerRoleTargetState(environmentName, self.getRuntimeServerRoleName());\n      return true;\n    });\n  }\n\n  static getAllByServerRoleName(environmentName, serverRoleName) {\n    return AutoScalingGroup.getAllByEnvironment(environmentName)\n      .then(asgs => _.filter(asgs, asg => asg.getTag('Role') === serverRoleName));\n  }\n\n  static getByName(accountName, autoScalingGroupName) {\n    let asgResourceBase = new AsgResourceBase(accountName);\n    return asgResourceBase.get({ name: autoScalingGroupName })\n      .then((asg) => {\n        let data = new AutoScalingGroup(asg);\n        data.$accountName = accountName;\n        data.$autoScalingGroupName = autoScalingGroupName;\n        return data;\n      });\n  }\n\n  static getAllByEnvironment(environmentName) {\n    return co(function* () {\n      let accountName = yield Environment.getAccountNameForEnvironment(environmentName);\n      let startTime = moment.utc();\n      let asgResourceBase = new AsgResourceBase(accountName);\n\n      return asgResourceBase.all({ names: undefined }).then((asgs = []) => {\n        let duration = moment.duration(moment.utc().diff(startTime)).asMilliseconds();\n        logger.debug(`server-status-query: AllAsgsQuery took ${duration}ms`);\n        return asgs\n          .map(asg => new AutoScalingGroup(asg))\n          .filter(asg => asg.getTag('Environment', '') === environmentName);\n      });\n    });\n  }\n});\n\nmodule.exports = AutoScalingGroup;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/models/AutoScalingGroup.js\n// module id = 19\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet getMetadataForDynamoAudit = req => ({\n  TransactionID: req.id,\n  User: req.user.getName()\n});\n\nmodule.exports = {\n  getMetadataForDynamoAudit\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/api-utils/requestMetadata.js\n// module id = 20\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet fp = require('lodash/fp');\n\nmodule.exports = (name, req) => fp.get(['swagger', 'params', name, 'value'])(req);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/api-utils/requestParam.js\n// module id = 21\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet singleAccountDynamoTable = require('./singleAccountDynamoTable');\nlet dynamoTableCache = require('./dynamoTableCache');\n\nfunction factory(physicalTableName, { ttl }) {\n  let cachedTable = dynamoTableCache(physicalTableName, { ttl });\n  return singleAccountDynamoTable(physicalTableName, cachedTable);\n}\n\nmodule.exports = factory;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/data-access/cachedSingleAccountDynamoTable.js\n// module id = 22\n// module chunks = 0","'use strict';\n\nlet when = (cond, fnTrue, fnFalse = () => null) =>\n  x => (cond(x) ? fnTrue(x) : fnFalse(x));\n\nlet hasValue = x =>\n  (x !== null && x !== undefined);\n\nmodule.exports = {\n  when,\n  hasValue\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/functional.js\n// module id = 23\n// module chunks = 0","'use strict';\n\nlet { hasValue, when } = require('../../modules/functional');\n\nlet ifNotFound = when.bind(null, hasValue, data => res => res.json(data));\n\nlet notFoundMessage = resourceType =>\n  () => res => res.status(404).json({ error: `The ${resourceType} was not found` });\n\nmodule.exports = {\n  ifNotFound,\n  notFoundMessage\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/api-utils/ifNotFound.js\n// module id = 24\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet AsgResource = require('./AsgResource');\nlet awsAccounts = require('../awsAccounts');\nlet fp = require('lodash/fp');\nlet logger = require('../logger');\n\nfunction getAccountId(accountName) {\n  return awsAccounts.getByName(accountName)\n    .then(fp.flow(fp.get('AccountNumber'), fp.toString));\n}\n\nmodule.exports = {\n\n  canCreate: resourceDescriptor =>\n    resourceDescriptor.type.toLowerCase() === 'asgs',\n\n  create: (resourceDescriptor, parameters) => {\n    logger.debug(`Getting ASG client for account \"${parameters.accountName}\"...`);\n\n    return getAccountId(parameters.accountName).then((accountId) => {\n      let asgResource = new AsgResource(accountId);\n      return asgResource;\n    });\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/resourceFactories/asgResourceFactory.js\n// module id = 25\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet consulUpdater = require('./consul');\n\n/**\n * Service Discovery abstraction to allow easy switching\n * of service discovery frameworks.\n */\nmodule.exports = consulUpdater;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/service-targets/index.js\n// module id = 26\n// module chunks = 0","module.exports = require(\"fs\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"fs\"\n// module id = 27\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nconst LOGICAL_TABLE_NAME = 'InfraConfigServices';\nconst TTL = 600; // seconds\n\nlet physicalTableName = require('../awsResourceNameProvider').getTableName;\nlet cachedSingleAccountDynamoTable = require('./cachedSingleAccountDynamoTable');\n\nlet table = cachedSingleAccountDynamoTable(physicalTableName(LOGICAL_TABLE_NAME), { ttl: TTL });\n\nfunction get(...args) {\n  return table.get(...args).then((service) => {\n    if (service && !service.Deleted) return service;\n    return undefined;\n  });\n}\n\nfunction ownedBy(owningCluster, returnDeleted) {\n  let settings = getScanSettings({ owningCluster, returnDeleted });\n  return table.scan(settings);\n}\n\nfunction scan(returnDeleted) {\n  let settings = getScanSettings({ returnDeleted });\n  return table.scan(settings);\n}\n\nfunction getScanSettings(options) {\n  let predicates = [\n    ...(options.owningCluster ? [['=', ['at', 'OwningCluster'], ['val', options.owningCluster]]] : []),\n    ...(options.returnDeleted ? [] : [['<>', ['at', 'Deleted'], ['val', 'true']]])\n  ];\n\n  if (predicates.length === 0) return undefined;\n\n  let filter = predicates.length === 1 ? predicates[0] : ['and', ...predicates];\n  return { FilterExpression: filter };\n}\n\nmodule.exports = Object.assign({}, table, { ownedBy, scan, get });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/data-access/services.js\n// module id = 28\n// module chunks = 0","module.exports = require(\"aws-sdk\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"aws-sdk\"\n// module id = 29\n// module chunks = 0","module.exports = require(\"js-joda\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"js-joda\"\n// module id = 30\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert = require(\"assert\");\nconst accounts_1 = require(\"./data-access/accounts\");\nconst ResourceNotFoundError = require(\"./errors/ResourceNotFoundError.class\");\nfunction getByName(accountName) {\n    const matches = (val) => `${accountName}`.toLowerCase() === `${val}`.toLowerCase();\n    return Promise.resolve()\n        .then(() => { assert(typeof accountName === \"number\" || typeof accountName === \"string\", `${accountName}`); })\n        .then(getAllAccounts)\n        .then((accounts) => {\n        const matchingAccounts = [\n            ...accounts.filter((account) => matches(account.AccountNumber)),\n            ...accounts.filter((account) => matches(account.AccountName)),\n        ];\n        if (matchingAccounts.length > 0) {\n            return matchingAccounts[0];\n        }\n        else {\n            throw new ResourceNotFoundError(`AWS account ${accountName} not found`);\n        }\n    });\n}\nexports.getByName = getByName;\nfunction getAMIsharingAccounts() {\n    return getAllAccounts().then((accounts) => accounts.filter((a) => a.IncludeAMIs).map((a) => a.AccountNumber));\n}\nexports.getAMIsharingAccounts = getAMIsharingAccounts;\nfunction getAllAccounts() {\n    return accounts_1.scan();\n}\nexports.all = getAllAccounts;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/awsAccounts.ts\n// module id = 31\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet assert = require('assert');\n\nfunction getAutoScalingGroupName(configuration, sliceName) {\n  assert(configuration, 'Expected \\'configuration\\' argument not to be null.');\n\n  let segments = [\n    configuration.environmentName,\n    configuration.cluster.ShortName.toLowerCase(),\n    getRoleName(configuration, sliceName)\n  ];\n  let autoScalingGroupName = segments.join('-');\n  return autoScalingGroupName;\n}\n\nfunction getLaunchConfigurationName(configuration, sliceName) {\n  assert(configuration, 'Expected \\'configuration\\' argument not to be null.');\n\n  let autoScalingGroupName = getAutoScalingGroupName(configuration, sliceName);\n  let launchConfigurationName = `LaunchConfig_${autoScalingGroupName}`;\n  return launchConfigurationName;\n}\n\n/**\n * Note: by \"serverRole\" / \"serverRoleName\", we could mean:\n * 1. Deployment target, ie. server role name as in configuration, like \"MultitenantOverwrite\"\n * 2. Runtime server role, with slice, like \"MultitenantOverwrite-blue\"\n *\n */\nfunction getRoleName(configuration, sliceName) {\n  assert(configuration, 'Expected \\'configuration\\' argument not to be null.');\n\n  let roleName = isAutoScalingGroupPerSlice(configuration)\n    ? `${configuration.serverRole.ServerRoleName}-${sliceName}`\n    : configuration.serverRole.ServerRoleName;\n  return roleName;\n}\n\nfunction isAutoScalingGroupPerSlice(configuration) {\n  return configuration.serverRole.FleetPerSlice === true;\n}\n\nmodule.exports = {\n  getAutoScalingGroupName,\n  getLaunchConfigurationName,\n  getRoleName\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/provisioning/namingConventionProvider.js\n// module id = 32\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet util = require('util');\nlet BaseError = require('./BaseError.class');\n\nmodule.exports = function AwsError(message, innerError) {\n  this.name = this.constructor.name;\n  this.message = message;\n  this.innerError = innerError;\n\n  Error.captureStackTrace(this, this.constructor);\n};\n\nutil.inherits(module.exports, BaseError);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/errors/AwsError.class.js\n// module id = 33\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n/**\n * An in-memory cache that decouples the getting of an item from\n * the handling of a cache miss.\n */\n\n'use strict';\n\nlet cacheManager = require('cache-manager');\nlet cacheManagerEncryptedRedis = require('./data-access/cacheManagerEncryptedRedis');\nlet config = require('../config');\nlet emCrypto = require('./emCrypto');\nlet fp = require('lodash/fp');\nlet logger = require('./logger');\nlet masterAccountClient = require('./amazon-client/masterAccountClient');\n\nconst DEFAULT_TTL_SECONDS = 10;\nconst REDIS_READ_TIMEOUT = 1000;\nconst REDIS_WRITE_TIMEOUT = 1000;\n\nconst caches = new Map();\n\nlet redisCachePromise = (() => {\n  const EM_REDIS_ADDRESS = config.get('EM_REDIS_ADDRESS');\n  const EM_REDIS_PORT = config.get('EM_REDIS_PORT');\n\n  let redisCryptoKeyPromise = (() => {\n    const EM_REDIS_CRYPTO_KEY = config.get('EM_REDIS_CRYPTO_KEY');\n    const EM_REDIS_CRYPTO_KEY_S3_BUCKET = config.get('EM_REDIS_CRYPTO_KEY_S3_BUCKET');\n    const EM_REDIS_CRYPTO_KEY_S3_KEY = config.get('EM_REDIS_CRYPTO_KEY_S3_KEY');\n\n    if (EM_REDIS_CRYPTO_KEY) {\n      return Promise.resolve(EM_REDIS_CRYPTO_KEY);\n    } else if (EM_REDIS_CRYPTO_KEY_S3_BUCKET && EM_REDIS_CRYPTO_KEY_S3_KEY) {\n      return masterAccountClient.createS3Client().then(s3 => s3.getObject({\n        Bucket: EM_REDIS_CRYPTO_KEY_S3_BUCKET,\n        Key: EM_REDIS_CRYPTO_KEY_S3_KEY\n      }).promise()).then(rsp => rsp.Body, (error) => {\n        logger.warn(`Failed to get Redis Crypto Key: Bucket=${EM_REDIS_CRYPTO_KEY_S3_BUCKET} Key=${EM_REDIS_CRYPTO_KEY_S3_KEY}`);\n        logger.error(error);\n        return Promise.resolve();\n      });\n    } else {\n      return Promise.resolve();\n    }\n  })();\n\n  return redisCryptoKeyPromise.then((cryptokey) => {\n    if (cryptokey && EM_REDIS_ADDRESS && EM_REDIS_PORT) {\n      let redisStore = cacheManagerEncryptedRedis.create({\n        host: EM_REDIS_ADDRESS,\n        port: EM_REDIS_PORT,\n        valueTransform: {\n          toStore: fp.flow(JSON.stringify, str => new Buffer(str), emCrypto.encrypt.bind(null, cryptokey)),\n          fromStore: fp.flow(emCrypto.decrypt.bind(null, cryptokey), buf => buf.toString(), JSON.parse)\n        },\n        readTimeout: REDIS_READ_TIMEOUT,\n        writeTimeout: REDIS_WRITE_TIMEOUT,\n        ttl: DEFAULT_TTL_SECONDS\n      });\n      logger.info(`Cache will use Redis. address=${EM_REDIS_ADDRESS} port=${EM_REDIS_PORT}`);\n      return [cacheManager.caching({ store: redisStore })];\n    } else {\n      logger.warn('Cache will not use Redis because it has not been configured.');\n      return [];\n    }\n  });\n})();\n\nlet memoryCache = cacheManager.caching({ store: 'memory', max: 256, ttl: 1 });\nlet cachePromise = redisCachePromise.then(redisCache => cacheManager.multiCaching([memoryCache].concat(redisCache)));\n\nconst myCacheManager = {\n  /**\n   * Create a cache that delegates to an async function on a cache miss.\n   * @param {string} name - identifies the cache.\n   * @param {CacheMissCallback} fn - function called to get the value on a cache miss.\n   */\n  create(name, fn, options) {\n    if (typeof fn !== 'function') {\n      throw new Error(`fn must be a function. fn = ${fn}`);\n    }\n\n    if (caches.has(name)) {\n      throw new Error(`Cache \"${name}\" already exists`);\n    }\n\n    let result = createCache(name, fn, options);\n    caches.set(name, result);\n    return result;\n  },\n\n  get(name) {\n    if (caches.has(name)) {\n      return caches.get(name);\n    }\n\n    throw new Error(`Cache \"${name}\" does not exist`);\n  },\n\n  hasCache(name) {\n    return caches.has(name);\n  },\n\n  /**\n   * Clear all named caches.\n   * This method should only be used by tests.\n   */\n  clear() {\n    caches.clear();\n    return cachePromise.then(cache => cache.reset());\n  },\n\n  /**\n   * Clear cache contents leaving cache-miss handler functions in place.\n   */\n  flush() {\n    return cachePromise.then(cache => cache.reset());\n  }\n};\n\nfunction createCache(name, fn, options) {\n  function cacheKey(key) {\n    return JSON.stringify({ ns: name, key });\n  }\n\n  function normalizeValue(item) {\n    if (item && item.value && item.ttl) {\n      return item.value;\n    } else {\n      return item;\n    }\n  }\n\n  /**\n   * Get an item from the cache.\n   */\n  function get(key) {\n    if (!(key && typeof key === 'string')) {\n      throw new Error('Cache key must be a string.');\n    }\n\n    /**\n     * The callback passed to cache.wrap cannot be an arrow function\n     * because its `this` argument is bound.\n     */\n    // eslint-disable-next-line prefer-arrow-callback\n    return cachePromise.then(cache => cache.wrap(cacheKey(key), function () {\n      logger.info(`Cache miss: namespace=\"${name}\", key=\"${key}\"`);\n      return Promise.resolve().then(() => fn(key)).then(normalizeValue);\n    }, { ttl: fp.get('stdTTL')(options) || DEFAULT_TTL_SECONDS }));\n  }\n\n  /**\n   * Evict an item from the cache.\n   */\n  function del(key) {\n    return cachePromise.then(cache => cache.del(cacheKey(key)));\n  }\n\n  function setInCache(key, item) {\n    return cachePromise.then(cache => cache.set(key, normalizeValue(item)));\n  }\n\n  function flush() {\n    return cachePromise.then(cache => cache.flush);\n  }\n\n  return {\n    get,\n    del,\n    // keys: cache.keys.bind(cache),\n    set: setInCache,\n    flush\n  };\n}\n\nmodule.exports = myCacheManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/cacheManager.js\n// module id = 34\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet { getTableName: physicalTableName } = require('../awsResourceNameProvider');\nlet Promise = require('bluebird');\nlet logger = require('../logger');\nlet describeDynamoTable = require('./describeDynamoTable');\nlet { hashKeyAttributeName } = require('./dynamoTableDescription');\nlet { DateTimeFormatterBuilder, LocalDate, ZoneId } = require('js-joda');\nlet { makeWritable } = require('./dynamoItemFilter');\nlet dynamoTable = require('./dynamoTable');\nlet fp = require('lodash/fp');\n\nconst DEFAULT_SCAN_EXPRESSIONS = {\n  ProjectionExpression: ['list', ', ',\n    ['at', 'AccountName'],\n    ['at', 'DeploymentID'],\n    ['at', 'Value', 'EndTimestamp'],\n    ['at', 'Value', 'EnvironmentName'],\n    ['at', 'Value', 'EnvironmentType'],\n    ['at', 'Value', 'Nodes'],\n    ['at', 'Value', 'OwningCluster'],\n    ['at', 'Value', 'RuntimeServerRoleName'],\n    ['at', 'Value', 'ServerRoleName'],\n    ['at', 'Value', 'ServiceName'],\n    ['at', 'Value', 'ServiceSlice'],\n    ['at', 'Value', 'ServiceVersion'],\n    ['at', 'Value', 'StartTimestamp'],\n    ['at', 'Value', 'Status'],\n    ['at', 'Value', 'User']]\n};\n\nconst ES_DATETIME_FORMAT = new DateTimeFormatterBuilder().appendInstant(3).toFormatter();\n\nfunction factory({ archivedDeploymentsTable, archivedDeploymentsIndex, runningDeploymentsTable }) {\n  let tableNames = [archivedDeploymentsTable, runningDeploymentsTable];\n\n  function myTables() {\n    return Promise.resolve(tableNames);\n  }\n\n  function create(item) {\n    return describeDynamoTable(runningDeploymentsTable).then(description =>\n      fp.flow(\n        makeWritable,\n        record => ({\n          record,\n          expressions: {\n            ConditionExpression: ['attribute_not_exists', ['at', hashKeyAttributeName(description)]]\n          }\n        }),\n        dynamoTable.create.bind(null, runningDeploymentsTable)\n      )(item)\n    );\n  }\n\n  function get(key) {\n    let firstFoundOrNull = fp.flow(fp.find(x => x !== null), fp.defaultTo(null));\n    return Promise.map(myTables(), tableName => dynamoTable.get(tableName, key))\n      .then(firstFoundOrNull);\n  }\n\n  function scanRunning(expressions) {\n    return dynamoTable.scan(runningDeploymentsTable, Object.assign({}, DEFAULT_SCAN_EXPRESSIONS, expressions));\n  }\n\n  function queryByDateRange(minInstant, maxInstant, expressions) {\n    function scanArchived() {\n      function next(prevKey) {\n        return prevKey.minusDays(1);\n      }\n\n      let createQuery = date => ({\n        IndexName: archivedDeploymentsIndex,\n        KeyConditionExpression: ['and',\n          ['=', ['at', 'StartDate'], ['val', date.toString()]],\n          ['>=', ['at', 'StartTimestamp'], ['val', ES_DATETIME_FORMAT.format(minInstant)]]],\n        Limit: 100,\n        ScanIndexForward: false\n      });\n\n      function loop(table, partition, lowerBound, results) {\n        let partitionContainingLowerBound = LocalDate.ofInstant(lowerBound, ZoneId.UTC);\n        if (partition.isBefore(partitionContainingLowerBound)) {\n          return results;\n        } else {\n          return dynamoTable.query(table, Object.assign({}, DEFAULT_SCAN_EXPRESSIONS, expressions, createQuery(partition)))\n            .then((result) => {\n              results.push(...result);\n              return loop(table, next(partition), lowerBound, results);\n            });\n        }\n      }\n\n      let firstPartition = LocalDate.ofInstant(maxInstant, ZoneId.UTC);\n      return loop(archivedDeploymentsTable, firstPartition, minInstant, [])\n      .catch((error) => {\n        logger.warn(error);\n        return [];\n      });\n    }\n\n    return Promise.join(\n      scanRunning(expressions),\n      scanArchived(),\n      (running, archived) => [...running, ...archived]);\n  }\n\n  function update(expression) {\n    return Promise.resolve().then(() =>\n      fp.flow(\n        ({ key, updateExpression }) => ({\n          key,\n          expressions: { UpdateExpression: updateExpression }\n        }),\n        dynamoTable.update.bind(null, runningDeploymentsTable)\n      )(expression)\n    );\n  }\n\n  function appendLogEntries({ key, logEntries }) {\n    let updateExpression = [\n      'update',\n      ['set',\n        ['at', 'Value', 'ExecutionLog'],\n        ['list_append',\n          ['at', 'Value', 'ExecutionLog'],\n          ['val', logEntries]]]\n    ];\n\n    return update({\n      key,\n      updateExpression\n    });\n  }\n\n  return {\n    appendLogEntries,\n    create,\n    get,\n    queryByDateRange,\n    scanRunning,\n    update\n  };\n}\n\nmodule.exports = factory({\n  archivedDeploymentsTable: physicalTableName('ConfigCompletedDeployments'),\n  archivedDeploymentsIndex: 'StartDate-StartTimestamp-index',\n  runningDeploymentsTable: physicalTableName('ConfigDeploymentExecutionStatus')\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/data-access/deployments.js\n// module id = 35\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet util = require('util');\nlet BaseError = require('./BaseError.class');\n\nmodule.exports = function ConfigurationError(message, innerError) {\n  this.name = this.constructor.name;\n  this.message = message;\n  this.innerError = innerError;\n\n  Error.captureStackTrace(this, this.constructor);\n};\n\nutil.inherits(module.exports, BaseError);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/errors/ConfigurationError.class.js\n// module id = 36\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet util = require('util');\nlet BaseError = require('./BaseError.class');\n\nmodule.exports = function ResourceNotFoundError(message, innerError) {\n  this.name = this.constructor.name;\n  this.message = message;\n  this.innerError = innerError;\n\n  Error.captureStackTrace(this, this.constructor);\n};\n\nutil.inherits(module.exports, BaseError);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/errors/ResourceNotFoundError.class.js\n// module id = 37\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nconst LOGICAL_TABLE_NAME = 'InfraConfigLBUpstream';\n\nlet {\n  getTableName: physicalTableName\n} = require('../awsResourceNameProvider');\nlet pages = require('../amazon-client/pages');\nlet { compile } = require('../awsDynamo/dynamodbExpression');\nlet { updateAuditMetadata } = require('./dynamoAudit');\nlet { createDynamoClient: documentClient } = require('../amazon-client/masterAccountClient');\nlet dynamoTable = require('./dynamoTable');\nlet singleAccountDynamoTable = require('./singleAccountDynamoTable');\nlet { setVersionOnUpdate } = require('./dynamoVersion');\n\nconst TABLE_NAME = physicalTableName(LOGICAL_TABLE_NAME);\n\nlet table = singleAccountDynamoTable(TABLE_NAME, dynamoTable);\n\nfunction inEnvironment(environment, { ExclusiveStartKey, Limit, ScanIndexForward } = {}) {\n  return documentClient()\n    .then((dynamo) => {\n      let KeyConditionExpression = ['=',\n        ['at', 'Environment'],\n        ['val', environment]];\n      let params = Object.assign(\n        {\n          IndexName: 'Environment-Key-index',\n          TableName: TABLE_NAME\n        },\n        (ExclusiveStartKey ? { ExclusiveStartKey } : {}),\n        (Limit ? { Limit } : {}),\n        (ScanIndexForward !== null && ScanIndexForward !== undefined ? { ScanIndexForward } : {}),\n        compile({ KeyConditionExpression }));\n      return dynamo.query(params);\n    })\n    .then(awsRequest => (Limit\n      ? awsRequest.promise().then(({ LastEvaluatedKey, Items }) => ({ LastEvaluatedKey, Items }))\n      : pages.flatten(rsp => rsp.Items, awsRequest).then(x => ({ Items: x }))));\n}\n\nfunction inEnvironmentWithService(environment, service) {\n  let params = {\n    FilterExpression: ['=',\n      ['at', 'Service'],\n      ['val', service]\n    ],\n    IndexName: 'Environment-Key-index',\n    KeyConditionExpression: ['=',\n      ['at', 'Environment'],\n      ['val', environment]]\n  };\n  return table.query(params);\n}\n\nfunction inEnvironmentWithUpstream(environment, upstream) {\n  let params = {\n    FilterExpression: ['=',\n      ['at', 'Upstream'],\n      ['val', upstream]\n    ],\n    IndexName: 'Environment-Key-index',\n    KeyConditionExpression: ['=',\n      ['at', 'Environment'],\n      ['val', environment]]\n  };\n  return table.query(params);\n}\n\nfunction inLoadBalancerGroup(loadBalancerGroup) {\n  return documentClient()\n    .then((dynamo) => {\n      let KeyConditionExpression = ['=',\n        ['at', 'LoadBalancerGroup'],\n        ['val', loadBalancerGroup]];\n      let params = Object.assign(\n        {\n          IndexName: 'LoadBalancerGroup-index',\n          TableName: TABLE_NAME\n        },\n        compile({ KeyConditionExpression }));\n      return pages.flatten(rsp => rsp.Items, dynamo.query(params)).then(x => ({ Items: x }));\n    });\n}\n\nfunction scan() {\n  return documentClient()\n    .then((dynamo) => {\n      let params = {\n        IndexName: 'Environment-Key-index',\n        TableName: TABLE_NAME\n      };\n      return pages.flatten(rsp => rsp.Items, dynamo.scan(params)).then(x => ({ Items: x }));\n    });\n}\n\nfunction determineState(host, toggleCommand, servicePortMappings) {\n  if (toggleCommand.activeSlice) {\n    return servicePortMappings[host.Port].toLowerCase() ===\n      toggleCommand.activeSlice.toLowerCase() ? 'up' : 'down';\n  }\n  return host.State.toUpperCase() === 'UP' ? 'down' : 'up';\n}\n\nfunction toggle(upstream, metadata, toggleCommand, servicePortMappings) {\n  let invert = host => determineState(host, toggleCommand, servicePortMappings);\n\n  let key = { Key: upstream.Key };\n  let expressions = {\n    ConditionExpression: ['and',\n      ...(upstream.Hosts.map((host, i) => ['=', ['at', 'Hosts', i, 'State'], ['val', host.State]]))],\n    UpdateExpression: updateAuditMetadata({\n      updateExpression: ['update',\n        ...(upstream.Hosts.map((host, i) => ['set', ['at', 'Hosts', i, 'State'], ['val', invert(host)]]))],\n      metadata\n    })\n  };\n\n  return dynamoTable.update(TABLE_NAME, setVersionOnUpdate({ key, expressions }));\n}\n\nmodule.exports = {\n  create: table.create,\n  delete: table.delete,\n  get: table.get,\n  inEnvironment,\n  inEnvironmentWithService,\n  inEnvironmentWithUpstream,\n  inLoadBalancerGroup,\n  replace: table.replace,\n  scan,\n  toggle,\n  update: table.update\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/data-access/loadBalancerUpstreams.js\n// module id = 38\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet logger = require('../../modules/logger');\nlet deploymentLogger = require('../../modules/DeploymentLogger');\n\nmodule.exports = function DeploymentCommandHandlerLogger(commandOrDeploymentId) {\n  let deploymentId = (() => {\n    if (typeof commandOrDeploymentId === 'string') {\n      return commandOrDeploymentId;\n    } else {\n      return commandOrDeploymentId.deploymentId || commandOrDeploymentId.commandId;\n    }\n  })();\n\n  this.debug = logger.debug.bind(logger);\n\n  this.info = function (message) {\n    logger.info(message);\n    deploymentLogger.inProgress(deploymentId, message);\n  };\n\n  this.warn = function (message) {\n    logger.warn(message);\n    deploymentLogger.inProgress(deploymentId, message);\n  };\n\n  this.error = logger.error.bind(logger);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/commands/deployments/DeploymentCommandHandlerLogger.js\n// module id = 39\n// module chunks = 0","module.exports = require(\"path\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"path\"\n// module id = 40\n// module chunks = 0","module.exports = require(\"uuid/v1\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"uuid/v1\"\n// module id = 41\n// module chunks = 0","module.exports = require(\"ms\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"ms\"\n// module id = 42\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet _ = require('lodash');\nlet environmentDatabase = require('../modules/environmentDatabase');\n\nclass EnvironmentType {\n\n  constructor(data) {\n    _.assign(this, data);\n  }\n\n  static getByName(name) {\n    return environmentDatabase.getEnvironmentTypeByName(name);\n  }\n\n}\n\nmodule.exports = EnvironmentType;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/models/EnvironmentType.js\n// module id = 43\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet config = require('../../config');\nlet consul = require('consul');\nlet mock = require('./clientConfig.mock.js');\nlet prod = require('./clientConfig.prod.js');\n\nlet clientConfig = config.get('IS_PRODUCTION') ? prod : mock;\n\nfunction createConfig(options) {\n  return clientConfig(options);\n}\n\nfunction create(options) {\n  return createConfig(options).then(newConfig => consul(newConfig));\n}\n\nmodule.exports = { createConfig, create };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/consul-client/index.js\n// module id = 44\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nconst LOGICAL_TABLE_NAME = 'InfraOpsEnvironment';\nconst TTL = 1200; // seconds\n\nlet physicalTableName = require('../awsResourceNameProvider').getTableName;\nlet cachedSingleAccountDynamoTable = require('./cachedSingleAccountDynamoTable');\n\nlet table = cachedSingleAccountDynamoTable(physicalTableName(LOGICAL_TABLE_NAME), { ttl: TTL });\n\nfunction setSchedule({ key, metadata, schedule }, expectedVersion) {\n  let scheduleAttributes = Object.keys(schedule).map(prop => ['set', ['at', 'Value', prop], ['val', schedule[prop]]]);\n  let updateExpression = ['update', ...scheduleAttributes];\n  return table.update({ key, metadata, updateExpression }, expectedVersion);\n}\n\nfunction setMaintenance({ key, metadata, isInMaintenance }, expectedVersion) {\n  let updateExpression = ['update',\n    ['set', ['at', 'Value', 'EnvironmentInMaintenance'], ['val', isInMaintenance]]\n  ];\n  return table.update({ key, metadata, updateExpression }, expectedVersion);\n}\n\nfunction setDeploymentLock({ key, metadata, isLocked }, expectedVersion) {\n  let updateExpression = ['update',\n    ['set', ['at', 'Value', 'DeploymentsLocked'], ['val', isLocked]]\n  ];\n  return table.update({ key, metadata, updateExpression }, expectedVersion);\n}\n\nmodule.exports = Object.assign({}, table, { setDeploymentLock, setMaintenance, setSchedule });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/data-access/opsEnvironment.js\n// module id = 45\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs_1 = require(\"fs\");\nconst path_1 = require(\"path\");\nmodule.exports = function findInAncestor(relativePath, startDir = \".\") {\n    function loop(dir) {\n        const file = path_1.resolve(dir, relativePath);\n        const parentDir = path_1.dirname(dir);\n        if (fs_1.existsSync(file)) {\n            return file;\n        }\n        else if (dir === parentDir) {\n            return undefined;\n        }\n        else {\n            return loop(parentDir);\n        }\n    }\n    return loop(path_1.resolve(startDir));\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/find-in-ancestor.ts\n// module id = 46\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet fp = require('lodash/fp');\n\nlet tableArn = fp.get(['Table', 'TableArn']);\n\nlet hashKeyAttributeName = fp.flow(\n  fp.get(['Table', 'KeySchema']),\n  fp.find({ KeyType: 'HASH' }),\n  fp.get(['AttributeName']));\n\nlet keyAttributeNames = fp.flow(\n  fp.get(['Table', 'KeySchema']),\n  fp.map(fp.get(['AttributeName'])));\n\nlet tableName = fp.get(['Table', 'TableName']);\n\nlet extractKey = (tableDescription, item) => fp.pick(keyAttributeNames(tableDescription))(item);\n\n/**\n * @description Construct a DynamoDB hash key\n * @param {object} tableDescription - The table description\n * @param {string} key - The value of the hash key\n * @returns {object} - The DynamoDB hash key\n * @example\n * For a table having a hash key attribute named 'ID'\n * hashkey(tableDescription, '1006') -> { ID: '1006' }\n */\nlet hashKey = (tableDescription, key) => fp.fromPairs([\n  [hashKeyAttributeName(tableDescription), key]\n]);\n\nmodule.exports = {\n  extractKey,\n  hashKey,\n  hashKeyAttributeName,\n  keyAttributeNames,\n  tableName,\n  tableArn\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/data-access/dynamoTableDescription.js\n// module id = 47\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet extractKey = require('./dynamoTableDescription').extractKey;\nlet describeDynamoTable = require('./describeDynamoTable');\nlet pages = require('../amazon-client/pages');\nlet { createDynamoClient: DocumentClient } = require('../amazon-client/masterAccountClient');\nlet compile = require('../awsDynamo/dynamodbExpression').compile;\n\nfunction compileIfSet(expressions) {\n  if (expressions && typeof expressions === 'object') {\n    return compile(expressions);\n  } else {\n    return {};\n  }\n}\n\nlet logError = params => (error) => {\n  console.error(JSON.stringify(params, null, 2));\n  return Promise.reject(error);\n};\n\nfunction get(TableName, key) {\n  let params = {\n    TableName,\n    Key: key\n  };\n  return DocumentClient()\n    .then(dynamo => dynamo.get(params).promise())\n    .then(result => result.Item || null)\n    .catch(logError(params));\n}\n\nfunction scan(TableName, expressions) {\n  let params = Object.assign({ TableName }, compileIfSet(expressions));\n  return DocumentClient()\n    .then(dynamo => pages.flatten(rsp => rsp.Items, dynamo.scan(params)))\n    .catch(logError(params));\n}\n\nfunction query(TableName, expressions) {\n  let params = Object.assign({ TableName }, compileIfSet(expressions));\n  return DocumentClient()\n    .then(dynamo => pages.flatten(rsp => rsp.Items, dynamo.query(params)))\n    .catch(logError(params));\n}\n\nfunction create(TableName, { record, expressions }) {\n  return describeDynamoTable(TableName).then((tableDescription) => {\n    let params = Object.assign({ TableName, Item: record }, compileIfSet(expressions));\n    return DocumentClient()\n      .then(dynamo => dynamo.put(params).promise())\n      .catch((error) => {\n        if (error.code === 'ConditionalCheckFailedException') {\n          let keyStr = JSON.stringify(extractKey(tableDescription, record));\n          let message = `Could not create this item because an item with the same key already exists. table = ${TableName} key = ${keyStr}.`;\n          return Promise.reject(new Error(message));\n        }\n        return Promise.reject(error);\n      })\n      .catch(logError(params));\n  });\n}\n\nfunction replace(TableName, { record, expressions }) {\n  return describeDynamoTable(TableName).then((tableDescription) => {\n    let params = Object.assign({ TableName, Item: record }, compileIfSet(expressions));\n    return DocumentClient()\n      .then(dynamo => dynamo.put(params).promise())\n      .catch((error) => {\n        if (error.code === 'ConditionalCheckFailedException') {\n          let keyStr = JSON.stringify(extractKey(tableDescription, record));\n          let message = `Could not update this item because it has been modified. table = ${TableName} key = ${keyStr}.`;\n          return Promise.reject(new Error(message));\n        }\n        return Promise.reject(error);\n      })\n      .catch(logError(params));\n  });\n}\n\nfunction update(TableName, { key, expressions }) {\n  return Promise.resolve().then(() => {\n    let params = Object.assign({ TableName, Key: key }, compileIfSet(expressions));\n    return DocumentClient()\n      .then(dynamo => dynamo.update(params).promise())\n      .catch((error) => {\n        if (error.code === 'ConditionalCheckFailedException') {\n          let keyStr = JSON.stringify(key);\n          let message = `Could not update this item because it has been modified. table = ${TableName} key = ${keyStr}.`;\n          return Promise.reject(new Error(message));\n        }\n        return Promise.reject(error);\n      })\n      .catch(logError(params));\n  });\n}\n\nfunction $delete(TableName, { key, expressions }) {\n  return Promise.resolve().then(() => {\n    let params = Object.assign({ TableName, Key: key }, compileIfSet(expressions));\n    return DocumentClient()\n      .then(dynamo => dynamo.delete(params).promise())\n      .catch((error) => {\n        if (error.code === 'ConditionalCheckFailedException') {\n          let keyStr = JSON.stringify(key);\n          let message = `Could not delete this item because it has been modified. table = ${TableName} key = ${keyStr}.`;\n          return Promise.reject(new Error(message));\n        }\n        return Promise.reject(error);\n      })\n      .catch(logError(params));\n  });\n}\n\nmodule.exports = {\n  create,\n  delete: $delete,\n  get,\n  query,\n  replace,\n  scan,\n  update\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/data-access/dynamoTable.js\n// module id = 48\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\n/**\n * Analogue of Array.reduce that iterates over the pages of an AWS Request object.\n *\n * @param {function} callback - (accumulator, page) -> accumulator.\n * @param {any} initialValue - initial value of accumulator.\n * @param {object} awsRequest - an instance of AWS.Request.\n *   See http://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/Request.html#eachPage\n * @returns {any} - returns the value of accumulator after applying callback to the\n *   last page.\n */\nfunction reduce(callback, initialValue, awsRequest) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback must be a function');\n  }\n\n  let accumulator = initialValue;\n  return new Promise((resolve, reject) => {\n    awsRequest.eachPage((error, data) => {\n      if (error) {\n        reject(error);\n        return false;\n      } else if (data === null) {\n        resolve(accumulator);\n        return false;\n      } else {\n        accumulator = callback(accumulator, data);\n        return true;\n      }\n    });\n  });\n}\n\n/**\n * Flattens the result pages of an AWS Request object into a single array.\n *\n * @param {function} callback - page -> items. Selects the items that should be\n *   returned from the page.\n * @param {object} awsRequest - an instance of AWS.Request.\n *   See http://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/Request.html#eachPage\n * @returns {array} - returns the value of accumulator after applying callback to the\n *   last page.\n */\nfunction flatten(callback, awsRequest) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback must be a function');\n  }\n\n  function extractAndConcatItems(accumulator, page) {\n    let items = callback(page);\n    if (Array.isArray(items)) {\n      items.forEach(item => accumulator.push(item));\n    } else {\n      accumulator.push(items);\n    }\n    return accumulator;\n  }\n\n  return reduce(extractAndConcatItems, [], awsRequest);\n}\n\nmodule.exports = {\n  reduce,\n  flatten\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/amazon-client/pages.js\n// module id = 49\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet config = require('../../config');\nconst mock = require('./userService.mock');\nconst Prod = require('./userService.prod');\nlet implementation;\n\nif (config.get('IS_PRODUCTION')) {\n  implementation = new Prod();\n} else {\n  implementation = mock;\n}\n\nmodule.exports = implementation;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/user-service/index.js\n// module id = 50\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\n/**\n * Attempts to parse a JSON string into an object, returning null on error\n *\n * @param raw {String} The raw JSON string\n * @returns {Object|null} The parsed Object or null if a parsing error occured.\n */\nfunction safeParseJSON(raw) {\n  try {\n    return JSON.parse(raw);\n  } catch (exception) {\n    return null;\n  }\n}\n\n/**\n *\n * @param date\n * @param offset\n * @returns {*}\n */\nfunction offsetMilliseconds(date, offset) {\n  date.setMilliseconds(date.getMilliseconds() + offset);\n  return date;\n}\n\nmodule.exports = { safeParseJSON, offsetMilliseconds };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/utilities.js\n// module id = 51\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet _ = require('lodash');\nlet assert = require('assert');\nlet co = require('co');\nlet ConfigurationError = require('../errors/ConfigurationError.class');\nlet DynamoItemNotFoundError = require('../errors/DynamoItemNotFoundError.class');\nlet imageProvider = require('./launchConfiguration/imageProvider');\nlet Environment = require('../../models/Environment');\nlet EnvironmentType = require('../../models/EnvironmentType');\nlet clusters = require('../data-access/clusters');\nlet servicesDb = require('../data-access/services');\n\nmodule.exports = {\n  get(environmentName, serviceName, serverRoleName) {\n    assert(environmentName, 'Expected \\'environmentName\\' argument not to be null or empty');\n    assert(serviceName, 'Expected \\'serviceName\\' argument not to be null or empty');\n    assert(serverRoleName, 'Expected \\'serviceName\\' argument not to be null or empty');\n\n    return co(function* () {\n      let environment = yield Environment.getByName(environmentName);\n      let deploymentMap = yield environment.getDeploymentMap();\n      let service = yield getServiceByName(serviceName);\n      let environmentType = yield EnvironmentType.getByName(environment.EnvironmentType).catch(\n        error => Promise.reject(new ConfigurationError(\n          `An error has occurred retrieving environment \"${environmentName}\" environment type.`,\n          error))\n      );\n      let serverRole = _.find(deploymentMap.DeploymentTarget, { ServerRoleName: serverRoleName });\n\n      let cluster = yield getClusterByName(serverRole.OwningCluster);\n      let image = yield imageProvider.get(serverRole.AMI);\n      let configuration = {\n        environmentTypeName: environment.EnvironmentType,\n        environmentName,\n        serviceName,\n        environmentType,\n        environment,\n        serverRole,\n        service,\n        cluster,\n        image\n      };\n      return Promise.resolve(configuration);\n    });\n  }\n};\n\nfunction getServiceByName(serviceName) {\n  return servicesDb.get({ ServiceName: serviceName })\n    .then(service =>\n      (service ?\n        Promise.resolve(service.Value) :\n        Promise.reject(new ConfigurationError(`Service \"${serviceName}\" not found.`))))\n    .catch((error) => {\n      throw new Error(`An error has occurred retrieving \"${serviceName}\" service: ${error.message}`);\n    });\n}\n\nfunction getClusterByName(clusterName) {\n  return clusters.get({ ClusterName: clusterName })\n    .then(\n    cluster => Promise.resolve({\n      Name: cluster.ClusterName,\n      ShortName: cluster.Value.ShortName,\n      KeyPair: cluster.Value.KeyPair\n    }),\n    error => Promise.reject(error instanceof DynamoItemNotFoundError ?\n      new ConfigurationError(`Cluster \"${clusterName}\" not found.`) :\n      new Error(`An error has occurred retrieving \"${clusterName}\" cluster: ${error.message}`)\n    ));\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/provisioning/infrastructureConfigurationProvider.js\n// module id = 52\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet awsAccounts = require('../modules/awsAccounts');\nlet applyFuncToAccounts = require('../modules/queryHandlersUtil/applyFuncToAccounts');\nlet imageSummary = require('../modules/machineImage/imageSummary');\nlet ec2ImageResourceFactory = require('../modules/resourceFactories/ec2ImageResourceFactory');\n\nmodule.exports = function ScanCrossAccountImages(query) {\n  return awsAccounts.all()\n    .then(accounts => applyFuncToAccounts(({ AccountName }) => getFromSingleAccount(Object.assign({ accountName: AccountName }, query)), accounts))\n    .then(images =>\n      imageSummary\n      .rank(images.map(image => Object.assign({ AccountName: image.AccountName }, imageSummary.summaryOf(image)))\n      .sort(imageSummary.compare))\n    );\n};\n\nfunction getFromSingleAccount(query) {\n  let parameters = { accountName: query.accountName };\n  return ec2ImageResourceFactory.create(undefined, parameters)\n    .then(resource => resource.all({ filter: query.filter }));\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/queryHandlers/ScanCrossAccountImages.js\n// module id = 53\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet configEnvironments = require('./data-access/configEnvironments');\nlet configEnvironmentTypes = require('./data-access/configEnvironmentTypes');\nlet ConfigurationError = require('./errors/ConfigurationError.class');\n\nfunction getEnvironmentByName(environmentName) {\n  return configEnvironments.get({ EnvironmentName: environmentName })\n    .then((environment) => {\n      if (environment) {\n        return Promise.resolve(environment.Value);\n      } else {\n        return Promise.reject(new ConfigurationError(`Environment \"${environmentName}\" not found.`));\n      }\n    });\n}\n\nfunction getEnvironmentTypeByName(environmentTypeName) {\n  return configEnvironmentTypes.get({ EnvironmentType: environmentTypeName })\n    .then((environment) => {\n      if (environment) {\n        return Promise.resolve(environment.Value);\n      } else {\n        return Promise.reject(new ConfigurationError(`Environment type \"${environmentTypeName}\" not found.`));\n      }\n    });\n}\n\nmodule.exports = {\n  getEnvironmentByName,\n  getEnvironmentTypeByName\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/environmentDatabase.js\n// module id = 54\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nconst LOGICAL_TABLE_NAME = 'ConfigEnvironmentTypes';\nconst TTL = 600; // seconds\n\nlet physicalTableName = require('../awsResourceNameProvider').getTableName;\nlet cachedSingleAccountDynamoTable = require('./cachedSingleAccountDynamoTable');\n\nmodule.exports = cachedSingleAccountDynamoTable(physicalTableName(LOGICAL_TABLE_NAME), { ttl: TTL });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/data-access/configEnvironmentTypes.js\n// module id = 55\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet assert = require('assert');\nlet getASG = require('../modules/queryHandlersUtil/getASG');\n\nmodule.exports = function GetAutoScalingGroup(query) {\n  assert(query.accountName);\n  assert(query.autoScalingGroupName);\n\n  return getASG(query);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/queryHandlers/GetAutoScalingGroup.js\n// module id = 56\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet co = require('co');\nlet environmentDatabase = require('./environmentDatabase');\nlet cacheManager = require('./cacheManager');\n\nconst TEN_MINUTES = 10 * 60;\n\ncacheManager.create('Environment', x => environmentDatabase.getEnvironmentByName(x), { stdTTL: TEN_MINUTES });\ncacheManager.create('EnvironmentType', x => environmentDatabase.getEnvironmentTypeByName(x), { stdTTL: TEN_MINUTES });\n\nfunction getEnvironmentByName(name) {\n  return cacheManager.get('Environment').get(name);\n}\n\nfunction getEnvironmentTypeByName(name) {\n  return cacheManager.get('EnvironmentType').get(name);\n}\n\nfunction getConsulConfig(environmentName) {\n  return co(function* () {\n    let environment = yield getEnvironmentByName(environmentName);\n    let environmentType = yield getEnvironmentTypeByName(environment.EnvironmentType);\n    return environmentType.Consul;\n  });\n}\n\nmodule.exports = {\n  getEnvironmentByName,\n  getEnvironmentTypeByName,\n  getConsulConfig\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/configurationCache.js\n// module id = 57\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet _ = require('lodash');\nlet amazonClientFactory = require('../amazon-client/childAccountClient');\n\nlet AwsError = require('../errors/AwsError.class');\nlet LaunchConfigurationAlreadyExistsError = require('../errors/LaunchConfigurationAlreadyExistsError.class');\n\nfunction standardifyError(error, launchConfigurationName) {\n  if (!error) return null;\n\n  let awsError = new AwsError(error.message);\n\n  if (error.code === 'AlreadyExists') {\n    return new LaunchConfigurationAlreadyExistsError(\n      `LaunchConfiguration \"${launchConfigurationName}\" already exists`, awsError\n    );\n  }\n\n  return awsError;\n}\n\nfunction cleanup(launchconfig) {\n  delete launchconfig.LaunchConfigurationARN;\n  delete launchconfig.CreatedTime;\n\n  if (_.isNull(launchconfig.KernelId) || _.isEmpty(launchconfig.KernelId)) delete launchconfig.KernelId;\n  if (_.isNull(launchconfig.RamdiskId) || _.isEmpty(launchconfig.RamdiskId)) delete launchconfig.RamdiskId;\n}\n\nclass LaunchConfigurationResource {\n\n  constructor(client) {\n    this.client = client;\n  }\n\n  describeLaunchConfigurations(names) {\n    let self = this;\n    let launchconfigs = [];\n    let request = {};\n\n    if (names.length) {\n      request.LaunchConfigurationNames = names;\n    }\n\n    function query() {\n      return self.client.describeLaunchConfigurations(request).promise().then((data) => {\n        launchconfigs = launchconfigs.concat(data.LaunchConfigurations);\n\n        if (!data.NextToken) return launchconfigs;\n\n        // Scan from next index\n        request.NextToken = data.NextToken;\n        return query();\n      });\n    }\n\n    return query();\n  }\n\n  get(parameters) {\n    return this.describeLaunchConfigurations([parameters.name]).then(data => data[0]);\n  }\n\n  all(parameters) {\n    return this.describeLaunchConfigurations(parameters.names || []);\n  }\n\n  delete({ name }) {\n    let request = { LaunchConfigurationName: name };\n\n    return this.client.deleteLaunchConfiguration(request).promise().catch((error) => {\n      throw standardifyError(error, name);\n    });\n  }\n\n  post(parameters) {\n    cleanup(parameters);\n\n    let request = parameters;\n    return this.client.createLaunchConfiguration(request).promise().catch((error) => {\n      throw standardifyError(error, parameters.LaunchConfigurationName);\n    });\n  }\n}\n\nmodule.exports = {\n\n  canCreate: resourceDescriptor =>\n    resourceDescriptor.type.toLowerCase() === 'launchconfig',\n\n  create: (resourceDescriptor, parameters) =>\n    amazonClientFactory.createASGClient(parameters.accountName).then(client => new LaunchConfigurationResource(client))\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/resourceFactories/launchConfigurationResourceFactory.js\n// module id = 58\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet systemUser = require('./systemUser');\nlet sender = require('./sender');\nlet deployments = require('./data-access/deployments');\nlet DeploymentLogsStreamer = require('./DeploymentLogsStreamer');\nlet deploymentLogsStreamer = new DeploymentLogsStreamer();\nlet Enums = require('../Enums');\nlet logger = require('./logger');\nlet UpdateTargetState = require('../commands/services/UpdateTargetState');\n\nmodule.exports = {\n  started(deployment, accountName) {\n    let record = {\n      AccountName: deployment.accountName,\n      DeploymentID: deployment.id,\n      Value: {\n        DeploymentType: 'Parallel',\n        EnvironmentName: deployment.environmentName,\n        EnvironmentType: deployment.environmentTypeName,\n        OwningCluster: deployment.clusterName,\n        SchemaVersion: 2,\n        ServiceName: deployment.serviceName,\n        ServiceSlice: deployment.serviceSlice,\n        ServiceVersion: deployment.serviceVersion,\n        RuntimeServerRoleName: deployment.serverRole,\n        ServerRoleName: deployment.serverRoleName,\n        Status: 'In Progress',\n        User: deployment.username,\n        StartTimestamp: new Date().toISOString(),\n        EndTimestamp: null,\n        ExecutionLog: []\n      }\n    };\n\n    return deployments.create(record).then(() => {\n      deploymentLogsStreamer.log(deployment.id, accountName, 'Deployment started');\n    });\n  },\n\n  inProgress(deploymentId, message) {\n    deploymentLogsStreamer.log(deploymentId, message);\n  },\n\n  updateStatus(deploymentStatus, newStatus) {\n    let logError = error => logger.error(error);\n\n    logger.debug(`Updating deployment '${deploymentStatus.deploymentId}' status to '${newStatus.name}'`);\n\n    /**\n     * flush log entries before changing status. A status change may move\n     * the record to another table. If this occurs before the log entries\n     * are flushed then the log entries may not be written.\n     */\n    return updateDeploymentTargetState(deploymentStatus, newStatus)\n      .catch(logError)\n      .then(() => deploymentLogsStreamer.log(deploymentStatus.deploymentId, newStatus.reason))\n      .then(() => deploymentLogsStreamer.flush(deploymentStatus.deploymentId))\n      .catch(logError)\n      .then(() => updateDeploymentDynamoTable(deploymentStatus, newStatus))\n      .catch(logError);\n  }\n};\n\nfunction updateDeploymentDynamoTable(deploymentStatus, newStatus) {\n  let { Success, InProgress } = Enums.DEPLOYMENT_STATUS;\n  let running = newStatus.name === InProgress;\n  let succeeded = newStatus.name === Success;\n\n  let updateExpression = ['update',\n    ['set', ['at', 'Value', 'Status'], ['val', newStatus.name]],\n    ['set', ['at', 'Value', 'Nodes'], ['val', deploymentStatus.nodesDeployment || []]]\n  ];\n\n  if (!running && !succeeded && newStatus.reason !== undefined) {\n    updateExpression.push(['set', ['at', 'Value', 'ErrorReason'], ['val', newStatus.reason]]);\n  }\n  if (!running) {\n    updateExpression.push(['set', ['at', 'Value', 'EndTimestamp'], ['val', new Date().toISOString()]]);\n  }\n\n  return deployments.update({ key: { DeploymentID: deploymentStatus.deploymentId }, updateExpression });\n}\n\nfunction updateDeploymentTargetState(deploymentStatus, newStatus) {\n  let command = {\n    deploymentId: deploymentStatus.deploymentId,\n    name: 'UpdateTargetState',\n    environment: deploymentStatus.environmentName,\n    key: `deployments/${deploymentStatus.deploymentId}/overall_status`,\n    value: newStatus.name\n  };\n\n  return sender.sendCommand(UpdateTargetState, { command, user: systemUser });\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/DeploymentLogger.js\n// module id = 59\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet _ = require('lodash');\nlet co = require('co');\nlet amazonClientFactory = require('../modules/amazon-client/childAccountClient');\nlet Environment = require('./Environment');\nlet moment = require('moment');\nlet logger = require('../modules/logger');\nlet TaggableMixin = require('./TaggableMixin');\nconst InstanceResourceBase = require('../modules/resourceFactories/InstanceResourceBase');\nlet scanCrossAccountFn = require('../modules/queryHandlersUtil/scanCrossAccountFn');\n\nclass Instance {\n  constructor(data) {\n    _.assign(this, data);\n    this.CreationTime = this.getCreationTime();\n  }\n\n  getAutoScalingGroupName() {\n    return this.getTag('aws:autoscaling:groupName');\n  }\n\n  persistTag(tag) {\n    return amazonClientFactory.createEC2Client(this.AccountName)\n    .then(client => new InstanceResourceBase(client))\n    .then((instanceResource) => {\n      let parameters = {\n        instanceIds: [this.InstanceId],\n        tagKey: tag.key,\n        tagValue: tag.value\n      };\n\n      return instanceResource.setTag(parameters);\n    });\n  }\n\n  getCreationTime() {\n    return _.get(this, 'BlockDeviceMappings[0].Ebs.AttachTime');\n  }\n\n  static getById(instanceId) {\n    function findInstanceInAccount({ AccountNumber }) {\n      return amazonClientFactory.createEC2Client(AccountNumber)\n      .then(client => new InstanceResourceBase(client))\n      .then(instanceResource => instanceResource.all({ filter: { 'instance-id': instanceId } }))\n      .then(instances => instances.map(instance => new TaggableInstance(instance)));\n    }\n    return scanCrossAccountFn(findInstanceInAccount).then(([head]) => head);\n  }\n\n  static getAllByEnvironment(environmentName) {\n    return co(function* () {\n      let accountName = yield Environment.getAccountNameForEnvironment(environmentName);\n      let startTime = moment.utc();\n      return amazonClientFactory.createEC2Client(accountName)\n        .then(client => new InstanceResourceBase(client))\n        .then(instanceResource => instanceResource.all({ filter: { 'tag:Environment': environmentName } }))\n        .then(instances => instances.map(instance => new TaggableInstance(instance)))\n        .then((result) => {\n          let duration = moment.duration(moment.utc().diff(startTime)).asMilliseconds();\n          logger.debug(`server-status-query: InstancesQuery took ${duration}ms`);\n          return result;\n        });\n    });\n  }\n}\n\nclass TaggableInstance extends TaggableMixin(Instance) { }\n\nmodule.exports = TaggableInstance;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/models/Instance.js\n// module id = 60\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet co = require('co');\nconst asgResourceFactory = require('../modules/resourceFactories/asgResourceFactory');\n\nfunction* handler(query) {\n  // Create an instance of the resource to work with based on the resource\n  // descriptor and AWS account name.\n  let parameters = { accountName: query.accountName };\n  let resource = yield asgResourceFactory.create(undefined, parameters);\n\n  return resource.all({ names: query.autoScalingGroupNames });\n}\n\nmodule.exports = co.wrap(handler);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/queryHandlers/ScanAutoScalingGroups.js\n// module id = 61\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet util = require('util');\nlet BaseError = require('./BaseError.class');\n\nmodule.exports = function InvalidOperationError(message, innerError) {\n  this.name = this.constructor.name;\n  this.message = message;\n  this.innerError = innerError;\n\n  Error.captureStackTrace(this, this.constructor);\n};\n\nutil.inherits(module.exports, BaseError);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/errors/InvalidOperationError.class.js\n// module id = 62\n// module chunks = 0","module.exports = require(\"url\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"url\"\n// module id = 63\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet consulReporter = require('./consul');\n\n/**\n * Service Discovery abstraction to allow easy switching\n * of service discovery frameworks.\n */\nmodule.exports = consulReporter;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/service-discovery/index.js\n// module id = 64\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nconst ec2InstanceResourceFactory = require('../modules/resourceFactories/ec2InstanceResourceFactory');\n\nmodule.exports = function ScanInstancesQueryHandler({ accountName, filter }) {\n  return ec2InstanceResourceFactory.create(undefined, { accountName })\n    .then(x => x.all({ filter }));\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/queryHandlers/ScanInstances.js\n// module id = 65\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nconst LOGICAL_TABLE_NAME = 'InfraConfigPermissions';\nconst TTL = 600; // seconds\n\nlet physicalTableName = require('../awsResourceNameProvider').getTableName;\nlet cachedSingleAccountDynamoTable = require('./cachedSingleAccountDynamoTable');\n\nmodule.exports = cachedSingleAccountDynamoTable(physicalTableName(LOGICAL_TABLE_NAME), { ttl: TTL });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/data-access/permissions.js\n// module id = 66\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet { attachAuditMetadata, updateAuditMetadata } = require('./dynamoAudit');\nlet describeDynamoTable = require('./describeDynamoTable');\nlet { hashKeyAttributeName } = require('./dynamoTableDescription');\nlet { makeWritable } = require('./dynamoItemFilter');\nlet dynamoVersion = require('./dynamoVersion');\nlet { softDelete } = require('./dynamoSoftDelete');\nlet fp = require('lodash/fp');\n\nfunction factory(physicalTableName, dynamoTable) {\n  let tableDescriptionPromise = () => describeDynamoTable(physicalTableName);\n\n  function create(item) {\n    return tableDescriptionPromise().then(description =>\n      fp.flow(\n        makeWritable,\n        attachAuditMetadata,\n        record => ({ record }),\n        dynamoVersion.compareAndSetVersionOnCreate(hashKeyAttributeName(description)),\n        dynamoTable.create.bind(null, physicalTableName)\n      )(item)\n    );\n  }\n\n  function $delete(item, expectedVersion, { ConditionExpression } = {}) {\n    let { key, metadata } = item;\n    let keyExpresionPair = softDelete({ key, metadata, expectedVersion });\n    if (ConditionExpression) {\n      let { expressions } = keyExpresionPair;\n      expressions.ConditionExpression = ['and', ConditionExpression, expressions.ConditionExpression];\n    }\n    return dynamoTable.update(physicalTableName, keyExpresionPair)\n      .then(() => dynamoTable.delete(physicalTableName, { key }));\n  }\n\n  function get(key) {\n    return dynamoTable.get(physicalTableName, key);\n  }\n\n  function put(item, expectedVersion) {\n    return tableDescriptionPromise().then(description =>\n      fp.flow(\n        makeWritable,\n        attachAuditMetadata,\n        record => ({ record, expectedVersion }),\n        dynamoVersion.compareAndSetVersionOnPut(hashKeyAttributeName(description)),\n        dynamoTable.replace.bind(null, physicalTableName)\n      )(item)\n    );\n  }\n\n  function query(expression) {\n    return dynamoTable.query(physicalTableName, expression);\n  }\n\n  function replace(item, expectedVersion) {\n    return fp.flow(\n      makeWritable,\n      attachAuditMetadata,\n      record => ({ record, expectedVersion }),\n      dynamoVersion.compareAndSetVersionOnReplace,\n      dynamoTable.replace.bind(null, physicalTableName)\n    )(item);\n  }\n\n  function scan(expression) {\n    return dynamoTable.scan(physicalTableName, expression);\n  }\n\n  function update(expression, expectedVersion) {\n    return fp.flow(\n        updateAuditMetadata,\n        updateExpression => ({\n          key: expression.key,\n          expressions: { UpdateExpression: updateExpression },\n          expectedVersion\n        }),\n        dynamoVersion.compareAndSetVersionOnUpdate,\n        dynamoTable.update.bind(null, physicalTableName)\n      )(expression);\n  }\n\n  return {\n    create,\n    delete: $delete,\n    get,\n    put,\n    query,\n    replace,\n    scan,\n    update\n  };\n}\n\nmodule.exports = factory;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/data-access/singleAccountDynamoTable.js\n// module id = 67\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet { createLowLevelDynamoClient: DynamoDB } = require('../amazon-client/masterAccountClient');\nlet memoize = require('../memoize');\n\nfunction describeTableArn(TableName) {\n  return DynamoDB()\n  .then(dynamo => dynamo.describeTable({ TableName }).promise())\n  .then(({ Table }) => ({ Table }));\n}\n\n/**\n * @description Return a memoized description of a DynamoDB table\n * @param {string} TableName - The name of the table\n * @returns {object} - The table description\n */\nlet describe = memoize(describeTableArn);\n\nmodule.exports = describe;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/data-access/describeDynamoTable.js\n// module id = 68\n// module chunks = 0","'use strict';\n\nfunction expressionScope() {\n  let valName = i => `:val${i}`;\n  let expressionAttributeValues = {};\n  let expressionAttributeNames = {};\n  let i = 0;\n\n  function nameExpressionAttributeValue(value) {\n    let t = valName(i);\n    i += 1;\n    expressionAttributeValues[t] = value;\n    return t;\n  }\n\n  function nameExpressionAttributeName(result, name) {\n    if (typeof name === 'number') {\n      let elt = `[${name}]`;\n      return result === null ? elt : `${result}${elt}`;\n    } else {\n      let elt = `#${name}`;\n      expressionAttributeNames[elt] = name;\n      return result === null ? elt : `${result}.${elt}`;\n    }\n  }\n\n  return {\n    nameExpressionAttributeName,\n    nameExpressionAttributeValue,\n    ExpressionAttributeNames: expressionAttributeNames,\n    ExpressionAttributeValues: expressionAttributeValues\n  };\n}\n\nfunction compileOne(scope, expr) {\n  let compile = compileOne.bind(null, scope);\n  let infix = ([fn, ...args]) => {\n    let compiled = args.map(compile).join(` ${fn} `);\n    return args.length === 1 ? compiled : `(${compiled})`;\n  };\n  let prefix = ([fn, ...args]) => `${fn}(${args.map(compile).join(', ')})`;\n  let attr = ([, ...exprs]) => exprs.reduce(scope.nameExpressionAttributeName, null);\n  let val = ([, ...exprs]) => exprs.map(value => scope.nameExpressionAttributeValue(value)).join(', ');\n  let list = ([, sep, ...items]) => `${items.map(compile).join(sep)}`;\n  let update = ([, ...args]) => {\n    let assign = opargs => opargs.map(compile).join(' = ');\n    let ref = opargs => opargs.map(compile).join(', ');\n    let operatorCompiler = {\n      add: assign,\n      delete: ref,\n      remove: ref,\n      set: assign\n    };\n    let grouped = args.reduce((acc, [op, ...opargs]) => {\n      let stmt = operatorCompiler[op](opargs);\n      if (acc[op] === undefined) {\n        acc[op] = stmt;\n      } else {\n        acc[op] += `, ${stmt}`;\n      }\n      return acc;\n    }, {});\n    return Object.keys(grouped).map(key => `${key.toUpperCase()} ${grouped[key]}`).join(' ');\n  };\n  let compilers = {\n    '=': infix,\n    '<>': infix,\n    '<': infix,\n    '<=': infix,\n    '>': infix,\n    '>=': infix,\n    '+': infix,\n    '-': infix,\n    '/': infix,\n    '*': infix,\n    'and': infix,\n    'at': attr,\n    'attr': attr,\n    'list': list,\n    'or': infix,\n    'update': update,\n    'val': val\n  };\n\n  if (Array.isArray(expr) && expr.length > 0) {\n    let [fn] = expr;\n    let compiler = compilers[fn] || prefix;\n    return compiler(expr);\n  } else {\n    return `${expr}`;\n  }\n}\n\nfunction compileAll(expressions) {\n  let scope = expressionScope();\n  if (Array.isArray(expressions)) {\n    return compileAll({ Expression: expressions }, scope);\n  }\n  let result = {};\n  Object.keys(expressions).forEach((key) => {\n    result[key] = compileOne(scope, expressions[key]);\n  });\n  ['ExpressionAttributeNames', 'ExpressionAttributeValues'].forEach(\n    (key) => {\n      if (Object.keys(scope[key]).length > 0) {\n        result[key] = scope[key];\n      }\n    }\n  );\n  return Object.freeze(result);\n}\n\nmodule.exports = {\n  compile: compileAll\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/awsDynamo/dynamodbExpression.js\n// module id = 69\n// module chunks = 0","module.exports = require(\"express\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"express\"\n// module id = 70\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\n/* eslint-disable */\n/**\n * TODO: This file is used across both client and server.\n * Not only is this a bad idea but it makes it impossible to lint.\n * We should refactor the shared aspects of this module.\n */\n\nvar User = function(data) {\n\n  var _data = {\n    name: null,\n    expiration: 0\n  };\n\n  if(data) {\n    _data.name       = data.name || null;\n    _data.groups     = data.groups || [];\n    _data.expiration = data.expiration || 0;\n    _data.permissions = data.permissions || [];\n  }\n\n  this.getName = function() {\n    return _data.name;\n  };\n\n  this.getExpiration = function() {\n    return _data.expiration;\n  };\n\n  this.isAnonymous = function() {\n    return !!_data.name;\n  };\n\n  this.getPermissions = function () {\n    return _data.permissions;\n  };\n\n  this.hasPermission = function (requiredPermission) {\n    return _data.permissions.some(function(userPermission) {\n      if (userPermission.Resource && userPermission.Access) {\n        var matchingResources = globIntersection(requiredPermission.resource.toLowerCase(), userPermission.Resource.toLowerCase());\n        var matchingAccess = (userPermission.Access.toLowerCase() == requiredPermission.access.toLowerCase()) || userPermission.Access == 'ADMIN';\n\n        if (matchingAccess && matchingResources) {\n          return true;\n        }\n      }\n    });\n  };\n\n  this.getGroups = function () {\n    return _data.groups;\n  };\n\n  this.toString = function() {\n    return [_data.name, _data.expiration].join('|');\n  };\n\n  this.toJson = function() {\n    return _data;\n  };\n\n};\n\nUser.prototype.toString = function() { return 'User'; };\n\nif(typeof module !== 'undefined' && module.exports) {\n\n  module.exports = {\n\n    anonymous: function() {\n      return new User();\n    },\n\n    new: function(name, expiration, groups, permissions) {\n      return new User({\n        name: name,\n        expiration: expiration,\n        groups: groups,\n        permissions: permissions\n      });\n    },\n\n    parse: function(json) {\n      if(!json) return new User();\n\n      var user = new User({\n        name: json.name,\n        expiration: json.expiration,\n        groups: json.groups,\n        permissions: json.permissions\n      });\n\n      return user;\n    }\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./shared/user.js\n// module id = 71\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet assert = require('assert');\nlet config = require('../../config');\n\nlet cookieConfig;\n\nmodule.exports = {\n  getCookieName: () => {\n    loadConfiguration();\n    return cookieConfig.cookieName;\n  },\n\n  getCookieDuration: () => {\n    loadConfiguration();\n    return cookieConfig.cookieDuration;\n  }\n};\n\nfunction loadConfiguration() {\n  let localConfig = config.getUserValue('local');\n\n  assert(localConfig.authentication, 'missing \\'authentication\\' field in configuration');\n  assert(localConfig.authentication.cookieName, 'missing \\'authentication.cookieName\\' field in configuration');\n  assert(localConfig.authentication.cookieDuration, 'missing \\'authentication.cookieDuration\\' field in configuration');\n\n  cookieConfig = {\n    loginUrl: localConfig.authentication.loginUrl,\n    cookieName: localConfig.authentication.cookieName,\n    cookieDuration: localConfig.authentication.cookieDuration\n  };\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/authentications/cookieAuthenticationConfiguration.js\n// module id = 72\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet guid = require('uuid/v1');\n\nfunction createCommandId() {\n  return guid();\n}\n\nfunction createTimestamp() {\n  return new Date().toISOString();\n}\n\nfunction getUsername(user) {\n  return user.getName();\n}\n\nfunction createFromParameters(parameters) {\n  let command = Object.assign({}, parameters.command);\n\n  // Why must we override these if they are already set?\n  if (parameters.parent) {\n    command.commandId = parameters.parent.commandId;\n    command.username = parameters.parent.username;\n  } else {\n    command.commandId = createCommandId();\n    command.username = getUsername(parameters.user);\n  }\n\n  command.timestamp = createTimestamp();\n  return command;\n}\n\nfunction addMetadata(command) {\n  // Why must we override these if they are already set?\n  let overrides = {\n    commandId: createCommandId(),\n    username: getUsername(command.user),\n    timestamp: createTimestamp()\n  };\n\n  let result = Object.assign({}, command, overrides);\n  delete result.user;\n  return result;\n}\n\nmodule.exports = {\n  createFromParameters,\n  addMetadata\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/commands/utils/metadata.js\n// module id = 73\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet assert = require('assert');\nlet sender = require('../../sender');\nlet Image = require('../Image.class');\nlet ImageNotFoundError = require('../../errors/ImageNotFoundError.class');\nlet ScanCrossAccountImages = require('../../../queryHandlers/ScanCrossAccountImages');\n\nmodule.exports = {\n\n  get(imageIdNameOrType, includeUnstable) {\n    assert(imageIdNameOrType, 'Expected \"imageIdNameOrType\" argument not to be null');\n    if (imageIdNameOrType.toLowerCase().startsWith('ami')) {\n      return getImage({ id: imageIdNameOrType });\n    }\n\n    if (doesSpecifyVersion(imageIdNameOrType)) {\n      return getImage({ name: imageIdNameOrType });\n    }\n\n    let safeIncludeUnstable = includeUnstable === undefined ? false : includeUnstable;\n    return getLatestImageByType(imageIdNameOrType, safeIncludeUnstable);\n  }\n};\n\nfunction doesSpecifyVersion(imageIdNameOrType) {\n  return imageIdNameOrType.match(/\\-(\\d+\\.){2}\\d+$/);\n}\n\nfunction getImage(params) {\n  let filter = {};\n\n  if (params.id) filter['image-id'] = params.id;\n  if (params.name) filter.name = params.name;\n\n  let query = { name: 'ScanCrossAccountImages', filter };\n\n  return sender\n    .sendQuery(ScanCrossAccountImages, { query })\n    .then(amiImages =>\n      (amiImages.length ?\n        Promise.resolve(new Image(amiImages[0])) :\n        Promise.reject(new ImageNotFoundError(`No AMI image \"${params.id || params.name}\" found.`))\n      )\n    );\n}\n\nfunction getLatestImageByType(imageType, includeUnstable) {\n  let query = {\n    name: 'ScanCrossAccountImages'\n  };\n\n  return sender\n    .sendQuery(ScanCrossAccountImages, { query })\n    .then((amiImages) => {\n      let isLatest = includeUnstable ? image => image.IsLatest : image => image.IsLatestStable;\n      let latestImage = amiImages.find(image => image.AmiType === imageType && isLatest(image));\n\n      if (latestImage) {\n        return new Image(latestImage);\n      }\n\n      throw new ImageNotFoundError(`No AMI image of type \"${imageType}\" found.`);\n    });\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/provisioning/launchConfiguration/imageProvider.js\n// module id = 74\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet util = require('util');\nlet BaseError = require('./BaseError.class');\n\nmodule.exports = function AutoScalingGroupNotFoundError(message, innerError) {\n  this.name = this.constructor.name;\n  this.message = message;\n  this.innerError = innerError;\n\n  Error.captureStackTrace(this, this.constructor);\n};\n\nutil.inherits(module.exports, BaseError);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/errors/AutoScalingGroupNotFoundError.class.js\n// module id = 75\n// module chunks = 0","module.exports = require(\"moment\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"moment\"\n// module id = 76\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet util = require('util');\nlet BaseError = require('./BaseError.class');\n\nmodule.exports = function HttpRequestError(message, innerError) {\n  this.name = this.constructor.name;\n  this.message = message;\n  this.innerError = innerError;\n\n  Error.captureStackTrace(this, this.constructor);\n};\n\nutil.inherits(module.exports, BaseError);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/errors/HttpRequestError.class.js\n// module id = 77\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet _ = require('lodash');\n\nlet TaggableMixin = Base => class extends Base {\n  getTag(key, defaultValue) {\n    let tag = _.find(this.Tags, { Key: key });\n    if (tag === undefined) {\n      if (arguments.length <= 1) {\n        throw new Error(`Can't find tag \"${key}\"`);\n      } else {\n        return defaultValue;\n      }\n    }\n    return tag.Value;\n  }\n\n  setTag(key, value) {\n    let tag = this.getTag(key);\n    if (tag === undefined) {\n      tag = {\n        Key: key,\n        Value: value\n      };\n      this.Tags.push(tag);\n    } else {\n      tag.Value = value;\n    }\n  }\n};\n\nmodule.exports = TaggableMixin;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/models/TaggableMixin.js\n// module id = 78\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet co = require('co');\nlet serviceTargets = require('../../modules/service-targets');\nlet schema = require('../../modules/schema/schema');\n\nmodule.exports = function GetTargetState(query) {\n  return co(function* () {\n    yield schema('GetTargetStateQuery').then(x => x.assert(query));\n\n    let key = query.key;\n    let recurse = query.recurse;\n\n    return yield serviceTargets.getTargetState(query.environment, { key, recurse });\n  });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/queryHandlers/services/GetTargetState.js\n// module id = 79\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet awsAccounts = require('../awsAccounts');\nlet applyFuncToAccounts = require('./applyFuncToAccounts');\n\nfunction scanCrossAccountFn(fn) {\n  return awsAccounts.all()\n    .then(accounts => applyFuncToAccounts(fn, accounts));\n}\n\nmodule.exports = scanCrossAccountFn;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/queryHandlersUtil/scanCrossAccountFn.js\n// module id = 80\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\n// Note: considering simply operating on AWS data rather than mapping our structures\nlet _ = require('lodash');\n\nconst OS_DEVICE_NAME = '/dev/sda1';\nconst DATA_DEVICE_NAME = '/dev/sda2';\n\nconst DEFAULT_VOLUME = {\n  Type: 'SSD',\n  Size: 50\n};\n\nmodule.exports = {\n  toAWS(volumes) {\n    let awsVolumes = [];\n\n    let osVolume = _.find(volumes, { Name: 'OS' }) || DEFAULT_VOLUME;\n    let osDevice = getDeviceByVolume(osVolume, OS_DEVICE_NAME);\n    awsVolumes.push(osDevice);\n\n    let dataVolume = _.find(volumes, { Name: 'Data' }) || DEFAULT_VOLUME;\n    if (dataVolume.Size !== 0) {\n      let dataDevice = getDeviceByVolume(dataVolume, DATA_DEVICE_NAME, true);\n      awsVolumes.push(dataDevice);\n    }\n\n    return awsVolumes;\n  },\n  // reverse function\n  fromAWS(awsVolumes) {\n    return awsVolumes.filter(vol =>\n      _.includes([OS_DEVICE_NAME, DATA_DEVICE_NAME], vol.DeviceName)\n    ).map((awsVolume) => {\n      let volume = {};\n      volume.Name = awsVolume.DeviceName === OS_DEVICE_NAME ? 'OS' : 'Data';\n      volume.Size = awsVolume.Ebs.VolumeSize;\n      volume.Type = awsVolume.Ebs.VolumeType === 'gp2' ? 'SSD' : 'Disk';\n      return volume;\n    }).sort((vol1, vol2) => (\n      // sda1 before sda2 etc.\n      vol1.Name < vol2.Name\n    ));\n  }\n};\n\nfunction getDeviceByVolume(dataVolume, name, encrypted) {\n  return {\n    DeviceName: name,\n    Ebs: {\n      DeleteOnTermination: true,\n      VolumeSize: dataVolume.Size,\n      VolumeType: dataVolume.Type.toLowerCase() === 'ssd' ? 'gp2' : 'standard',\n      Encrypted: encrypted\n    }\n  };\n}\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/provisioning/launchConfiguration/instanceDevicesProvider.js\n// module id = 81\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet co = require('co');\nlet _ = require('lodash');\nconst asgResourceFactory = require('../../modules/resourceFactories/asgResourceFactory');\nlet InvalidOperationError = require('../../modules/errors/InvalidOperationError.class');\n\nfunction* handler(command) {\n  // Validation\n  let min = command.autoScalingGroupMinSize;\n  let desired = command.autoScalingGroupDesiredSize;\n  let max = command.autoScalingGroupMaxSize;\n\n  if (!_.isNil(min)) {\n    if (!_.isNil(max) && min > max) {\n      throw new InvalidOperationError(\n        `Provided Max size '${max}' must be greater than or equal to the Min size '${min}'.`\n      );\n    }\n\n    if (!_.isNil(desired) && desired < min) {\n      throw new InvalidOperationError(\n        `Provided Desired size '${desired}' must be greater than or equal to the Min size '${min}'.`\n      );\n    }\n  }\n\n  if (!_.isNil(max)) {\n    if (!_.isNil(min) && min > max) {\n      throw new InvalidOperationError(\n        `Provided Min size '${min}' must be less than or equal to the Max size '${max}'.`\n      );\n    }\n\n    if (!_.isNil(desired) && desired > max) {\n      throw new InvalidOperationError(\n        `Provided Desired size '${desired}' must be less than or equal to the Max size '${max}'.`\n      );\n    }\n  }\n\n  // Get a resource instance to work with AutoScalingGroup in the proper\n  // AWS account.\n  let parameters = { accountName: command.accountName };\n  let resource = yield asgResourceFactory.create(undefined, parameters);\n\n  // Change the AutoScalingGroup size accordingly to the expected one.\n  parameters = {\n    name: command.autoScalingGroupName,\n    minSize: command.autoScalingGroupMinSize,\n    desiredSize: command.autoScalingGroupDesiredSize,\n    maxSize: command.autoScalingGroupMaxSize\n  };\n\n  return resource.put(parameters);\n}\n\nmodule.exports = co.wrap(handler);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/commands/asg/SetAutoScalingGroupSize.js\n// module id = 82\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet amazonClientFactory = require('../amazon-client/childAccountClient');\nlet Instance = require('../../models/Instance');\nlet InstanceResourceBase = require('./InstanceResourceBase');\n\nfunction instanceResource(client) {\n  const instanceResourceBase = new InstanceResourceBase(client);\n  const self = Object.create(instanceResourceBase);\n  self.all = function all(parameters) {\n    return instanceResourceBase.all(parameters).then(xs => xs.map(x => new Instance(x)));\n  };\n  return self;\n}\n\nmodule.exports = {\n  canCreate: resourceDescriptor =>\n    resourceDescriptor.type.toLowerCase() === 'ec2/instance',\n\n  create: (_, { accountName } = {}) => amazonClientFactory.createEC2Client(accountName).then(instanceResource)\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/resourceFactories/ec2InstanceResourceFactory.js\n// module id = 83\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet BaseError = require('./BaseError.class');\n\nmodule.exports = class DeploymentValidationError extends BaseError {\n\n  constructor(message, innerError) {\n    super();\n    this.name = this.constructor.name;\n    this.message = message;\n    this.innerError = innerError;\n\n    Error.captureStackTrace(this, this.constructor);\n  }\n\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/errors/DeploymentValidationError.class.js\n// module id = 84\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet serviceTargets = require('../../modules/service-targets');\nlet _ = require('lodash');\nlet { createServerRoleFilter } = require('../../modules/environment-state/serverRoleFilters');\n\nfunction toRoleGroups(results) {\n  let hash = _.groupBy(results, getRole);\n  return Object.keys(hash).map(key => (\n    {\n      Role: key,\n      Services: _.map(hash[key], 'value')\n    }\n  ));\n}\n\nfunction getRole(service) {\n  let r = /roles\\/(.*?)\\//;\n  let matches = r.exec(service.key);\n  return matches[1];\n}\n\nfunction GetServerRoles({ environmentName, serviceName, slice, serverRole }) {\n  let recurse = true;\n  let key = `environments/${environmentName.toLowerCase()}/roles`;\n  return serviceTargets.getTargetState(environmentName, { key, recurse })\n    .then(results => ({\n      EnvironmentName: environmentName,\n      Value: toRoleGroups(results).filter(createServerRoleFilter({ serviceName, slice, serverRole }))\n    }));\n}\n\nmodule.exports = GetServerRoles;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/queryHandlers/services/GetServerRoles.js\n// module id = 85\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nmodule.exports = {\n  SUCCESS: 'Success',\n  FAIL: 'Failed'\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/health-checks/resultCodes.js\n// module id = 86\n// module chunks = 0","module.exports = require(\"newrelic\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"newrelic\"\n// module id = 87\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet deepFreeze = require('deep-freeze-strict');\n\nfunction isPromise(obj) {\n  return obj && obj.then && typeof obj.then === 'function';\n}\n\nfunction deepFreezeIfObj(obj) {\n  let t = typeof obj;\n  return ((t === 'object' || t === 'function') && t !== null)\n    ? deepFreeze(obj)\n    : obj;\n}\n\nfunction memoize(fn) {\n  if (typeof fn !== 'function') {\n    throw new Error('Can only memoize a function');\n  }\n\n  let memo = new Map();\n  return (...args) => {\n    let key = JSON.stringify(args);\n    if (!memo.has(key)) {\n      let result = fn(...args);\n      if (isPromise(result)) {\n        memo.set(key, result.then(deepFreezeIfObj));\n      } else {\n        memo.set(key, deepFreezeIfObj(result));\n      }\n    }\n    return memo.get(key);\n  };\n}\n\nmodule.exports = memoize;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/memoize.js\n// module id = 88\n// module chunks = 0","/**\n * Attach the duct-tape that keeps the wings on ;-)\n */\n\n'use strict';\n\n/**\n * Return a deep copy of item with only properties for which\n * filter returns true.\n * @param {function} filter\n * @param {*} item\n */\nfunction recursivelyRemoveProperties(filter, item) {\n  function loop(i) {\n    if (typeof i !== 'object' || i === null) {\n      return i;\n    } else if (Array.isArray(i)) {\n      return i.filter(filter.bind(null, null)).map(loop);\n    } else if (i instanceof Date) {\n      let t = new Date();\n      t.setTime(i.getTime());\n      return t;\n    } else {\n      return Object.keys(i).reduce((acc, key) => {\n        let value = i[key];\n        if (filter(key, value)) {\n          acc[key] = loop(i[key]);\n        }\n        return acc;\n      }, {});\n    }\n  }\n  return loop(item);\n}\n\n/**\n * DynamoDB cannot store the empty string or undefined as property values\n * @param {string} name\n * @param {*} value\n */\nfunction dynamoCanStoreProperty(name, value) {\n  return value !== undefined && value !== '';\n}\n\nmodule.exports = {\n  makeWritable: recursivelyRemoveProperties.bind(null, dynamoCanStoreProperty)\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/data-access/dynamoItemFilter.js\n// module id = 89\n// module chunks = 0","module.exports = require(\"ioredis\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"ioredis\"\n// module id = 90\n// module chunks = 0","module.exports = require(\"timers\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"timers\"\n// module id = 91\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet crypto = require('crypto');\n\nconst CIPHER_ALGORITHM = 'aes-256-gcm';\nconst CONTENT_LENGTH_BYTES = 32 / 8;\nconst HASH_ALGORITHM = 'sha256';\nconst ITERATIONS = 1000;\nconst KEY_LENGTH = 32;\n\nfunction bufOfInt(i) {\n  let buf = new Buffer(CONTENT_LENGTH_BYTES);\n  buf.writeUInt32LE(i);\n  return buf;\n}\n\nfunction pack(buffers) {\n  let sizeThenContent = buf => [bufOfInt(buf.length), buf];\n  return Buffer.concat(buffers.map(sizeThenContent).reduce((acc, nxt) => acc.concat(nxt), []));\n}\n\nfunction unpack(buffer) {\n  let offset = 0;\n  let output = [];\n  while (offset < buffer.length) {\n    let contentLength = buffer.readUInt32LE(offset);\n    let contentStart = offset + CONTENT_LENGTH_BYTES;\n    output.push(buffer.slice(contentStart, contentStart + contentLength));\n    offset = offset + CONTENT_LENGTH_BYTES + contentLength;\n  }\n  return output;\n}\n\nfunction encrypt(key, plaintext) {\n  if (!plaintext) {\n    throw new Error(`plaintext must be a buffer: got ${plaintext}`);\n  }\n\n  let iv = crypto.randomBytes(12);\n  let salt = crypto.randomBytes(16);\n  let sessionKey = crypto.pbkdf2Sync(key, salt, ITERATIONS, KEY_LENGTH, HASH_ALGORITHM);\n  let cipher = crypto.createCipheriv(CIPHER_ALGORITHM, sessionKey, iv);\n  let encrypted = Buffer.concat([cipher.update(plaintext), cipher.final()]);\n  let tag = cipher.getAuthTag();\n  return pack([\n    new Buffer(CIPHER_ALGORITHM, 'utf8'),\n    new Buffer(HASH_ALGORITHM, 'utf8'),\n    iv,\n    salt,\n    bufOfInt(ITERATIONS),\n    bufOfInt(KEY_LENGTH),\n    tag,\n    encrypted]);\n}\n\nfunction decrypt(key, ciphertext) {\n  if (!ciphertext) {\n    throw new Error(`ciphertext must be a buffer: got ${ciphertext}`);\n  }\n\n  let parts = unpack(ciphertext);\n  let cipherAlgorithm = parts[0].toString('utf8');\n  let hashAlgorithm = parts[1].toString('utf8');\n  let iv = parts[2];\n  let salt = parts[3];\n  let iterations = parts[4].readUInt32LE();\n  let keyLength = parts[5].readUInt32LE();\n  let tag = parts[6];\n  let content = parts[7];\n  let sessionKey = crypto.pbkdf2Sync(key, salt, iterations, keyLength, hashAlgorithm);\n  let cipher = crypto.createDecipheriv(cipherAlgorithm, sessionKey, iv);\n  cipher.setAuthTag(tag);\n  let decrypted = cipher.update(content) + cipher.final();\n  return decrypted;\n}\n\nmodule.exports = {\n  decrypt,\n  encrypt\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/emCrypto.js\n// module id = 92\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\n/**\n * Remove verbose stuff from stack traces\n */\n\nconst FILE_LOCATION_REGEXP = /\\((.*)(:[0-9]+:[0-9]+)\\)/;\nconst LINE_FILTER_REGEXP = /^\\s*at\\s+/i;\nconst NOT_MY_CODE_REGEXP = /(node_modules)|(\\([^\\\\\\/]+:[0-9]+:[0-9]+\\))|(\\(native\\))/;\n\nconst path = require('path');\nconst findInAncestor = require('./find-in-ancestor');\n\nlet isMyCode = line => !NOT_MY_CODE_REGEXP.test(line);\n\nlet enteredMyCode = (line, prev) => isMyCode(line) && !isMyCode(prev);\nlet exitedMyCode = (line, prev) => !isMyCode(line) && isMyCode(prev);\nlet inMyCode = (line, prev) => isMyCode(line) && isMyCode(prev);\nlet inOtherCode = (line, prev) => !isMyCode(line) && !isMyCode(prev);\n\nfunction create({ contextLines, filePathTransform }) {\n  function shorten(line) {\n    return line.replace(FILE_LOCATION_REGEXP, (match, fullPath, location) => {\n      let file = filePathTransform(fullPath);\n      return `(${file}${location})`;\n    }).replace();\n  }\n\n  function minimize(stack) {\n    let lines = stack.split('\\n')\n      .filter(line => LINE_FILTER_REGEXP.test(line))\n      .map(line => line.replace(LINE_FILTER_REGEXP, ''));\n    let linesSkippedMessage = (omittedCount) => {\n      let skipped = omittedCount - (2 * contextLines);\n      return skipped > 0 ? [`...(${skipped} line${skipped > 1 ? 's' : ''} skipped)...`] : [];\n    };\n    function loop({ context, omittedCount, output, prev }, line) {\n      if (enteredMyCode(line, prev)) {\n        let skipped = linesSkippedMessage(omittedCount);\n        return {\n          context: [],\n          omittedCount: 0,\n          output: output.concat(skipped, context.map(shorten), shorten(line)),\n          prev: line\n        };\n      } else if (exitedMyCode(line, prev)) {\n        return {\n          context: [],\n          omittedCount: 1,\n          output: contextLines ? output.concat(shorten(line)) : output,\n          prev: line\n        };\n      } else if (inMyCode(line, prev)) {\n        return {\n          context: [],\n          omittedCount: 0,\n          output: output.concat(shorten(line)),\n          prev: line\n        };\n      } else if (inOtherCode(line, prev)) {\n        return {\n          context: contextLines ? [line] : [],\n          omittedCount: omittedCount + 1,\n          output,\n          prev: line\n        };\n      } else {\n        throw new Error('This code path should be unreachable');\n      }\n    }\n    let { context, omittedCount, output } = lines.reduce(loop, {\n      context: [],\n      omittedCount: 0,\n      output: [],\n      prev: undefined\n    });\n    let skipped = linesSkippedMessage(omittedCount);\n    let rest = context.length > 0 ? skipped.concat(context.map(shorten)) : [];\n    return output.concat(rest).join('\\n');\n  }\n\n  return minimize;\n}\n\ncreate.build = () => {\n  let basePath = path.dirname(findInAncestor('package.json', __dirname));\n  let filePathTransform = fullPath => path.relative(basePath, fullPath);\n  return create({ contextLines: 0, filePathTransform });\n};\n\nmodule.exports = create;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/miniStack.js\n// module id = 93\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet util = require('util');\nlet BaseError = require('./BaseError.class');\n\nmodule.exports = function ActiveDirectoryError(message, innerError) {\n  this.name = this.constructor.name;\n  this.message = message;\n  this.innerError = innerError;\n\n  Error.captureStackTrace(this, this.constructor);\n};\n\nutil.inherits(module.exports, BaseError);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/errors/ActiveDirectoryError.class.js\n// module id = 94\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet EncryptedRedisStore = require('./data-access/encryptedRedisStore');\nconst USER_SESSION_STORE_INDEX = 1;\n\nlet sessionStore;\n\nfunction createSessionStore() {\n  sessionStore = EncryptedRedisStore.createStore(USER_SESSION_STORE_INDEX);\n  return sessionStore;\n}\n\nmodule.exports = {\n  get: () => { return sessionStore || createSessionStore(); }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/userSessionStore.js\n// module id = 95\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet config = require('../../config');\nconst mock = require('./sslComponentsRepository.mock.js');\nconst prod = require('./sslComponentsRepository.prod.js');\n\nlet implementation;\n\nif (config.get('IS_PRODUCTION')) {\n  implementation = prod;\n} else {\n  implementation = mock;\n}\n\nmodule.exports = implementation;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/sslComponentsRepository/index.js\n// module id = 96\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet assert = require('assert');\n\nfunction S3GetObjectRequest(client, parameters) {\n  assert(client, 'Invalid argument \\'client\\'.');\n  assert(parameters, 'Invalid argument \\'parameters\\'.');\n  assert(parameters.bucketName, 'Invalid argument \\'parameters.bucketName\\'.');\n  assert(parameters.objectPath, 'Invalid argument \\'parameters.objectPath\\'.');\n\n  let self = this;\n\n  self.execute = function (callback) {\n    let request = {\n      Bucket: parameters.bucketName,\n      Key: parameters.objectPath\n    };\n\n    let promise = client.getObject(request)\n      .promise().then(data => data, (error) => {\n        let message = `An error has occurred retrieving '${request.Key}' file from '${request.Bucket}' S3 bucket: ${error.message}`;\n        throw new Error(message);\n      });\n\n    if (callback !== undefined) {\n      promise.then(result => callback(null, result), error => callback(error));\n      return undefined;\n    } else {\n      return promise;\n    }\n  };\n}\n\nmodule.exports = S3GetObjectRequest;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/S3GetObjectRequest.js\n// module id = 97\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet userService = require('../user-service');\nlet cookieAuthenticationConfiguration = require('./cookieAuthenticationConfiguration');\n\nmodule.exports = {\n  middleware(req, res, next) {\n    if (req.user) return next();\n\n    let cookie = req.cookies[cookieAuthenticationConfiguration.getCookieName()];\n    if (!cookie) return next();\n\n    return userService.getUserByToken(cookie)\n      .then((user) => {\n        req.user = user;\n        req.authenticatedBy = 'cookie';\n        next();\n      }, () => next());\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/authentications/cookieAuthentication.js\n// module id = 98\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet co = require('co');\nlet ms = require('ms');\nlet _ = require('lodash');\n\nlet DEFAULT_SERVICE_INSTALLATION_TIMEOUT = '30m';\n\nlet Enums = require('../../Enums');\nlet BaseError = require('../errors/BaseError.class');\nlet deployments = require('../data-access/deployments');\nlet sender = require('../sender');\nlet infrastructureConfigurationProvider = require('../provisioning/infrastructureConfigurationProvider');\nlet namingConventionProvider = require('../provisioning/namingConventionProvider');\nlet logger = require('../logger');\nlet Environment = require('../../models/Environment');\nlet GetAutoScalingGroup = require('../../queryHandlers/GetAutoScalingGroup');\nlet GetTargetState = require('../../queryHandlers/services/GetTargetState');\n\nmodule.exports = {\n\n  all() {\n    return co(function* () {\n      let activeDeployments = yield getActiveDeploymentsFromHistoryTable();\n      logger.debug(`DeploymentMonitor: ${activeDeployments.length} deployments found to monitor.`);\n\n      return activeDeployments;\n    }).catch((error) => {\n      let message = (error instanceof BaseError) ? error.toString(true) : error.stack;\n      logger.error(`DeploymentMonitor: An error has occurred getting active deployments: ${message}`);\n\n      return Promise.reject(error);\n    });\n  },\n\n  getActiveDeploymentsFullStatus(activeDeployments) {\n    return Promise.all(activeDeployments.map(\n      activeDeployment => getActiveDeploymentFullStatus(activeDeployment)\n    ));\n  }\n\n};\n\nfunction getActiveDeploymentsFromHistoryTable() {\n  let FilterExpression = ['and',\n    ['=', ['at', 'Value', 'SchemaVersion'], ['val', 2]],\n    ['=', ['at', 'Value', 'Status'], ['val', 'In Progress']]\n  ];\n  return deployments.scanRunning({ FilterExpression });\n}\n\nfunction getActiveDeploymentFullStatus(activeDeployment) {\n  let deploymentId = activeDeployment.DeploymentID;\n  let environmentName = activeDeployment.Value.EnvironmentName;\n  let serviceName = activeDeployment.Value.ServiceName;\n  let serviceVersion = activeDeployment.Value.ServiceVersion;\n  let accountName = activeDeployment.AccountName;\n\n  return co(function* () {\n    let data = yield {\n      nodesId: getExpectedNodesIdByDeployment(activeDeployment),\n      serviceInstallation: getTargetState(\n        `environments/${environmentName}/services/${serviceName}/${serviceVersion}/installation`,\n        environmentName,\n        true\n      ),\n      nodesDeployment: getTargetState(\n        `deployments/${deploymentId}/nodes/`,\n        environmentName,\n        true\n      )\n    };\n\n    let nodesDeployment = getNodesDeployment(data.nodesId, data.nodesDeployment);\n    let installationTimeout = data.serviceInstallation.length ? data.serviceInstallation[0].value.InstallationTimeout : DEFAULT_SERVICE_INSTALLATION_TIMEOUT;\n\n    let activeDeploymentFullStatus = {\n      deploymentId,\n      environmentName,\n      accountName,\n      installationTimeout: ms(`${installationTimeout}m`),\n      startTime: new Date(activeDeployment.Value.StartTimestamp),\n      nodesDeployment\n    };\n\n    logger.debug(`DeploymentMonitor: Deployment '${deploymentId}' is going to affect following nodes ${JSON.stringify(nodesDeployment)}`);\n\n    return activeDeploymentFullStatus;\n  }).catch((error) => {\n    let errorString = `An error has occurred getting deployment '${deploymentId}' status: ${error.toString(true)}`;\n    logger.error(errorString);\n\n    return Promise.resolve({\n      deploymentId,\n      error: errorString,\n      environmentName,\n      accountName\n    });\n  });\n}\n\nfunction getNodesDeployment(nodesId, nodesDeployment) {\n  let mapping = nodesId.map((nodeId) => {\n    let nodeDeployment = nodesDeployment\n      .filter(x => x.key.indexOf(`/nodes/${nodeId}`) >= 0)\n      .map(x => x.value)[0];\n\n    let result = {\n      InstanceId: nodeId,\n      Status: Enums.NodeDeploymentStatus.NotStarted\n    };\n\n    if (!nodeDeployment) return result;\n\n    for (let propertyName in nodeDeployment) {\n      if ({}.hasOwnProperty.call(nodeDeployment, propertyName)) {\n        let property = nodeDeployment[propertyName];\n        if (!property) continue; // eslint-disable-line no-continue\n        result[propertyName] = property;\n      }\n    }\n\n    return result;\n  });\n\n  return mapping;\n}\n\nfunction getExpectedNodesIdByDeployment(deployment) {\n  return co(function* () {\n    let serverRoleName;\n    if (deployment.Value.ServerRoleName === undefined) {\n      let environment = yield Environment.getByName(deployment.Value.EnvironmentName);\n      let deploymentMap = yield environment.getDeploymentMap();\n      let serverRoles = _.map(yield deploymentMap.getServerRolesByServiceName(deployment.Value.ServiceName), 'ServerRoleName');\n      serverRoleName = serverRoles[0];\n      logger.info(`DeploymentMonitor: Picked deployment from old monitor: ${serverRoleName}`);\n    } else {\n      serverRoleName = deployment.Value.ServerRoleName;\n    }\n\n    let configuration = yield infrastructureConfigurationProvider.get(\n      deployment.Value.EnvironmentName, deployment.Value.ServiceName, serverRoleName\n    );\n\n    let autoScalingGroupName = namingConventionProvider.getAutoScalingGroupName(\n      configuration, deployment.Value.ServiceSlice\n    );\n\n    let query = {\n      name: 'GetAutoScalingGroup',\n      accountName: deployment.AccountName,\n      autoScalingGroupName\n    };\n\n    try {\n      let autoScalingGroup = yield sender.sendQuery(GetAutoScalingGroup, { query });\n      let nodeIds = autoScalingGroup.Instances\n        .filter(instance => instance.LifecycleState === 'InService')\n        .map(instance => instance.InstanceId);\n      return nodeIds;\n    } catch (err) {\n      logger.error('Couldn\\'t find AutoScalingGroup - it\\'s not in cached array?');\n      logger.error(err);\n      return [];\n    }\n  });\n}\n\nfunction getTargetState(key, environmentName, recurse) {\n  let query = {\n    name: 'GetTargetState',\n    environment: environmentName,\n    key,\n    recurse\n  };\n\n  return sender.sendQuery(GetTargetState, { query });\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/monitoring/activeDeploymentsStatusProvider.js\n// module id = 99\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nconst LOGICAL_TABLE_NAME = 'InfraConfigAccounts';\nconst TTL = 600; // seconds\n\nlet physicalTableName = require('../awsResourceNameProvider').getTableName;\nlet cachedSingleAccountDynamoTable = require('./cachedSingleAccountDynamoTable');\n\nmodule.exports = cachedSingleAccountDynamoTable(physicalTableName(LOGICAL_TABLE_NAME), { ttl: TTL });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/data-access/accounts.js\n// module id = 100\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet Promise = require('bluebird');\n\nfunction applyFuncToAccounts(fn, accounts) {\n  function applyFnAndAssignAccountName({ AccountName, AccountNumber }) {\n    return Promise.resolve({ AccountName, AccountNumber })\n      .then(fn)\n      .then((result = []) => result.map(item => (item !== null && typeof item === 'object'\n        ? Object.assign(item, { AccountName })\n        : item)));\n  }\n  return Promise.map(accounts, applyFnAndAssignAccountName)\n    .then(results => [].concat(...results));\n}\n\nmodule.exports = applyFuncToAccounts;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/queryHandlersUtil/applyFuncToAccounts.js\n// module id = 101\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet _ = require('lodash/fp');\nlet { ChronoUnit, Clock, Instant } = require('js-joda');\nlet semver = require('semver');\n\nlet clock = Clock.systemUTC();\n\nmodule.exports = {\n  isCompatibleImage,\n  isStable,\n  getAmiType,\n  getAmiVersion,\n  getRootDevice,\n  summaryOf,\n  compare,\n  rank,\n  getStableDate\n};\n\nfunction isCompatibleImage(amiName) {\n  // whatever-name-0.0.0\n  return /^[a-zA-Z0-9.-]+-[0-9]+\\.[0-9]+\\.[0-9]+$/.test(amiName);\n}\n\nfunction daysBetween(selected, now) {\n  try {\n    return getStableDate(selected).until(now, ChronoUnit.DAYS);\n  } catch (error) {\n    return 0;\n  }\n}\n\nfunction getAmiType(name) {\n  let amiType = name;\n  if (name && isCompatibleImage(name)) {\n    let pos = name.lastIndexOf('-');\n    if (pos) amiType = name.substr(0, pos);\n  }\n\n  return amiType;\n}\n\nfunction getAmiVersion(name) {\n  let amiVersion = '';\n  if (name && isCompatibleImage(name)) {\n    let pos = name.lastIndexOf('-');\n    if (pos) amiVersion = name.substr(pos + 1);\n  }\n\n  return amiVersion;\n}\n\nfunction getRootDevice(ec2image) {\n  if (!ec2image.RootDeviceName) return null;\n  if (!ec2image.BlockDeviceMappings) return null;\n\n  let rootDevice = ec2image.BlockDeviceMappings.find(mapping =>\n    mapping.DeviceName === ec2image.RootDeviceName\n  );\n\n  return rootDevice;\n}\n\nfunction summaryOf(ec2Image) {\n  let name = ec2Image.Name;\n  let rootDevice = getRootDevice(ec2Image);\n  let tags = _.flow([_.map(tag => [tag.Key, tag.Value]), _.fromPairs])(ec2Image.Tags);\n  let summary = {\n    ImageId: ec2Image.ImageId,\n    CreationDate: ec2Image.CreationDate,\n    Platform: ec2Image.Platform ? 'Windows' : 'Linux',\n    Name: name,\n    Description: ec2Image.Description || '',\n    AmiType: getAmiType(name),\n    AmiVersion: getAmiVersion(name),\n    IsCompatibleImage: isCompatibleImage(name),\n    IsStable: isStable(ec2Image),\n    Encrypted: _.get('Ebs.Encrypted')(rootDevice),\n    RootVolumeSize: _.get('Ebs.VolumeSize')(rootDevice)\n  };\n\n  return Object.assign(tags, summary);\n}\n\nfunction compare(summaryImageX, summaryImageY) {\n  if (summaryImageX && summaryImageY) {\n    let x = comparable(summaryImageX);\n    let y = comparable(summaryImageY);\n    return (2 * Math.sign(x.amiType.localeCompare(y.amiType))) + Math.sign(semver.rcompare(x.amiVersion, y.amiVersion));\n  } else if (summaryImageX) {\n    return 1;\n  } else if (summaryImageY) {\n    return -1;\n  } else {\n    return 0;\n  }\n}\n\nfunction rank(summaries) {\n  let prev = { AmiType: null };\n  let prevStable = { AmiType: null };\n  let latestStable = { AmiType: null };\n  let i = 0;\n  for (let summary of summaries) {\n    let isLatest = (summary.AmiType !== prev.AmiType);\n    let isLatestStable = (summary.AmiType !== prevStable.AmiType && summary.IsStable);\n    i = isLatest ? 1 : 1 + i;\n    summary.Rank = i;\n    summary.IsLatest = isLatest;\n    summary.IsLatestStable = isLatestStable;\n    summary.DaysBehindLatest = (summary.AmiType === latestStable.AmiType) ? daysBetween(prevStable, clock.instant()) : 0;\n    prev = summary;\n    if (summary.IsStable) {\n      prevStable = summary;\n    }\n    if (isLatestStable) {\n      latestStable = summary;\n    }\n  }\n\n  return summaries;\n}\n\nfunction comparable(summary) {\n  return {\n    amiType: summary.AmiType || '',\n    amiVersion: semver.valid(summary.AmiVersion) || '0.0.0'\n  };\n}\n\nfunction isStable(ec2Image) {\n  let hasStableTag = ec2Image.Tags && ec2Image.Tags.some(t => t.Key.toLowerCase() === 'stable' && t.Value !== '');\n  let hasStableInDescription = ec2Image.Description && ec2Image.Description.toLowerCase() === 'stable';\n  return !!((hasStableTag || hasStableInDescription));\n}\n\nfunction getStableTagValue(ec2image) {\n  if (!ec2image.Tags) {\n    return null;\n  }\n\n  let stableTag = ec2image.Tags.find(t => t.Key.toLowerCase() === 'stable');\n  if (!stableTag) {\n    return null;\n  }\n\n  try {\n    return Instant.parse(stableTag.Value);\n  } catch (e) {\n    if (e.name === 'DateTimeParseException') {\n      return null;\n    }\n    throw e;\n  }\n}\n\nfunction getStableDate(ec2image) {\n  let stableTagValue = getStableTagValue(ec2image);\n  if (!stableTagValue) {\n    return Instant.parse(ec2image.CreationDate);\n  }\n\n  return stableTagValue;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/machineImage/imageSummary.js\n// module id = 102\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet _ = require('lodash');\nlet amazonClientFactory = require('../amazon-client/childAccountClient');\nlet awsAccounts = require('../awsAccounts');\nlet cacheManager = require('../cacheManager');\nlet fp = require('lodash/fp');\n\nconst USE_CACHE = true;\n\nfunction getImagesVisibleToAccount(accountId, filter) {\n  function getImagesOwners() {\n    return awsAccounts.getAMIsharingAccounts()\n      .then(accounts => _.uniq(accounts.concat(accountId))\n        .map(acc => _.padStart(acc, 12, '0')));\n  }\n\n  function buildRequest(query) {\n    let Filters = [];\n    if (query) {\n      // {a:1, b:2} => [{Name:'a', Values:[1]}, {Name:'b', Values:[2]}]\n      Filters = _.toPairs(query).map(q => ({ Name: q[0], Values: _.concat(q[1]) }));\n    }\n\n    Filters.push({ Name: 'state', Values: ['available'] });\n    Filters.push({ Name: 'is-public', Values: ['false'] });\n    Filters.push({ Name: 'image-type', Values: ['machine'] });\n\n    return getImagesOwners().then(Owners => ({ Filters, Owners }));\n  }\n\n  let ec2ClientPromise = amazonClientFactory.createEC2Client(accountId);\n\n  return Promise.all([ec2ClientPromise, buildRequest(filter)])\n    .then(([client, request]) => client.describeImages(request).promise())\n    .then(data => data.Images);\n}\n\nconst imagesCache = cacheManager.create('ImagesCache', getImagesVisibleToAccount, { stdTTL: 30 * 60 });\n\nfunction ImageResource(account) {\n  let accountId = _.toString(account.AccountNumber);\n\n  function cachedGetAll(params) {\n    let hasFilter = fp.flow(fp.get('filter'), fp.toPairs, x => x.length > 0);\n\n    if (hasFilter(params) || !USE_CACHE) {\n      return getImagesVisibleToAccount(accountId, params.filter);\n    } else {\n      return imagesCache.get(accountId);\n    }\n  }\n\n  this.all = cachedGetAll;\n}\n\nfunction create(resourceDescriptor, parameters) {\n  return awsAccounts.getByName(parameters.accountName)\n  .then(account => new ImageResource(account));\n}\n\nfunction canCreate(resourceDescriptor) {\n  return resourceDescriptor.type.toLowerCase() === 'ec2/image';\n}\n\nmodule.exports = {\n  canCreate,\n  create\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/resourceFactories/ec2ImageResourceFactory.js\n// module id = 103\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nconst LOGICAL_TABLE_NAME = 'ConfigDeploymentMaps';\nconst TTL = 600; // seconds\n\nlet physicalTableName = require('../awsResourceNameProvider').getTableName;\nlet cachedSingleAccountDynamoTable = require('./cachedSingleAccountDynamoTable');\n\nmodule.exports = cachedSingleAccountDynamoTable(physicalTableName(LOGICAL_TABLE_NAME), { ttl: TTL });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/data-access/deploymentMaps.js\n// module id = 104\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nconst LOGICAL_TABLE_NAME = 'InfraConfigClusters';\nconst TTL = 3600; // seconds\n\nlet physicalTableName = require('../awsResourceNameProvider').getTableName;\nlet cachedSingleAccountDynamoTable = require('./cachedSingleAccountDynamoTable');\n\nmodule.exports = cachedSingleAccountDynamoTable(physicalTableName(LOGICAL_TABLE_NAME), { ttl: TTL });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/data-access/clusters.js\n// module id = 105\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet _ = require('lodash');\nlet co = require('co');\nlet amazonClientFactory = require('../amazon-client/childAccountClient');\nlet AwsError = require('../errors/AwsError.class');\nlet AutoScalingGroupNotFoundError = require('../errors/AutoScalingGroupNotFoundError.class');\nlet AutoScalingGroupAlreadyExistsError = require('../errors/AutoScalingGroupAlreadyExistsError.class');\nlet cacheManager = require('../cacheManager');\nlet fp = require('lodash/fp');\nlet logger = require('../logger');\nlet pages = require('../amazon-client/pages');\n\nfunction getAllAsgsInAccount(accountId, names) {\n  logger.debug(`Describing all ASGs in account \"${accountId}\"...`);\n  let request = (names && names.length) ? { AutoScalingGroupNames: names } : {};\n  let asgDescriptions = amazonClientFactory.createASGClient(accountId)\n    .then(client => pages.flatten(page => page.AutoScalingGroups, client.describeAutoScalingGroups(request)));\n  return asgDescriptions;\n}\n\nlet asgCache = cacheManager.create('Auto Scaling Groups', getAllAsgsInAccount, { stdTTL: 60 });\n\nfunction AsgResourceBase(accountId) {\n  let asgClient = () => amazonClientFactory.createASGClient(accountId);\n\n  function standardifyError(error, autoScalingGroupName) {\n    if (!error) return null;\n    let awsError = new AwsError(error.message);\n    if (error.message.indexOf('AutoScalingGroup name not found') >= 0) {\n      return new AutoScalingGroupNotFoundError(`AutoScalingGroup \"${autoScalingGroupName}\" not found.`, awsError);\n    }\n\n    if (error.code === 'AlreadyExists') {\n      let message = `AutoScalingGroup \"${autoScalingGroupName}\" already exists.`;\n      return new AutoScalingGroupAlreadyExistsError(message, awsError);\n    }\n\n    return awsError;\n  }\n\n  function describeAutoScalingGroups(names) {\n    let predicate = (() => {\n      if (names && names.length) {\n        let nameSet = new Set(names);\n        return asg => nameSet.has(asg.AutoScalingGroupName);\n      } else {\n        return () => true;\n      }\n    })();\n\n    return asgCache.get(accountId).then(fp.filter(predicate));\n  }\n\n  this.get = function (parameters) {\n    if (parameters.clearCache === true) {\n      asgCache.del(accountId);\n    }\n    return describeAutoScalingGroups([parameters.name]).then((result) => {\n      if (result.length > 0) return result[0];\n      throw new AutoScalingGroupNotFoundError(`AutoScalingGroup \"${parameters.name}\" not found.`);\n    }).catch((error) => {\n      throw new AwsError(error.message);\n    });\n  };\n\n  this.all = function (parameters) {\n    return describeAutoScalingGroups(parameters.names);\n  };\n\n  this.setTag = function (parameters) {\n    let request = {\n      Tags: [{\n        Key: parameters.tagKey,\n        PropagateAtLaunch: true,\n        ResourceId: parameters.name,\n        ResourceType: 'auto-scaling-group',\n        Value: parameters.tagValue\n      }]\n    };\n    return asgClient().then(client => client.createOrUpdateTags(request).promise()).catch((error) => {\n      throw standardifyError(error, parameters.name);\n    });\n  };\n\n  this.delete = function ({ name, force }) {\n    logger.warn(`Deleting Auto Scaling Group \"${name}\"`);\n    return asgClient().then(client => client.deleteAutoScalingGroup({ AutoScalingGroupName: name, ForceDelete: force }).promise());\n  };\n\n  function updateASG(client, parameters) {\n    let request = {\n      AutoScalingGroupName: parameters.name\n    };\n\n    if (!_.isNil(parameters.minSize)) {\n      request.MinSize = parameters.minSize;\n    }\n\n    if (!_.isNil(parameters.desiredSize)) {\n      request.DesiredCapacity = parameters.desiredSize;\n    }\n\n    if (!_.isNil(parameters.maxSize)) {\n      request.MaxSize = parameters.maxSize;\n    }\n\n    if (parameters.launchConfigurationName) {\n      request.LaunchConfigurationName = parameters.launchConfigurationName;\n    }\n\n    if (!_.isNil(parameters.subnets)) {\n      request.VPCZoneIdentifier = parameters.subnets.join(',');\n    }\n\n    return client.updateAutoScalingGroup(request).promise();\n  }\n\n  function updateLCHs(client, parameters) {\n    let request = {\n      AutoScalingGroupName: parameters.name,\n      LifecycleHookName: '10min-draining'\n    };\n\n    if (_.isNil(parameters.scaling)) return Promise.resolve();\n\n    if (!parameters.scaling.terminationDelay) {\n      return client.deleteLifecycleHook(request).promise().catch(() => {});\n    }\n\n    Object.assign(request, {\n      HeartbeatTimeout: parameters.scaling.terminationDelay * 60,\n      LifecycleTransition: 'autoscaling:EC2_INSTANCE_TERMINATING',\n      DefaultResult: 'CONTINUE'\n    });\n\n    return client.putLifecycleHook(request).promise();\n  }\n\n  this.put = (parameters) => {\n    asgCache.del(accountId);\n    return co(function* () {\n      let client = yield asgClient();\n      yield updateASG(client, parameters);\n      yield updateLCHs(client, parameters);\n    }).catch((error) => {\n      throw standardifyError(error, parameters.name);\n    });\n  };\n\n  this.enterInstancesToStandby = (parameters) => {\n    let request = {\n      AutoScalingGroupName: parameters.name,\n      ShouldDecrementDesiredCapacity: true,\n      InstanceIds: parameters.instanceIds\n    };\n    return asgClient().then(client => client.enterStandby(request).promise());\n  };\n\n  this.exitInstancesFromStandby = (parameters) => {\n    let request = {\n      AutoScalingGroupName: parameters.name,\n      InstanceIds: parameters.instanceIds\n    };\n    return asgClient().then(client => client.exitStandby(request).promise());\n  };\n\n  this.post = request => asgClient().then(client => client.createAutoScalingGroup(request).promise().catch((error) => {\n    throw standardifyError(error, request.AutoScalingGroupName);\n  }));\n\n  this.attachLifecycleHook = request => asgClient().then(client => client.putLifecycleHook(request).promise().catch((error) => {\n    throw standardifyError(error, request.AutoScalingGroupName);\n  }));\n\n  this.attachNotifications = request => asgClient().then(client => client.putNotificationConfiguration(request).promise().catch((error) => {\n    throw standardifyError(error, request.AutoScalingGroupName);\n  }));\n\n  this.describeScheduledActions = request => asgClient().then(client => client.describeScheduledActions(request).promise().then(result => result.ScheduledUpdateGroupActions).catch((error) => {\n    throw standardifyError(error, request.AutoScalingGroupName);\n  }));\n\n  this.describeLifeCycleHooks = request => asgClient().then(client => client.describeLifecycleHooks(request).promise().then(result => result.ScheduledUpdateGroupActions).catch((error) => {\n    throw standardifyError(error, request.AutoScalingGroupName);\n  }));\n\n  this.deleteScheduledAction = request => asgClient().then(client => client.deleteScheduledAction(request).promise().catch((error) => {\n    throw standardifyError(error, request.AutoScalingGroupName);\n  }));\n\n  this.createScheduledAction = request => asgClient().then(client => client.putScheduledUpdateGroupAction(request).promise().catch((error) => {\n    throw standardifyError(error, request.AutoScalingGroupName);\n  }));\n}\n\nmodule.exports = AsgResourceBase;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/resourceFactories/AsgResourceBase.js\n// module id = 106\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet {\n  setInstanceMaintenanceMode\n} = require('./consulMacroManager');\n\nlet {\n  getTargetState,\n  setTargetState,\n  removeTargetState,\n  removeRuntimeServerRoleTargetState,\n  getAllServiceTargets,\n  getServiceDeploymentCause,\n  getInstanceServiceDeploymentInfo\n} = require('./keyValueStore');\n\nmodule.exports = {\n  getTargetState,\n  setTargetState,\n  removeTargetState,\n  removeRuntimeServerRoleTargetState,\n  setInstanceMaintenanceMode,\n  getAllServiceTargets,\n  getServiceDeploymentCause,\n  getInstanceServiceDeploymentInfo\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/service-targets/consul/index.js\n// module id = 107\n// module chunks = 0","module.exports = require(\"retry\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"retry\"\n// module id = 108\n// module chunks = 0","'use strict';\n\nlet fs = require('fs');\nlet path = require('path');\nlet Ajv = require('ajv');\nlet Promise = require('bluebird');\nconst findInAncestor = require('../find-in-ancestor');\n\nconst readFile = Promise.promisify(fs.readFile);\n\nfunction loadSchema(schemaId, callback) {\n  return readFile(findInAncestor(path.join('schemas', `${schemaId}.json`), __dirname), 'utf-8')\n    .then(text => JSON.parse(text))\n    .asCallback(callback);\n}\n\nconst options = {\n  allErrors: true,\n  format: 'fast',\n  loadSchema\n};\n\nconst ajv = new Ajv(options);\nconst compileAsync = Promise.promisify(ajv.compileAsync.bind(ajv));\n\nfunction validator(schemaId) {\n  return getSchema(schemaId).then((validate) => {\n    let test = (value) => {\n      if (validate(value)) {\n        return [null, value];\n      } else {\n        let errors = validate.errors;\n        return [errors];\n      }\n    };\n\n    let assert = (value) => {\n      if (validate(value)) {\n        return true;\n      } else {\n        let errors = validate.errors;\n        throw new Error(JSON.stringify(errors, null, 4));\n      }\n    };\n\n    return {\n      assert,\n      test\n    };\n  });\n}\n\nfunction getSchema(schemaId) {\n  let validate = ajv.getSchema(schemaId);\n  return validate\n    ? Promise.resolve(validate)\n    : loadSchema(schemaId).then(schema => compileAsync(schema));\n}\n\nmodule.exports = validator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/schema/schema.js\n// module id = 109\n// module chunks = 0","module.exports = require(\"ajv\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"ajv\"\n// module id = 110\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet { appendLogEntries } = require('./data-access/deployments');\nlet logger = require('./logger');\nlet timer = require('timers');\n\nmodule.exports = function DeploymentLogsStreamer() {\n  let pendingLogEntries = (() => {\n    let state = new Map();\n    return {\n      add: (deploymentId, message) => {\n        if (!state.has(deploymentId)) {\n          state.set(deploymentId, []);\n        }\n        state.get(deploymentId).push(message);\n      },\n      deploymentIds: () => Array.from(state.keys()),\n      getByDeploymentId: deploymentId => state.get(deploymentId) || [],\n      removeByDeploymentId: deploymentId => state.delete(deploymentId)\n    };\n  })();\n\n  function logWriteErrors(result) {\n    if (result.error) {\n      logger.error(result.error);\n      logger.error(`Failed to flush pending log entries for deployment ${result.deploymentId}:\n${result.logEntries.join('\\n')}`);\n    }\n    return result;\n  }\n\n  function flushPendingLogEntries(deploymentId) {\n    let key = { DeploymentID: deploymentId };\n\n    let logEntries = pendingLogEntries.getByDeploymentId(deploymentId);\n    pendingLogEntries.removeByDeploymentId(deploymentId);\n    return appendLogEntries({ logEntries, key })\n      .then(() => ({ deploymentId }))\n      .catch(error => logWriteErrors({ deploymentId, logEntries, error }));\n  }\n\n  timer.setInterval(() => {\n    let promises = pendingLogEntries.deploymentIds().map(flushPendingLogEntries);\n    Promise.all(promises).catch(\n      (error) => {\n        logger.error(`An error has occurred streaming logs to DynamoDB: ${error.message}`);\n      }\n    );\n  }, 1000);\n\n  this.log = (deploymentId, message) => {\n    let timestamp = new Date().toISOString();\n    pendingLogEntries.add(deploymentId, `[${timestamp}] ${message}`);\n  };\n\n  this.flush = flushPendingLogEntries;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/DeploymentLogsStreamer.js\n// module id = 111\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet serviceTargets = require('../../modules/service-targets');\nlet schema = require('../../modules/schema/schema');\nlet DeploymentLogsStreamer = require('../../modules/DeploymentLogsStreamer');\nlet deploymentLogsStreamer = new DeploymentLogsStreamer();\n\nmodule.exports = function UpdateTargetState(command) {\n  let { deploymentId, key, options, value } = command;\n  return schema('UpdateTargetStateCommand')\n    .then(x => x.assert(command))\n    .then(() => deploymentLogsStreamer.log(deploymentId, `Updating key ${command.key}`))\n    .then(() => serviceTargets.setTargetState(command.environment, { key, value, options }));\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/commands/services/UpdateTargetState.js\n// module id = 112\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet co = require('co');\nlet configurationCache = require('../configurationCache');\nlet deployments = require('../data-access/deployments');\nlet fp = require('lodash/fp');\nlet { Clock, Instant, LocalDate, ZoneId } = require('js-joda');\nlet sender = require('../sender');\nlet GetTargetState = require('../../queryHandlers/services/GetTargetState');\nconst Deployment = require('../../models/Deployment');\n\nfunction getTargetAccountName(deployment) {\n  return configurationCache.getEnvironmentTypeByName(fp.get(['Value', 'EnvironmentType'])(deployment))\n    .then(fp.get(['AWSAccountName']));\n}\n\nfunction mapDeployment(deployment) {\n  const environmentName = deployment.Value.EnvironmentName;\n  const deploymentID = deployment.DeploymentID;\n  const accountName = deployment.AccountName;\n\n  return co(function* () {\n    let expectedNodes;\n    try {\n      let serviceDeployment = yield getServiceDeploymentDefinition(environmentName, deploymentID, accountName);\n      if (Array.isArray(serviceDeployment)) {\n        serviceDeployment = serviceDeployment[0];\n      }\n      if (serviceDeployment !== undefined) {\n        expectedNodes = serviceDeployment.value.ExpectedNodeDeployments;\n      }\n    } catch (error) {\n      expectedNodes = undefined;\n    }\n\n    if (deployment.Value.Status.toLowerCase() !== 'in progress') {\n      return new Deployment(deployment, expectedNodes);\n    }\n\n    let nodes = yield queryDeploymentNodeStates(environmentName, deploymentID, accountName);\n    deployment.Value.Nodes = nodes.map(mapNode);\n    return new Deployment(deployment, expectedNodes);\n  });\n}\n\nfunction mapNode(node) {\n  let resultNode = node.value;\n  let r = /.*\\/(.*)$/g;\n  resultNode.InstanceId = r.exec(node.key)[1];\n  return resultNode;\n}\n\nfunction queryDeployment({ key }) {\n  return deployments.get({ DeploymentID: key })\n    .then((result) => {\n      if (result === null) {\n        return null;\n      } else {\n        return getTargetAccountName(result).then((accountName) => {\n          result.AccountName = accountName;\n          if (Array.isArray(result.Value.ExecutionLog)) {\n            result.Value.ExecutionLog = result.Value.ExecutionLog.join('\\n');\n          }\n          return result;\n        });\n      }\n    });\n}\n\nfunction queryDeployments(query) {\n  let expressions = (() => {\n    function predicate(attribute, value) {\n      if (value === undefined) {\n        return null;\n      } else {\n        return ['=', ['at', ...attribute], ['val', value]];\n      }\n    }\n\n    let filter = [\n      predicate(['Value', 'EnvironmentName'], query.environment),\n      predicate(['Value', 'Status'], query.status),\n      predicate(['Value', 'OwningCluster'], query.cluster)\n    ].filter(x => x !== null);\n\n    if (filter.length === 0) {\n      return {};\n    } else if (filter.length === 1) {\n      return { FilterExpression: filter[0] };\n    } else {\n      return { FilterExpression: ['and', ...filter] };\n    }\n  })();\n\n  let now = Instant.now(Clock.systemUTC());\n  let startOfToday = LocalDate.ofInstant(now, ZoneId.UTC).atStartOfDay().toInstant(ZoneId.UTC);\n  let startDate = query.since instanceof Date\n    ? Instant.ofEpochMilli(query.since)\n    : startOfToday;\n  let endDate = now;\n  return deployments.queryByDateRange(startDate, endDate, expressions);\n}\n\nfunction getServiceDeploymentDefinition(environment, key, accountName) {\n  let consulQuery = {\n    name: 'GetTargetState',\n    key: `deployments/${key}/service`,\n    accountName,\n    environment,\n    recurse: true\n  };\n\n  return sender.sendQuery(GetTargetState, { query: consulQuery });\n}\n\nfunction queryDeploymentNodeStates(environment, key, accountName) {\n  let consulQuery = {\n    name: 'GetTargetState',\n    key: `deployments/${key}/nodes`,\n    accountName,\n    environment,\n    recurse: true\n  };\n\n  return sender.sendQuery(GetTargetState, { query: consulQuery });\n}\n\nmodule.exports = {\n\n  get: query => queryDeployment(query).then(x => (x !== null ? mapDeployment(x) : null)),\n\n  scan: query => queryDeployments(query)\n    .then((results) => {\n      let deploymentsWithNodes = results.map(mapDeployment);\n      return Promise.all(deploymentsWithNodes);\n    })\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/queryHandlersUtil/deployments-helper.js\n// module id = 113\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet co = require('co');\nlet configCache = require('../configurationCache');\n\nconst SCHEDULE_ENVIRONMENT = 'SCHEDULE_ENVIRONMENT';\n\nfunction getEnvironmentType(environmentName) {\n  return co(function* () {\n    let environment = yield configCache.getEnvironmentByName(environmentName);\n    return configCache.getEnvironmentTypeByName(environment.EnvironmentType);\n  });\n}\n\nfunction* isActionProtected(environmentName, action) {\n  let envType = yield getEnvironmentType(environmentName);\n  let protectedActions = envType.ProtectedActions || [];\n  return protectedActions.indexOf(action) !== -1;\n}\n\nmodule.exports = {\n  SCHEDULE_ENVIRONMENT,\n  isActionProtected: co.wrap(isActionProtected)\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/authorizers/environmentProtection.js\n// module id = 114\n// module chunks = 0","'use strict';\n\nlet _ = require('lodash');\nlet InstanceNotFoundError = require('../errors/InstanceNotFoundError.class');\n\nfunction InstanceResource(client) {\n  function flatInstances(data) {\n    let instances = reservation => reservation.Instances;\n    return _(data.Reservations).map(instances).compact().flatten().value();\n  }\n\n  function buildRequest(query) {\n    if (!query) return {};\n\n    // {a:1, b:2} => [{Name:'a', Values:[1]}, {Name:'b', Values:[2]}]\n    let Filters = _.toPairs(query).map(q => ({ Name: q[0], Values: _.castArray(q[1]) }));\n    return { Filters };\n  }\n\n  this.all = function (parameters) {\n    let request = buildRequest(parameters.filter);\n    let instances = [];\n\n    function query() {\n      return client.describeInstances(request).promise().then((data) => {\n        instances = instances.concat(flatInstances(data));\n\n        if (!data.NextToken) {\n          return _.map(instances);\n        }\n\n        // Scan from next index\n        request.NextToken = data.NextToken;\n        return query(client);\n      });\n    }\n\n    return query(client);\n  };\n\n  this.setTag = function (parameters) {\n    let request = {\n      Resources: parameters.instanceIds,\n      Tags: [\n        {\n          Key: parameters.tagKey,\n          Value: parameters.tagValue\n        }\n      ]\n    };\n\n    return client.createTags(request).promise().catch((error) => {\n      throw standardifyError(error);\n    });\n  };\n\n  function standardifyError(error) {\n    if (!error) return null;\n\n    return new InstanceNotFoundError(error.message);\n  }\n}\n\nmodule.exports = InstanceResource;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/resourceFactories/InstanceResourceBase.js\n// module id = 115\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet _ = require('lodash');\nlet servicesDb = require('../modules/data-access/services');\n\nclass Service {\n\n  constructor(data) {\n    _.assign(this, data);\n  }\n\n  static getByName(name) {\n    return servicesDb.get({ ServiceName: name })\n      .then(obj => (obj ? new Service(obj) : null));\n  }\n}\n\nmodule.exports = Service;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/models/Service.js\n// module id = 116\n// module chunks = 0","'use strict';\n\nconst yaml = require('js-yaml');\nconst fs = require('fs');\nconst findInAncestor = require('../modules/find-in-ancestor');\n\nconst apiSpec = yaml.safeLoad(fs.readFileSync(findInAncestor('swagger.yaml', __dirname), 'utf8'));\n\nmodule.exports = apiSpec;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/swagger-doc.js\n// module id = 117\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nconst LOGICAL_TABLE_NAME = 'InfraAsgIPs';\n\nlet { createDynamoClient: DocumentClient } = require('../amazon-client/childAccountClient');\nlet { getTableName: physicalTableName } = require('../awsResourceNameProvider');\n\nconst commonParams = Object.freeze({ TableName: physicalTableName(LOGICAL_TABLE_NAME) });\n\nfunction get(account, key) {\n  let params = Object.assign({ Key: key }, commonParams);\n  return DocumentClient(account)\n    .then(dynamo => dynamo.get(params).promise())\n    .then(({ Item }) => Item);\n}\n\nfunction put(account, item) {\n  let params = Object.assign({ Item: item }, commonParams);\n  return DocumentClient(account)\n    .then(dynamo => dynamo.put(params).promise());\n}\n\nmodule.exports = {\n  get,\n  put\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/data-access/asgips.js\n// module id = 118\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet _ = require('lodash');\nlet sender = require('../modules/sender');\nlet TaggableMixin = require('./TaggableMixin');\nlet ScanSecurityGroups = require('../queryHandlers/ScanSecurityGroups');\n\nclass SecurityGroup {\n  constructor(data) {\n    _.assign(this, data);\n  }\n\n  getName() {\n    return this.getTag('Name');\n  }\n\n  static getAllByIds(accountName, vpcId, groupIds) {\n    let query = {\n      name: 'ScanSecurityGroups',\n      accountName,\n      vpcId,\n      groupIds\n    };\n\n    return sender.sendQuery(ScanSecurityGroups, { query }).then(list => list.map(item => new TaggableSecurityGroup(item)));\n  }\n\n  static getAllByNames(accountName, vpcId, groupNames) {\n    let query = {\n      name: 'ScanSecurityGroups',\n      accountName,\n      vpcId,\n      groupNames\n    };\n\n    return sender.sendQuery(ScanSecurityGroups, { query }).then(list => list.map(item => new TaggableSecurityGroup(item)));\n  }\n}\n\nclass TaggableSecurityGroup extends TaggableMixin(SecurityGroup) { }\n\nmodule.exports = TaggableSecurityGroup;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/models/SecurityGroup.js\n// module id = 119\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet assert = require('assert');\nlet SecurityGroup = require('../../../models/SecurityGroup');\nlet _ = require('lodash');\n\n/**\n * These returns SecurityGroups in format\n * [ {Id, Name} ] where Id is AWS Secuity Group Id, and Name is a Tag:Name of an AWS Security Group\n */\nmodule.exports = {\n\n  getFromSecurityGroupNames(accountName, vpcId, securityGroupNamesAndReasons, logger) {\n    let securityGroupNames = [];\n    let securityGroupNamesAndReasonsMapping = {};\n\n    securityGroupNamesAndReasons.forEach((group) => {\n      securityGroupNames.push(group.name);\n      securityGroupNamesAndReasonsMapping[group.name] = group.reason;\n    });\n\n    return SecurityGroup.getAllByNames(accountName, vpcId, securityGroupNames)\n      .then(securityGroups =>\n        getAndVerifyAllExpectedSecurityGroups(securityGroups, vpcId, securityGroupNamesAndReasonsMapping, logger)\n      );\n  },\n\n  getFromConfiguration(configuration, image, accountName, logger) {\n    assert(configuration, 'Expected \"configuration\" argument not to be null');\n    assert(image, 'Expected \"image\" argument not to be null');\n    assert(accountName, 'Expected \"accountName\" argument not to be null');\n\n    let vpcId = configuration.environmentType.VpcId;\n    let securityGroupNamesAndReasons = getSecurityGroupsNamesAndReasons(configuration, image);\n\n    return this.getFromSecurityGroupNames(accountName, vpcId, securityGroupNamesAndReasons, logger);\n  }\n\n};\n\nfunction getAndVerifyAllExpectedSecurityGroups(securityGroups, vpcId, securityGroupNamesAndReasonsMapping) {\n  for (let securityGroupName in securityGroupNamesAndReasonsMapping) {\n    if ({}.hasOwnProperty.call(securityGroupNamesAndReasonsMapping, securityGroupName)) {\n      let found = _.find(securityGroups, sg => sg.getName() === securityGroupName);\n      if (found === undefined) {\n        throw new Error(`Security group \"${securityGroupName}\" not found in \"${vpcId}\" VPC. ${\n          securityGroupNamesAndReasonsMapping[securityGroupName]}`\n        );\n      }\n    }\n  }\n\n  return securityGroups;\n}\n\nfunction getSecurityGroupsNamesAndReasons(configuration, image) {\n  let cluster = configuration.cluster;\n  let imagePlatform = image.platform;\n  let securityZone = configuration.serverRole.SecurityZone;\n  let serverRoleName = configuration.serverRole.ServerRoleName;\n  let customSecurityGroups = configuration.serverRole.SecurityGroups || [];\n\n  let securityGroupNamesAndReasons = [];\n\n  if (customSecurityGroups.length) {\n    customSecurityGroups.forEach(group => securityGroupNamesAndReasons.push({\n      name: group,\n      reason: 'It is assigned because specified in the server role configuration.'\n    }));\n  } else {\n    securityGroupNamesAndReasons.push({\n      name: getSecurityGroupNameByServerRole(cluster, serverRoleName),\n      reason: 'It is assigned by default given server role and cluster. It can be overwritten ' +\n              'by specifying one or more security groups in the server role configuration.'\n    });\n  }\n\n  if (securityZone === 'Secure') {\n    securityGroupNamesAndReasons.push({\n      name: getSecurityGroupNameBySecurityZone(securityZone),\n      reason: 'It is assigned by default because server role security zone is Secure.'\n    });\n\n    securityGroupNamesAndReasons.push({\n      name: getSecurityGroupNameByPlatformSecure(image, securityZone),\n      reason: `It is assigned by default because instances image is ${imagePlatform} based in ` +\n              'Secure security zone.'\n    });\n  } else {\n    securityGroupNamesAndReasons.push({\n      name: getSecurityGroupNameByPlatform(image, securityZone),\n      reason: `It is assigned by default because instances image is ${imagePlatform} based.`\n    });\n  }\n\n  return securityGroupNamesAndReasons;\n}\n\n\nfunction getSecurityGroupNameByPlatform(image) {\n  return `sgOS${image.platform}`;\n}\n\nfunction getSecurityGroupNameByPlatformSecure(image) {\n  return `sgOS${image.platform}Secure`;\n}\n\nfunction getSecurityGroupNameByServerRole(cluster, serverRoleName) {\n  return `sgRole${cluster.Name}${serverRoleName}`;\n}\n\nfunction getSecurityGroupNameBySecurityZone(securityZone) {\n  return `sgZone${securityZone}`;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/provisioning/launchConfiguration/securityGroupsProvider.js\n// module id = 120\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nconst iamInstanceProfileResourceFactory = require('../modules/resourceFactories/iamInstanceProfileResourceFactory');\n\nmodule.exports = function GetInstanceProfile(query) {\n  let parameters = { accountName: query.accountName };\n  return iamInstanceProfileResourceFactory.create(undefined, parameters).then(resource =>\n    resource.get({ instanceProfileName: query.instanceProfileName })\n  );\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/queryHandlers/GetInstanceProfile.js\n// module id = 121\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet assert = require('assert');\nlet co = require('co');\nlet ConfigurationError = require('../../errors/ConfigurationError.class');\nlet _ = require('lodash');\n\nconst SECURE_SECURITY_ZONE = 'Secure';\n\nmodule.exports = {\n  get(configuration) {\n    assert(configuration, 'Expected \"configuration\" argument not to be null.');\n\n    return co(function* () {\n      let subnetTypeName = configuration.serverRole.SubnetTypeName;\n      validateSubnetType(configuration);\n      let subnets = yield getSubnetsByAvailabilityZone(subnetTypeName, configuration);\n      return subnets;\n    }).catch((error) => {\n      throw new ConfigurationError(\n            `Error retrieving subnet from \"${configuration.environmentTypeName}\": ${error.message}`);\n    });\n  }\n};\n\nfunction validateSubnetType(configuration) {\n  let securityZone = configuration.serverRole.SecurityZone;\n  let subnetTypeName = configuration.serverRole.SubnetTypeName;\n\n  let subnetType = configuration.environmentType.Subnets[subnetTypeName];\n\n  if (subnetType === undefined) {\n    throw new Error(`Couldn't find Subnet Type ${subnetTypeName} in environment type config`);\n  }\n\n  if (securityZone === SECURE_SECURITY_ZONE && subnetType.Secure !== true) {\n    throw new Error(`Can't use insecure subnet type \"${subnetTypeName}\" to deploy to Server Role with Security Zone \"Secure\"`);\n  }\n}\n\nfunction getSubnetsByAvailabilityZone(subnetTypeName, configuration) {\n  let subnetType = configuration.environmentType.Subnets[subnetTypeName];\n  if (!subnetType) {\n    throw new Error(`\"${subnetTypeName}\" subnet type not found`);\n  }\n\n  let availabilityZoneName = (configuration.serverRole.AvailabilityZoneName || '*');\n  let subnets = [];\n\n  if (availabilityZoneName === '*') {\n    subnets = [subnetType.AvailabilityZoneA, subnetType.AvailabilityZoneB, subnetType.AvailabilityZoneC,\n      subnetType.AvailabilityZoneD, subnetType.AvailabilityZoneE, subnetType.AvailabilityZoneF];\n  } else {\n    let azs = _.toArray(availabilityZoneName);\n    azs.forEach((az) => {\n      let name = az.toUpperCase();\n      switch (name) {\n        case 'A':\n          subnets.push(subnetType.AvailabilityZoneA);\n          break;\n        case 'B':\n          subnets.push(subnetType.AvailabilityZoneB);\n          break;\n        case 'C':\n          subnets.push(subnetType.AvailabilityZoneC);\n          break;\n        case 'D':\n          subnets.push(subnetType.AvailabilityZoneD);\n          break;\n        case 'E':\n          subnets.push(subnetType.AvailabilityZoneE);\n          break;\n        case 'F':\n          subnets.push(subnetType.AvailabilityZoneF);\n          break;\n        default:\n          throw new Error(`Unknown \"${name}\" availability zone specified in configuration. ` +\n            'Please specify one of the following values: \"A\", \"B\", \"C\" or \"*\".');\n      }\n    });\n  }\n\n  subnets = _.compact(subnets);\n\n  if (subnets.some(subnet => !subnet.trim())) {\n    throw new Error(`\"${subnetTypeName}\" subnet type does not contain the expected availability zones.`);\n  }\n\n  return subnets;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/provisioning/autoScaling/subnetsProvider.js\n// module id = 122\n// module chunks = 0","'use strict';\n\nconst buffer = require('buffer');\nconst base64 = 'base64';\nconst utf8 = 'utf8';\n\nlet decode = str => JSON.parse(new buffer.Buffer(str, base64).toString(utf8));\n\nlet encode = obj => new buffer.Buffer(JSON.stringify(obj), utf8).toString(base64);\n\nmodule.exports = {\n  decode,\n  encode\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/base64.js\n// module id = 123\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nconst LOGICAL_TABLE_NAME = 'InfraConfigLBSettings';\nconst TTL = 600; // seconds\n\nlet { getTableName: physicalTableName } = require('../awsResourceNameProvider');\nlet cachedSingleAccountDynamoTable = require('./cachedSingleAccountDynamoTable');\n\nmodule.exports = cachedSingleAccountDynamoTable(physicalTableName(LOGICAL_TABLE_NAME), { ttl: TTL });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/data-access/loadBalancerSettings.js\n// module id = 124\n// module chunks = 0","'use strict';\n\nconst logicalTableNames = {\n  accounts: 'InfraConfigAccounts',\n  clusters: 'InfraConfigClusters',\n  deploymentmaps: 'ConfigDeploymentMaps',\n  environments: 'ConfigEnvironments',\n  environmenttypes: 'ConfigEnvironments',\n  lbsettings: 'InfraConfigLBSettings',\n  lbupstream: 'InfraConfigLBUpstream',\n  permissions: 'InfraConfigPermissions',\n  services: 'InfraConfigServices'\n};\n\nfunction logicalTableName(entityTypeName) {\n  return logicalTableNames[entityTypeName];\n}\n\nmodule.exports = logicalTableName;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/api-utils/logicalTableName.js\n// module id = 125\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet S3GetObjectRequest = require('../../modules/S3GetObjectRequest');\nlet amazonClientFactory = require('../../modules/amazon-client/childAccountClient');\nlet sender = require('../../modules/sender');\nlet GetTargetState = require('../services/GetTargetState');\n\nfunction getNode({ deploymentId, instanceId, accountName, environment }) {\n  let query = {\n    name: 'GetTargetState',\n    key: `deployments/${deploymentId}/nodes/${instanceId}`,\n    accountName,\n    environment,\n    recurse: false\n  };\n\n  return sender.sendQuery(GetTargetState, { query }).then((node) => {\n    let s3Details = parseBucketAndPathFromS3Url(node.value.Log);\n    return fetchS3Object(accountName, s3Details);\n  }, (error) => {\n    if (error.message.match(/Key.*has not been found/)) {\n      throw new Error(`The service deployment ${deploymentId} hasn\\'t started on instance ${instanceId}.`);\n    } else throw error;\n  });\n}\n\nfunction fetchS3Object(account, s3Details) {\n  return amazonClientFactory.createS3Client(account).then((client) => {\n    let s3Request = new S3GetObjectRequest(client, s3Details);\n    return s3Request.execute()\n      .then(result => result.Body.toString());\n  });\n}\n\nfunction parseBucketAndPathFromS3Url(url) {\n  let r = /:\\/\\/(.*?)\\..*?\\/(.*)\\?/g;\n  let matches = r.exec(url);\n\n  if (matches) {\n    return {\n      bucketName: matches[1],\n      objectPath: matches[2]\n    };\n  } else {\n    return null;\n  }\n}\n\nmodule.exports = getNode;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/queryHandlers/deployments/GetNodeDeploymentLog.js\n// module id = 126\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet sender = require('./sender');\nlet ToggleTargetStatus = require('../commands/services/ToggleTargetStatus');\n\nfunction toggleServiceStatus({ environment, service, slice, enable, serverRole, user }) {\n  const name = 'ToggleTargetStatus';\n  const command = { name, environment, service, slice, enable, serverRole };\n  return sender.sendCommand(ToggleTargetStatus, { user, command });\n}\n\nmodule.exports = {\n  toggleServiceStatus\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/toggleServiceStatus.js\n// module id = 127\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\n/* Defines functions to locate a package in S3 given its name, version and (optionally) environment\n */\n\nlet config = require('../config');\nlet fp = require('lodash/fp');\nlet masterAccountClient = require('./amazon-client/masterAccountClient');\nlet s3Url = require('./amazon-client/s3Url');\n\nconst EM_PACKAGES_BUCKET = config.get('EM_PACKAGES_BUCKET');\nconst EM_PACKAGES_KEY_PREFIX = config.get('EM_PACKAGES_KEY_PREFIX');\n\nfunction key({ environment, service, version }) {\n  let dynamicParts = [service, version, environment].filter(x => x !== undefined);\n  let keyPathParts = [\n    EM_PACKAGES_KEY_PREFIX,\n    dynamicParts,\n    `${dynamicParts.join('-')}.zip`\n  ];\n  return fp.flow(fp.flatten, fp.filter(x => x !== undefined), fp.join('/'))(keyPathParts);\n}\n\n/**\n * Format an object as an S3 URL.\n * @param {Object} packageRef - an object with string properties service, version and (optionally) environment.\n * @returns {Object} an S3 location with string properties Bucket and Key.\n */\nfunction exactLocation(packageRef) {\n  return {\n    Bucket: EM_PACKAGES_BUCKET,\n    Key: key(packageRef)\n  };\n}\n\n/**\n * Format an object as an S3 URL.\n * @param {Object} packageRef - an object with string properties service, version and environment.\n * @returns {Array} An array of S3 locations, each with string properties Bucket and Key.\n */\nfunction s3GetLocations(packageRef) {\n  let matches = [\n    x => x,\n    fp.omit('environment')\n  ];\n  return fp.flow(fp.map(x => exactLocation(x(packageRef))), fp.uniq)(matches);\n}\n\nfunction findDownloadUrl(packageRef) {\n  let locations = s3GetLocations(packageRef);\n  return masterAccountClient.createS3Client()\n    .then((s3) => {\n      function getUrlIfObjectExists(location) {\n        let rq = s3.headObject(location);\n        return rq.promise().then(\n          () => s3Url.format(location, rq.httpRequest.region),\n          error => (error.statusCode === 404 ? Promise.resolve() : Promise.reject(error))\n        );\n      }\n\n      return Promise.all(locations.map(getUrlIfObjectExists))\n        .then(results => results.find(x => x));\n    });\n}\n\nmodule.exports = {\n  findDownloadUrl,\n  s3GetLocations,\n  s3PutLocation: exactLocation\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/s3PackageLocator.js\n// module id = 128\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n/**\n * @typedef {Object} S3Location\n * @property {string} endpoint\n * @property {string} Bucket\n * @property {string} Key\n * @property {string|undefined} VersionId\n */\n\n'use strict';\n\nconst AWS = require('aws-sdk');\nconst fp = require('lodash/fp');\n\nlet encodeKey = fp.flow(fp.split('/'), fp.map(encodeURIComponent), fp.join('/'));\n\nlet decodeKey = fp.flow(fp.split('/'), fp.map(decodeURIComponent), fp.join('/'));\n\n/**\n * Parse a string as an S3 object URL.\n * @param {string} url - the URL that refers to the S3 object.\n * @returns {S3Location|undefined} The parsed S3 location.\n */\nfunction parse(url) {\n  function parseBucketInPath() {\n    let regex = /^(https?:\\/\\/s3\\.?[^\\/\\.]+\\.amazonaws\\.com)\\/([^\\/]+)\\/([^\\?]+)(?:\\?versionId=([^&]+))?$/;\n    let t = regex.exec(url);\n    if (t === null) {\n      return undefined;\n    }\n    return {\n      endpoint: t[1],\n      Bucket: t[2],\n      Key: decodeKey(t[3]),\n      VersionId: t[4]\n    };\n  }\n\n  function parseBucketInHostname() {\n    let regex = /^(https?:\\/\\/)([^\\.]+)\\.(s3\\.?[^\\/\\.]+\\.amazonaws\\.com)\\/([^\\?]+)(?:\\?versionId=([^&]+))?$/;\n    let t = regex.exec(url);\n    if (t === null) {\n      return undefined;\n    }\n    return {\n      endpoint: t[1] + t[3],\n      Bucket: t[2],\n      Key: decodeKey(t[4]),\n      VersionId: t[5]\n    };\n  }\n\n  return parseBucketInPath() || parseBucketInHostname();\n}\n\n/**\n * Format an object as an S3 URL.\n * @param {string} s3location - an object with string properties Bucket, Key and (optionally) VersionId.\n * @returns {string} the URL that refers to the S3 object.\n */\nfunction format(s3location, region) {\n  let s3 = new AWS.S3({ region });\n  let versionId = x => (x.VersionId ? `?versionId=${x.VersionId}` : '');\n  return `${s3.endpoint.href}${s3location.Bucket}/${encodeKey(s3location.Key)}${versionId(s3location)}`;\n}\n\n/**\n * Get the object at the S3 URL.\n * @param {string} url - the URL that refers to the S3 object.\n * @param {Object} options - additional options to the AWS.S3 constructor.\n * @returns {ReadableStream} A readable stream of the object data.\n */\nfunction getObject(url, options) {\n  let params = parse(url);\n  if (params === undefined) {\n    throw new Error(`The URL is not a valid S3 object or object version URL: ${url}`);\n  }\n  let opts = Object.assign({}, options || {}, fp.pick(['endpoint'])(params));\n  let getObjectArgs = Object.assign({}, fp.compose(fp.pick(['Bucket', 'Key', 'VersionId']), fp.omitBy(fp.isUndefined))(params));\n  let request = new AWS.S3(opts).getObject(getObjectArgs);\n  return request.createReadStream();\n}\n\nmodule.exports = {\n  format,\n  getObject,\n  parse\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/amazon-client/s3Url.js\n// module id = 129\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet _ = require('lodash');\nlet scheduling = require('../modules/scheduling');\nlet Environment = require('./Environment');\nlet co = require('co');\nlet opsEnvironment = require('../modules/data-access/opsEnvironment');\n\nclass OpsEnvironment {\n\n  constructor(data) {\n    _.assign(this, data);\n  }\n\n  getScheduleStatus(date) {\n    let env = this.Value;\n    return scheduling.expectedStateFromSchedule(env, date).toUpperCase();\n  }\n\n  toAPIOutput() {\n    let self = this;\n    return co(function* () { // eslint-disable-line func-names\n      let value = _.pick(self.Value, 'ManualScheduleUp', 'ScheduleAutomatically', 'DeploymentsLocked');\n      value.InMaintenance = self.Value.EnvironmentInMaintenance;\n\n      let accountName = yield Environment.getAccountNameForEnvironment(self.EnvironmentName);\n      value.AccountName = accountName;\n\n      let ret = {\n        EnvironmentName: self.EnvironmentName,\n        Value: value\n      };\n\n      ret.Value.ScheduleStatus = self.getScheduleStatus();\n      return ret;\n    });\n  }\n\n  isNothing() {\n    return Object.keys(this).length === 0;\n  }\n\n  static getAll() {\n    return opsEnvironment.scan()\n      .then(list => list.map(env => new OpsEnvironment(env)));\n  }\n\n  static getByName(environmentName) {\n    return opsEnvironment.get({ EnvironmentName: environmentName })\n      .then(obj => new OpsEnvironment(obj));\n  }\n}\n\nmodule.exports = OpsEnvironment;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/models/OpsEnvironment.js\n// module id = 130\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\n/* eslint-disable */\n\nconst _ = require('lodash');\nconst parseSchedule = require('./parseSchedule');\nconst later = require('later');\nconst moment = require('moment-timezone');\n\nconst actions = {\n  switchOn: 'switchOn',\n  switchOff: 'switchOff',\n  putInService: 'putInService',\n  putOutOfService: 'putOutOfService',\n  skip: 'skip'\n};\n\nconst sources = {\n  instance: 'instance',\n  asg: 'asg',\n  environment: 'environment'\n};\n\nconst skipReasons = {\n  noEnvironment: 'This instance has no environment',\n  explicitNoSchedule: 'The schedule tag for this instance is set to \"noschedule\"',\n  invalidSchedule: 'The schedule tag for this instance is not valid',\n  transitioning: 'This instance is currently transitioning between states',\n  asgTransitioning: 'This instance is currently transitioning between ASG lifecycle states',\n  asgLifecycleMismatches: 'The ASG has instances in different lifecycle states',\n  maintenanceMode: 'This instance is currently in Maintenance Mode',\n  stateIsCorrect: 'The instance is already in the correct state'\n};\n\nconst states = {\n  on: 'on',\n  off: 'off'\n};\n\nconst lifeCycleStates = {\n  inService: 'InService',\n  outOfService: 'Standby'\n};\n\nconst currentStates = {\n  on: 'on',\n  off: 'off',\n  transitioning: 'transitioning'\n};\n\nfunction actionsForAutoScalingGroup(autoScalingGroup, instances, dateTime) {\n\n  autoScalingGroup.Environment = getTagValue(autoScalingGroup, 'Environment');\n\n  mergeAsgInstances(autoScalingGroup, instances);\n\n  if (autoScalingGroup.Instances.some(i => currentStateOfInstance(i._instance) == currentStates.transitioning))\n    return [];\n\n  if (!autoScalingGroup.Environment) {\n    return skipAll(autoScalingGroup, skipReasons.noEnvironment);\n  }\n\n  let foundSchedule = getScheduleFromTag(autoScalingGroup);\n\n  let source = foundSchedule.source;\n  let parseResult = foundSchedule.parseResult;\n\n  if (!parseResult.success) {\n    return skipAll(autoScalingGroup, `${skipReasons.invalidSchedule} - Error: '${parseResult.error}'`, source);\n  }\n\n  let schedule = parseResult.schedule;\n\n  if (schedule.skip) {\n\n    // TODO: Check for any instances that might have schedules, this should fallback on to actionForInstance\n\n    return skipAll(autoScalingGroup, skipReasons.explicitNoSchedule);\n  }\n\n  let localTime = convertToTimezone(dateTime, parseResult.timezone);\n  let expectedState = expectedStateFromParsedSchedule(schedule, localTime);\n\n  if (expectedState.noSchedule) {\n    return skipAll(autoScalingGroup, skipReasons.stateIsCorrect);\n  }\n\n  var expectedNumberOfServers = 0;\n\n  if (expectedState === states.on) {\n    expectedNumberOfServers = autoScalingGroup.MaxSize;\n  } else if (expectedState === states.off) {\n    expectedNumberOfServers = autoScalingGroup.MinSize;\n  } else {\n    expectedNumberOfServers = Number(expectedState);\n  }\n\n  var actions = [];\n\n  if (expectedNumberOfServers < calculateNumberOfServersRunning(autoScalingGroup)) {\n    var numberOfServersToSwitchOff = calculateNumberOfServersRunning(autoScalingGroup) - expectedNumberOfServers\n    actions = [...switchOffAsg(numberOfServersToSwitchOff, autoScalingGroup)];\n  } else if (expectedNumberOfServers > calculateNumberOfServersInService(autoScalingGroup)) {\n    var numberOfServersToSwitchOn = expectedNumberOfServers - calculateNumberOfServersInService(autoScalingGroup);\n    actions = [...switchOnAsg(numberOfServersToSwitchOn, autoScalingGroup)];\n  } else {\n    actions = skipAll(autoScalingGroup, skipReasons.stateIsCorrect);\n  }\n\n  return actions;\n}\n\nfunction calculateNumberOfServersRunning(autoScalingGroup) {\n  var distributionSet = getAsgDistributionSet(autoScalingGroup);\n  var numberOfServersRunning = findInstancesWhere(distributionSet, autoScalingGroup.Instances.length, (instance) => currentStateOfInstance(instance._instance) == currentStates.on);\n  return numberOfServersRunning.length;\n}\n\nfunction calculateNumberOfServersInService(autoScalingGroup) {\n  var distributionSet = getAsgDistributionSet(autoScalingGroup);\n  var numberOfServersInService = findInstancesWhere(distributionSet, autoScalingGroup.Instances.length, (instance) => instance.LifecycleState == lifeCycleStates.inService);\n  return numberOfServersInService.length;\n}\n\nfunction getAsgDistributionSet(autoScalingGroup) {\n  var results = {};\n  autoScalingGroup.AvailabilityZones.sort()\n  for (var availabilityZone of autoScalingGroup.AvailabilityZones) {\n    results[availabilityZone] = [];\n  }\n  for (var instance of autoScalingGroup.Instances) {\n    results[instance.AvailabilityZone].push(instance);\n    results[instance.AvailabilityZone].sort((a, b) => {\n      if (a.InstanceId > b.InstanceId) return 1;\n      if (a.InstanceId < b.InstanceId) return -1;\n      if (a.InstanceId === b.InstanceId) return 0;\n    });\n  }\n  return results;\n}\n\nfunction findInstancesWhere(distributionSet, numberOfServers, instancePredicate) {\n  var instancesFound = [];\n  for (var availabilityZone of Object.keys(distributionSet)) {\n    for (var instance of distributionSet[availabilityZone]) {\n      if (instancePredicate(instance) && instancesFound.length !== numberOfServers)\n        instancesFound.push(instance);\n    }\n  }\n  return instancesFound;\n}\n\nfunction switchOffAsg(numberOfServersToSwitchOff, autoScalingGroup) {\n\n  var distributionSet = getAsgDistributionSet(autoScalingGroup);\n\n  var actions = [];\n\n  var outOfServiceButRunningInstances = findInstancesWhere(distributionSet, numberOfServersToSwitchOff, (instance) =>\n    instance.LifecycleState == lifeCycleStates.outOfService && currentStateOfInstance(instance._instance) == currentStates.on);\n\n  var inServiceInstances = findInstancesWhere(distributionSet, numberOfServersToSwitchOff - outOfServiceButRunningInstances.length, (instance) =>\n    instance.LifecycleState == lifeCycleStates.inService);\n\n  for (var instance of [...outOfServiceButRunningInstances, ...inServiceInstances]) {\n    var action = getActionResult(switchOff(instance._instance),  getInstanceInfo(instance._instance));\n    actions.push(action);\n  }\n\n  return actions;\n}\n\nfunction getActionResult(action, instanceInfo) {\n  return { action: action, instance: instanceInfo };\n}\n\nfunction switchOnAsg(numberOfServersToSwitchOn, autoScalingGroup) {\n  var distributionSet = getAsgDistributionSet(autoScalingGroup);\n\n  var actions = [];\n\n  var inServiceInstances = findInstancesWhere(distributionSet, numberOfServersToSwitchOn, (instance) =>\n    instance.LifecycleState == lifeCycleStates.outOfService && currentStateOfInstance(instance._instance) == currentStates.on);\n\n  var outOfServiceAndSwitchedOffInstances = findInstancesWhere(distributionSet, numberOfServersToSwitchOn - inServiceInstances.length, (instance) =>\n    instance.LifecycleState == lifeCycleStates.outOfService && currentStateOfInstance(instance._instance) == currentStates.off);\n\n  for (var instance of [...inServiceInstances, ...outOfServiceAndSwitchedOffInstances]) {\n    var action = getActionResult(switchOn(instance._instance),  getInstanceInfo(instance._instance));\n    actions.push(action);\n  }\n\n  return actions;\n\n}\n\nfunction mergeAsgInstances(autoScalingGroup, instances) {\n  for (var instanceIndex in autoScalingGroup.Instances) {\n    var currentInstance = autoScalingGroup.Instances[instanceIndex];\n    var emInstance = instances.filter(x => x.InstanceId === currentInstance.InstanceId)[0];\n    currentInstance._instance = emInstance;\n  }\n}\n\nfunction actionForInstance(instance, dateTime) {\n\n  if (!instance.Environment) {\n    return getActionResult(skip(skipReasons.noEnvironment), getInstanceInfo(instance));\n  }\n\n  if (isInMaintenanceMode(instance)) {\n    return getActionResult(skip(skipReasons.maintenanceMode), getInstanceInfo(instance));\n  }\n\n  let foundSchedule = getScheduleFromTag(instance);\n\n  let source = foundSchedule.source;\n  let parseResult = foundSchedule.parseResult;\n\n  if (!parseResult.success) {\n    return getActionResult(skip(`${skipReasons.invalidSchedule} - Error: '${parseResult.error}'`, source),  getInstanceInfo(instance));\n  }\n\n  let schedule = parseResult.schedule;\n\n  if (schedule.skip) {\n    return getActionResult(skip(skipReasons.explicitNoSchedule, source),  getInstanceInfo(instance));\n  }\n\n  let localTime = convertToTimezone(dateTime, parseResult.timezone);\n  let expectedState = expectedStateFromParsedSchedule(schedule, localTime);\n\n  if (expectedState.noSchedule) {\n    return getActionResult(skip(skipReasons.stateIsCorrect), getInstanceInfo(instance));\n  }\n\n  if (expectedState === states.on) {\n    return getActionResult(switchOn(instance, source), getInstanceInfo(instance));\n  }\n\n  return getActionResult(switchOff(instance, source), getInstanceInfo(instance));\n}\n\nfunction expectedStateFromSchedule(schedule, dateTime) {\n  let parsedSchedule =\n    isEnvironmentSchedule(schedule) ?\n      parseEnvironmentSchedule(schedule) :\n      parseSchedule(schedule);\n\n  if (!parsedSchedule.success) {\n    return 'INVALID SCHEDULE';\n  }\n\n  if (parsedSchedule.schedule.skip) {\n    return 'NO SCHEDULE';\n  }\n\n  let localTime = convertToTimezone(dateTime, parsedSchedule.timezone);\n  let expectedState = expectedStateFromParsedSchedule(parsedSchedule.schedule, localTime);\n\n  if (expectedState.noSchedule) {\n    return 'NOT FOUND';\n  }\n\n  return expectedState;\n}\n\nfunction isEnvironmentSchedule(schedule) {\n  let environmentScheduleProperties = ['DefaultSchedule', 'ManualScheduleUp', 'ScheduleAutomatically'];\n  return _.some(environmentScheduleProperties, p => schedule[p] !== undefined);\n}\n\nfunction switchOn(instance, source) {\n  let currentState = currentStateOfInstance(instance);\n\n  if (currentState === currentStates.off) {\n    return takeAction(actions.switchOn, source);\n  }\n\n  if (currentState === currentStates.transitioning) { return skip(skipReasons.transitioning); }\n\n  if (instance.AutoScalingGroup) {\n    let lifeCycleState = getAsgInstanceLifeCycleState(instance);\n\n    if (lifeCycleState === lifeCycleStates.outOfService) {\n      return takeAction(actions.putInService, source);\n    }\n\n    if (lifeCycleState === lifeCycleStates.transitioning) {\n      return skip(skipReasons.asgTransitioning);\n    }\n  }\n\n  return skip(skipReasons.stateIsCorrect, source);\n}\n\nfunction switchOff(instance, source) {\n  if (instance.AutoScalingGroup) {\n    let lifeCycleState = getAsgInstanceLifeCycleState(instance);\n\n    if (lifeCycleState === lifeCycleStates.inService) {\n      return takeAction(actions.putOutOfService, source);\n    }\n\n    if (lifeCycleState === lifeCycleStates.transitioning) {\n      return skip(skipReasons.asgTransitioning);\n    }\n  }\n\n  let currentState = currentStateOfInstance(instance);\n\n  if (currentState === currentStates.on) {\n    return takeAction(actions.switchOff, source);\n  }\n\n  if (currentState === currentStates.transitioning) {\n    return skip(skipReasons.transitioning);\n  }\n\n  return skip(skipReasons.stateIsCorrect, source);\n}\n\nfunction isInMaintenanceMode(instance) {\n  let maintenanceModeTagValue = getTagValue(instance, 'maintenance');\n  return maintenanceModeTagValue && maintenanceModeTagValue.toLowerCase() === 'true';\n}\n\nfunction getAsgInstanceLifeCycleState(instance) {\n  let asgInstanceEntry = _.first(instance.AutoScalingGroup.Instances.filter(i => i.InstanceId.toLowerCase() === instance.InstanceId.toLowerCase()));\n\n  if (asgInstanceEntry) {\n    if (asgInstanceEntry.LifecycleState === 'Standby') return lifeCycleStates.outOfService;\n    if (asgInstanceEntry.LifecycleState === 'InService') return lifeCycleStates.inService;\n  }\n\n  return lifeCycleStates.transitioning;\n}\n\nfunction getScheduleFromTag(instance) {\n  let instanceSchedule = getTagValue(instance, 'schedule');\n  if (instanceSchedule) return { parseResult: parseSchedule(instanceSchedule), source: sources.instance };\n\n  if (instance.AutoScalingGroup) {\n    let asgSchedule = getTagValue(instance.AutoScalingGroup, 'schedule');\n    if (asgSchedule) return { parseResult: parseSchedule(asgSchedule), source: sources.asg };\n  }\n\n  return { parseResult: parseEnvironmentSchedule(instance.Environment), source: sources.environment };\n}\n\nfunction parseEnvironmentSchedule(environmentSchedule) {\n  if (environmentIsScheduledOff(environmentSchedule)) {\n    return { success: true, schedule: { permanent: states.off } };\n  }\n\n  if (environmentIsScheduledOn(environmentSchedule)) {\n    return { success: true, schedule: { permanent: states.on } };\n  }\n\n  return parseSchedule(environmentSchedule.DefaultSchedule);\n}\n\nfunction environmentIsScheduledOff(schedule) {\n  return schedule.ManualScheduleUp === false && schedule.ScheduleAutomatically === false;\n}\n\nfunction environmentIsScheduledOn(schedule) {\n  return !(schedule.ManualScheduleUp !== true && schedule.ScheduleAutomatically === true);\n}\n\nfunction expectedStateFromParsedSchedule(schedules, dateTime) {\n  if (schedules.permanent) {\n    return schedules.permanent;\n  }\n\n  let scheduleStates = schedules.map((schedule) => {\n    return {\n      dateTime: later.schedule(schedule.recurrence).prev(1, dateTime),\n      state: schedule.state\n    };\n  });\n\n  let latest = _.maxBy(scheduleStates, scheduleState => scheduleState.dateTime);\n\n  if (latest.dateTime === 0) { return { noSchedule: true }; }\n\n  return latest.state;\n}\n\nfunction convertToTimezone(dateTime, timezone) {\n  let matchingZoneTime = moment.tz(dateTime, 'utc').tz(timezone || 'utc').format('YYYY-MM-DDTHH:mm:ss');\n  return `${matchingZoneTime}Z`;\n}\n\nfunction getTagValue(instance, tagName) {\n  if (instance.Tags) {\n    let tag = _.first(instance.Tags.filter(t => t.Key.toLowerCase() === tagName.toLowerCase()));\n    return (tag && tag.Value) ? tag.Value.trim() : undefined;\n  }\n  return undefined;\n}\n\nfunction currentStateOfInstance(instance) {\n  if (!instance || !instance.State) return currentStates.transitioning;\n  if (instance.State.Name === 'running') return currentStates.on;\n  if (instance.State.Name === 'stopped') return currentStates.off;\n\n  return currentStates.transitioning;\n}\n\nfunction skip(reason, source) {\n  return { action: actions.skip, reason, source };\n}\n\nfunction skipAll(autoScalingGroup, reason, source) {\n  var actions = [];\n  for (var instanceIndex in autoScalingGroup.Instances) {\n    var currentInstance = autoScalingGroup.Instances[instanceIndex];\n\n    var result = { action: skip(reason, source), instance: getInstanceInfo(currentInstance._instance || currentInstance) };\n    actions.push(result);\n  }\n  return actions;\n}\n\nfunction takeAction(action, source) {\n  return { action, source };\n}\n\nfunction getInstanceInfo(instance) {\n  let instanceVM = {\n    id: instance.InstanceId,\n    name: getTagValue(instance, 'name'),\n    role: getTagValue(instance, 'role'),\n    environment: getTagValue(instance, 'environment')\n  };\n  if (instance.AutoScalingGroup) {\n    instanceVM.asg = instance.AutoScalingGroup.AutoScalingGroupName;\n  }\n  return instanceVM;\n}\n\nmodule.exports = {\n  actions,\n  sources,\n  skipReasons,\n  states,\n  actionForInstance,\n  actionsForAutoScalingGroup,\n  expectedStateFromSchedule\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/scheduling/index.js\n// module id = 131\n// module chunks = 0","module.exports = require(\"later\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"later\"\n// module id = 132\n// module chunks = 0","module.exports = require(\"http\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"http\"\n// module id = 133\n// module chunks = 0","module.exports = require(\"https\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"https\"\n// module id = 134\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet _ = require('lodash');\nlet fp = require('lodash/fp');\nlet co = require('co');\n\nlet getInstanceState = require('./getInstanceState');\nlet getServicesState = require('./getServicesState');\nlet getAWSInstances = require('./getAWSInstances');\n\nlet AutoScalingGroup = require('../../models/AutoScalingGroup');\nlet logger = require('../logger');\nlet Environment = require('../../models/Environment');\nlet Enums = require('../../Enums');\nlet DIFF_STATE = Enums.DIFF_STATE;\nlet HEALTH_STATUS = Enums.HEALTH_STATUS;\n\n// Services with 'Extra' diff state are present on some instances, but not in target state, typically because they're Ignored\nfunction getServicesSummary(services) {\n  let expected = _.filter(services, (service) => {\n    let diff = service.DiffWithTargetState;\n    return diff !== DIFF_STATE.Unexpected && diff !== DIFF_STATE.Ignored;\n  });\n\n  let expectedAndHealthy = _.filter(expected, s => s.OverallHealth === HEALTH_STATUS.Healthy);\n\n  let unexpected = _.filter(services, { DiffWithTargetState: DIFF_STATE.Unexpected });\n  let missing = _.filter(services, { DiffWithTargetState: DIFF_STATE.Missing });\n  let ignored = _.filter(services, { DiffWithTargetState: DIFF_STATE.Ignored });\n\n  return {\n    AllExpectedServicesPresent: missing.length === 0,\n    AllExpectedServicesHealthy: expectedAndHealthy.length === expected.length,\n    ServicesCount: {\n      Expected: expected.length,\n      Unexpected: unexpected.length,\n      Missing: missing.length,\n      Ignored: ignored.length\n    },\n    ExpectedServices: fp.map(fp.pick(['Name', 'Slice', 'Version']), expected),\n    MissingServices: fp.map(fp.pick(['Name', 'Slice', 'Version']), missing)\n  };\n}\n\nfunction getASGState(environmentName, asgName) {\n  return co(function* () {\n    const accountName = yield (yield Environment.getByName(environmentName)).getAccountName();\n    let asg = yield AutoScalingGroup.getByName(accountName, asgName);\n\n    let instancesIds = _.map(asg.Instances, 'InstanceId');\n    let instances = yield getAWSInstances(accountName, instancesIds);\n\n    let instancesStates = yield _.map(instances, (instance) => {\n      // Fresh instances might not have initialised tags yet - don't merge state when that happens\n      if (instance.Name !== undefined) {\n        return getInstanceState(accountName, environmentName, instance.Name, instance.InstanceId, instance.Role, instance.LaunchTime);\n      } else {\n        logger.warn(`Instance ${instance.InstanceId} name tag is undefined`);\n        return {};\n      }\n    });\n\n    _.forEach(instances, (instance, index) => {\n      // Copy ASG instance data\n      let asgInstance = _.find(asg.Instances, { InstanceId: instance.InstanceId });\n      instance.LifecycleState = asgInstance.LifecycleState;\n\n      // Copy ASG state data\n      _.assign(instance, instancesStates[index]);\n    });\n\n    let services = yield getServicesState(environmentName, asg.getRuntimeServerRoleName(), instances);\n\n    let response = getServicesSummary(services);\n    _.assign(response, {\n      Services: services,\n      Instances: instances\n    });\n\n    return response;\n  });\n}\n\ngetASGState.getServicesSummary = getServicesSummary;\n\nmodule.exports = getASGState;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/environment-state/getASGState.js\n// module id = 135\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet serviceDiscovery = require('../service-discovery');\nlet serviceTargets = require('../service-targets');\nlet _ = require('lodash');\nlet co = require('co');\nlet Enums = require('../../Enums');\nlet DIFF_STATE = Enums.DIFF_STATE;\nlet DEPLOYMENT_STATUS = Enums.DEPLOYMENT_STATUS;\nlet serviceUtil = require('./serviceStateUtils');\n\n/**\n * Returns a detailed view of the current state of a given instance and its services\n */\nfunction getInstanceState(accountName, environmentName, nodeName, instanceId, runtimeServerRoleName, instanceLaunchTime) {\n  return co(function* () {\n    // Get info on 'current state' of services from consul\n    let response = yield {\n      checks: serviceDiscovery.getNodeHealth(environmentName, nodeName),\n      node: serviceDiscovery.getNode(environmentName, nodeName)\n    };\n    let checks = response.checks;\n    let node = response.node;\n    let services = node ? node.Services : [];\n\n    // Get info on 'target state'\n    let targetServiceStates = yield serviceTargets.getAllServiceTargets(environmentName, runtimeServerRoleName);\n\n    // Combine consul service info with target state info and remove redundant service values\n    let consulServiceContext = { checks, targetServiceStates, environmentName, instanceId, accountName };\n    services = yield _.map(services, co.wrap(describeConsulService.bind(this, consulServiceContext)));\n    services = _.compact(services);\n\n    // Find missing services (in target state but not on instance)\n    _.each(targetServiceStates, findMissingServices.bind(this, { services, accountName, instanceId, instanceLaunchTime }));\n    // Find unexpected services (on instance but not in target state)\n    _.each(services, findUnexpectedServices.bind(this, { targetServiceStates, runtimeServerRoleName }));\n    // Set convenience name value\n    _.each(services, (service) => { service.NameAndSlice = serviceUtil.getServiceAndSlice(service); });\n\n    return {\n      OverallHealth: serviceUtil.getOverallHealth(checks),\n      DeploymentStatus: serviceUtil.getInstanceDeploymentStatus(services),\n      RunningServicesCount: serviceUtil.getRunningServicesCount(services),\n      MissingOrUnexpectedServices: serviceUtil.hasMissingOrUnexpectedServices(services),\n      Services: services\n    };\n  });\n}\n\n/**\n * Augments a service object retrieved from consul with extra information\n *\n * @param context {object} Context info on healthchecks, target states, environment, instance & account\n * @param service {object} The service value from consul\n * @returns {object} A new object combining context info with consul service info\n */\nfunction* describeConsulService(context, service) {\n  let { checks, targetServiceStates, environmentName, instanceId, accountName } = context;\n  service.Tags = serviceUtil.mapConsulTags(service.Tags);\n\n  let targetService = _.find(targetServiceStates, {\n    Name: serviceUtil.getSimpleServiceName(service.Service), Slice: service.Tags.slice });\n\n  let deploymentId = _.get(targetService, 'DeploymentId') || service.Tags.deployment_id;\n\n  if (!deploymentId) return false; // It's not EM deployed service\n\n  let instanceDeploymentInfo = yield serviceTargets.getInstanceServiceDeploymentInfo(environmentName, deploymentId, instanceId);\n  let deploymentStatus = instanceDeploymentInfo ? instanceDeploymentInfo.Status : 'Success';\n  let logURL = serviceUtil.getLogUrl(deploymentId, accountName, instanceId);\n  let deploymentCause = yield serviceTargets.getServiceDeploymentCause(environmentName, deploymentId, instanceId);\n  // Note: we use DeploymentId from targetService, because DeploymentId from catalog might be old - in case\n  // last deployment was unsuccessful\n  return serviceUtil.formatConsulService(service, checks, deploymentId, deploymentStatus, deploymentCause, logURL);\n}\n\n/**\n * Finds services defined in target state but not present on instance.\n * Missing services are added to the {context.services} array in place.\n *\n * @param context {object} Context info on instance services, account, instance id and launch time\n * @param targetService {object} The target service to look for on the instance\n */\nfunction findMissingServices(context, targetService) {\n  let { services, accountName, instanceId, instanceLaunchTime } = context;\n\n  if (_.find(services, { Name: targetService.Name, Slice: targetService.Slice }) === undefined) {\n    if (targetService.Action === Enums.ServiceAction.IGNORE) {\n      return; // Don't include ignored services\n    }\n    // Allow 60 minutes 'missing' before concluding that service won't get installed on instance\n    let deploymentStatus;\n    let timeoutDateMs = new Date(instanceLaunchTime).getTime() + (60 * 60 * 1000);\n    if (timeoutDateMs > new Date().getTime()) {\n      deploymentStatus = DEPLOYMENT_STATUS.InProgress;\n    } else {\n      deploymentStatus = DEPLOYMENT_STATUS.Failed;\n    }\n    let logURL = serviceUtil.getLogUrl(targetService.DeploymentId, accountName, instanceId);\n    let missingService = serviceUtil.formatMissingService(targetService, deploymentStatus, logURL);\n    services.push(missingService);\n  }\n}\n\n/**\n * Finds services present on an instance that aren't defined in the target state.\n * Adds a warning attribute to any unexpected services\n *\n * @param context {object} Context info on target states and server role\n * @param instanceService {object} The service to interrogate\n */\nfunction findUnexpectedServices(context, instanceService) {\n  let { targetServiceStates, runtimeServerRoleName } = context;\n  // If DiffWithTargetState is present, it's a placeholder - it's not present on instance\n  if (instanceService.DiffWithTargetState !== null) {\n    return;\n  }\n  let targetState = _.find(targetServiceStates, { Name: instanceService.Name, Slice: instanceService.Slice });\n\n  if (targetState === undefined) {\n    instanceService.Issues.Warnings.push(\n      `Service missing in target state for server role \"${runtimeServerRoleName}\"`);\n    instanceService.DiffWithTargetState = DIFF_STATE.Unexpected;\n  } else if (targetState.Action !== Enums.ServiceAction.INSTALL) {\n    instanceService.Issues.Warnings.push(\n      `Service for server role \"${runtimeServerRoleName}\" is marked for \"${targetState.Action}\" action`);\n    instanceService.DiffWithTargetState = DIFF_STATE.Unexpected;\n  }\n}\n\nmodule.exports = getInstanceState;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/environment-state/getInstanceState.js\n// module id = 136\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet InvalidOperationError = require('./errors/InvalidOperationError.class');\nconst STATES_AS_IN_SERVICE = ['InService', 'Pending', 'Pending:Wait', 'Pending:Proceed'];\n\nfunction getFirstUnknownInstanceId(autoScalingGroup, instanceIds) {\n  let autoScalingGroupInstanceIds = autoScalingGroup.Instances.map(\n    instance => instance.InstanceId\n  );\n\n  let unknownInstanceIds = instanceIds.filter(id =>\n      autoScalingGroupInstanceIds.indexOf(id) < 0\n  );\n  return unknownInstanceIds[0];\n}\n\nfunction predictSizeAfterEnteringInstancesToStandby(autoScalingGroup, instancesIds) {\n  let unknownInstanceId = getFirstUnknownInstanceId(autoScalingGroup, instancesIds);\n  if (unknownInstanceId) {\n    return Promise.reject(new InvalidOperationError(\n      `The instance \"${unknownInstanceId}\" is not part of \"${autoScalingGroup.AutoScalingGroupName}\" AutoScalingGroup.`\n    ));\n  }\n\n  let instancesInService = 0;\n  let instancesToStandby = 0;\n\n  for (let i = 0; i < autoScalingGroup.Instances.length; i++) {\n    let instance = autoScalingGroup.Instances[i];\n\n    // Counting all instances that are or will be InService\n    if (STATES_AS_IN_SERVICE.indexOf(instance.LifecycleState) >= 0) instancesInService++;\n\n    // Exclude all instances not specified by the command\n    if (instancesIds.indexOf(instance.InstanceId) < 0) continue; // eslint-disable-line no-continue\n\n    if (instance.LifecycleState !== 'InService') {\n      return Promise.reject(new InvalidOperationError(\n        `The instance \"${instance.InstanceId}\" cannot be entered to standby as its LifecycleState is ${instance.LifecycleState}.`\n      ));\n    }\n    instancesToStandby++;\n  }\n\n  return Promise.resolve(instancesInService - instancesToStandby);\n}\n\nfunction predictSizeAfterExitingInstancesFromStandby(autoScalingGroup, instancesIds) {\n  let unknownInstanceId = getFirstUnknownInstanceId(autoScalingGroup, instancesIds);\n  if (unknownInstanceId) {\n    return Promise.reject(new InvalidOperationError(\n      `The instance \"${unknownInstanceId}\" is not part of \"${autoScalingGroup.AutoScalingGroupName}\" AutoScalingGroup.`\n    ));\n  }\n\n  let instancesInService = 0;\n  let instancesToUnstandby = 0;\n\n  for (let i = 0; i < autoScalingGroup.Instances.length; i++) {\n    let instance = autoScalingGroup.Instances[i];\n\n    // Counting all instances that are or will be InService\n    if (STATES_AS_IN_SERVICE.indexOf(instance.LifecycleState) >= 0) instancesInService++;\n\n    // Exclude all instances not specified by the command\n    if (instancesIds.indexOf(instance.InstanceId) < 0) continue; // eslint-disable-line no-continue\n\n    if (instance.LifecycleState !== 'Standby') {\n      return Promise.reject(new InvalidOperationError(\n        `The instance \"${instance.InstanceId}\" cannot be exited from standby as its LifecycleState is ${instance.LifecycleState}.`\n      ));\n    }\n\n    instancesToUnstandby++;\n  }\n\n  return Promise.resolve(instancesInService + instancesToUnstandby);\n}\n\nmodule.exports = {\n  predictSizeAfterEnteringInstancesToStandby,\n  predictSizeAfterExitingInstancesFromStandby\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/autoScalingGroupSizePredictor.js\n// module id = 137\n// module chunks = 0","module.exports = require(\"request\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"request\"\n// module id = 138\n// module chunks = 0","'use strict';\n\nmodule.exports = function create(status, value) {\n  return response => response.format({\n    'text/plain': () => response.status(status).send(value), // This is the default if no \"Accept\" header specified; see https://expressjs.com/en/api.html#res.format\n    'application/json': () => response.status(status).json({ url: value })\n  });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/controllers/package-upload-url/dynamicResponseCreator.js\n// module id = 139\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet Promise = require('bluebird');\nlet co = require('co');\nlet _ = require('lodash');\nlet ResourceNotFoundError = require('../errors/ResourceNotFoundError.class');\nlet servicesDb = require('../data-access/services');\n\nfunction hostFilter(active) {\n  if (active === true) {\n    return host => host.State === 'up';\n  } else if (active === false) {\n    return host => host.State === 'down';\n  } else {\n    return () => true;\n  }\n}\n\nfunction* handleQuery(query, inputUpstreams) {\n  // Get all LoadBalancer upstreams from DynamoDB without apply any filter.\n  // NOTE: If it ever becomes a DynamoDB map item then filtering this query\n  //       would be great!\n\n  // If any upstream was found the chain continues otherwise a\n  // [ResourceNotFound] error is returned.\n  if (!inputUpstreams.length) {\n    throw new ResourceNotFoundError('No load balancer upstream has been found.');\n  }\n\n  // Flatting upstreams hosts in to a plain list\n  // eslint-disable-next-line arrow-body-style\n  let upstreamValues = (upstream) => {\n    return upstream.Hosts.filter(hostFilter(query.active)).map(host => ({\n      Key: upstream.Key,\n      EnvironmentName: upstream.Environment,\n      ServiceName: upstream.Service,\n      UpstreamName: upstream.Upstream,\n      DnsName: host.DnsName,\n      Port: host.Port,\n      OwningCluster: '',\n      Name: 'Unknown',\n      State: host.State === 'up' ? 'Active' : 'Inactive'\n    }));\n  };\n\n  let upstreams = _(inputUpstreams).map(upstreamValues).compact().flatten().value();\n  // Getting all services the upstreams refer to\n\n  // Extracts all service names the found upstreams refer to\n  let serviceNames = [...new Set(upstreams.map(upstream => upstream.ServiceName))];\n\n  // Gets all services from DynamoDB table\n  let services = yield Promise.map(serviceNames, ServiceName => servicesDb.get({ ServiceName }))\n    .then(ss => ss.filter(s => s));\n\n  // Assigning blue/green port reference to the found slices\n  function getServicesPortMapping(sliceServices) {\n    let result = {};\n    sliceServices.forEach((service) => {\n      let portsMapping = {};\n      portsMapping.owningCluster = service.OwningCluster;\n      if (service.Value.BluePort) portsMapping[service.Value.BluePort] = 'Blue';\n      if (service.Value.GreenPort) portsMapping[service.Value.GreenPort] = 'Green';\n      result[service.ServiceName] = portsMapping;\n    });\n\n    return result;\n  }\n\n  let servicesPortsMapping = getServicesPortMapping(services);\n\n  upstreams.forEach((upstream) => {\n    let servicePortsMapping = servicesPortsMapping[upstream.ServiceName];\n    if (!servicePortsMapping) return;\n    upstream.OwningCluster = servicePortsMapping.owningCluster;\n    let portMapping = servicePortsMapping[upstream.Port];\n    if (!portMapping) return;\n    upstream.Name = portMapping;\n  });\n\n  return upstreams;\n}\n\nmodule.exports = {\n  handleQuery: co.wrap(handleQuery)\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/queryHandlersUtil/getSlices.js\n// module id = 140\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet Promise = require('bluebird');\n\nlet ResourceNotFoundError = require('../../modules/errors/ResourceNotFoundError.class');\nlet InconsistentSlicesStatusError = require('../../modules/errors/InconsistentSlicesStatusError.class');\nlet logger = require('../../modules/logger');\nlet servicesDb = require('../../modules/data-access/services');\nlet loadBalancerUpstreams = require('../../modules/data-access/loadBalancerUpstreams');\n\nfunction ToggleUpstreamByServiceVerifier() {\n  this.verifyUpstreams = (upstreams) => {\n    return getServicePortMappings(upstreams[0].Service)\n      .then(portMapping => Promise.map(upstreams, upstream => detectUpstreamInconsistency(upstream, portMapping)));\n  };\n\n  function detectUpstreamInconsistency(upstream, portMapping) {\n    if (upstream.Hosts.length === 0) {\n      return makeUpstreamError(upstream, 'cannot be toggled because it has no slice');\n    }\n\n    if (upstream.Hosts.length === 1) {\n      return makeUpstreamError(upstream, 'cannot be toggled because it has only one slice');\n    }\n\n    if (upstream.Hosts.length > 2) {\n      return makeUpstreamError(upstream, 'cannot be toggled because it has more than two slices');\n    }\n\n    let statuses = [...new Set(upstream.Hosts.map((host) => { return host.State === 'up' ? 'Active' : 'Inactive'; }))];\n    if (statuses.length === 1) {\n      return makeUpstreamError(upstream, `cannot be toggled because all its slices are \"${statuses[0]}\"`);\n    }\n\n    let slicesNames = upstream.Hosts.map(host => portMapping[host.Port]);\n    if (slicesNames.indexOf('Blue') < 0) {\n      return makeUpstreamError(upstream, 'cannot be toggled because there is no way to detect which slice is \"blue\"');\n    }\n\n    if (slicesNames.indexOf('Green') < 0) {\n      return makeUpstreamError(upstream, 'cannot be toggled because there is no way to detect which slice is \"green\"');\n    }\n\n    return Promise.resolve();\n  }\n\n  function makeUpstreamError(upstream, reason) {\n    let message = `Upstream named \"${upstream.Upstream}\" which refers to \"${upstream.Service}\" service in \"${upstream.Environment}\" environment ${reason}.`;\n    return Promise.reject(new InconsistentSlicesStatusError(message));\n  }\n}\n\nfunction getServicePortMappings(serviceName) {\n  return servicesDb.get({ ServiceName: serviceName })\n    .then(asPortMapping);\n}\n\nfunction asPortMapping(service) {\n  let portMapping = {};\n  if (service) {\n    if (service.Value.BluePort) portMapping[service.Value.BluePort] = 'Blue';\n    if (service.Value.GreenPort) portMapping[service.Value.GreenPort] = 'Green';\n  }\n\n  return portMapping;\n}\n\nfunction ToggleUpstreamByNameVerifier(resourceName) {\n  return {\n    verifyUpstreams(upstreams) {\n      if (upstreams.length > 1) {\n        let keys = upstreams.map(upstream => upstream.key).join(', ');\n        let message = `${resourceName} cannot be toggled because all following keys refer to it: ${keys}.`;\n        return Promise.reject(new InconsistentSlicesStatusError(message));\n      }\n\n      let upstream = upstreams[0];\n      if (upstream.Hosts.length === 0) {\n        let message = `Upstream named \"${upstream.Upstream}\" which refers to \"${upstream.Service}\" service in \"${upstream.Environment}\" environment cannot be toggled because it has no slice.`;\n        return Promise.reject(new InconsistentSlicesStatusError(message));\n      }\n\n      return Promise.resolve();\n    }\n  };\n}\n\nfunction UpstreamProvider(_, toggleCommand, resourceName) {\n  let { environmentName, serviceName, upstreamName } = toggleCommand;\n\n  let errorIfNone = items => (items.length === 0\n    ? Promise.reject(new ResourceNotFoundError(`No ${resourceName} has been found.`))\n    : Promise.resolve(items));\n\n  return {\n    provideUpstreams() {\n      if (serviceName) {\n        return loadBalancerUpstreams.inEnvironmentWithService(environmentName, serviceName)\n          .then(errorIfNone);\n      } else if (upstreamName) {\n        return loadBalancerUpstreams.inEnvironmentWithUpstream(environmentName, upstreamName)\n          .then(errorIfNone);\n      } else {\n        return Promise.reject(`Expected one of serviceName, upstreamName in toggleCommand: ${toggleCommand}`);\n      }\n    }\n  };\n}\n\nfunction UpstreamToggler(senderInstance, toggleCommand) {\n  let metadata = {\n    TransactionID: toggleCommand.commandId,\n    User: toggleCommand.username\n  };\n  return {\n    toggleUpstream(upstream) {\n      return getServicePortMappings(upstream.Service)\n        .then(portMappings => loadBalancerUpstreams.toggle(upstream, metadata, toggleCommand, portMappings));\n    }\n  };\n}\n\nfunction orchestrate(provider, verifier, toggler) {\n  let upstreamsP = provider.provideUpstreams();\n  let verifiedP = upstreamsP.then(upstreams => verifier.verifyUpstreams(upstreams));\n  let toggledP = Promise.map(upstreamsP, upstream => toggler.toggleUpstream(upstream)\n    .then(() => [null, upstream.Upstream])\n    .catch(error => [error, upstream.Upstream]));\n  return Promise.join(toggledP, verifiedP, toggled => ({\n    ToggledUpstreams: toggled.reduce((acc, [error, data]) => {\n      if (error) {\n        logger.error(error);\n        return acc;\n      } else {\n        return [...acc, data];\n      }\n    }, [])\n  }));\n}\n\nmodule.exports = {\n  UpstreamProvider,\n  UpstreamToggler,\n  orchestrate,\n  ToggleUpstreamByServiceVerifier,\n  ToggleUpstreamByNameVerifier\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/commands/utils/toggleSlices.js\n// module id = 141\n// module chunks = 0","'use strict';\n\nlet { ServiceAction: { INSTALL } } = require('../../Enums');\nlet { format } = require('../serviceName');\nlet fp = require('lodash/fp');\n\nfunction createServerRoleFilter({ serviceName, slice, serverRole }) {\n  if (!serviceName) {\n    return () => true;\n  }\n\n  let slicePredicate = slice ? x => x === slice : () => true;\n  let servicePredicate = ({ Action, Name, Slice }) =>\n    (Name === serviceName)\n    && slicePredicate(Slice)\n    && (Action === undefined || Action === INSTALL);\n  let serverRoleNamePredicate = serverRole\n    ? x => new RegExp(`^${serverRole}((-blue)|(-green))?$`).test(x)\n    : () => true;\n\n  return ({ Role, Services }) => serverRoleNamePredicate(Role) && fp.some(servicePredicate)(Services);\n}\n\nfunction describeServerRoleFilter({ environmentName, serviceName, slice, serverRole }) {\n  let print = fn => val => (val ? fn(val) : undefined);\n  let sliceOf = print(x => `${x} slice of`);\n  let service = print(x => `service ${x}`);\n  let inEnvironment = print(x => `in environment ${x}`);\n  let installedOn = print(x => `installed on server role ${x}`);\n  return ['the', sliceOf(slice), service(serviceName), inEnvironment(environmentName), installedOn(serverRole)]\n    .filter(x => x)\n    .join(' ');\n}\n\nfunction fullyQualifiedServiceNamesFor({ environmentName, serviceName, slice }) {\n  let slices = slice ? [slice] : ['blue', 'green', 'none'];\n  return fp.map(format.bind(null, environmentName, serviceName))(slices);\n}\n\nmodule.exports = {\n  createServerRoleFilter,\n  describeServerRoleFilter,\n  fullyQualifiedServiceNamesFor\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/environment-state/serverRoleFilters.js\n// module id = 142\n// module chunks = 0","'use strict';\n\nfunction format(environment, service, slice) {\n  function validate(required, regexp, name, value) {\n    if (!required && (value === null || value === undefined)) {\n      return;\n    }\n    if (!(typeof value === 'string' && regexp.test(value))) {\n      throw new Error(`${required ? 'Required' : 'Optional'} argument \"${name}\" must be a string matching ${regexp}`);\n    }\n  }\n\n  let validateOptional = validate.bind(null, false);\n  let validateRequired = validate.bind(null, true);\n  validateRequired(/^[^-]+$/, 'environment', environment);\n  validateRequired(/^[^-]+$/, 'service', service);\n  validateOptional(/^[^-]+$/, 'slice', slice);\n  let formatSlice = s => (s !== undefined && s !== null && s !== 'none' ? `-${slice}` : '');\n  return `${environment}-${service}${formatSlice(slice)}`;\n}\n\nmodule.exports = {\n  format\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/serviceName.js\n// module id = 143\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nif (process.env.NEW_RELIC_APP_NAME !== undefined) {\n  // eslint-disable-next-line global-require\n  require('newrelic'); // This line must be executed before any other call to require()\n}\n\nglobal.Promise = require('bluebird');\nlet AWS = require('aws-sdk');\nlet co = require('co');\nconst fp = require('lodash/fp');\nlet config = require('./config');\nlet logger = require('./modules/logger');\n\n// TODO conver to singleton\nlet ConfigurationProvider = require('./modules/configuration/ConfigurationProvider');\nlet checkAppPrerequisites = require('./modules/checkAppPrerequisites');\nlet cacheManager = require('./modules/cacheManager');\nconst miniStack = require('./modules/miniStack');\nconst mini = miniStack.build();\n\nprocess.on('unhandledRejection', (err) => {\n  let entry;\n  if (err instanceof Error) {\n    entry = {\n      error: {\n        message: fp.get(['message'])(err),\n        stack: fp.compose(fp.truncate({ length: 1400 }), mini, fp.get(['stack']))(err)\n      },\n      eventtype: 'UnhandledRejection'\n    };\n  } else {\n    entry = err;\n  }\n\n  logger.warn('Promise rejection was unhandled: ', entry);\n});\n\nlet servers;\n\nfunction start() {\n  co(function* () { // eslint-disable-line func-names\n    AWS.config.setPromisesDependency(Promise);\n    AWS.config.update({ region: config.get('EM_AWS_REGION') });\n    let configurationProvider = new ConfigurationProvider();\n    yield configurationProvider.init();\n    yield cacheManager.flush();\n\n    yield checkAppPrerequisites();\n    config.logBootstrapValues();\n\n    // eslint-disable-next-line global-require\n    let mainServer = require('./modules/MainServer');\n    yield mainServer.start();\n  }).catch((error) => {\n    if (error !== undefined && error.stack !== undefined) {\n      // eslint-disable-next-line no-console\n      console.error(error.stack);\n    }\n  });\n}\n\nfunction stop() {\n  servers.forEach(server => server.stop());\n}\n\nif (require.main === module) {\n  start();\n}\n\nmodule.exports = {\n  start,\n  stop\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.js\n// module id = 144\n// module chunks = 0","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/module.js\n// module id = 145\n// module chunks = 0","module.exports = require(\"nconf\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"nconf\"\n// module id = 146\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nconst VERSION_INFO = 'version.txt';\n\nlet fs = require('fs');\nlet packageInfo = require('../../package.json');\n\nfunction getVersion() {\n  if (fs.existsSync(VERSION_INFO)) {\n    return fs.readFileSync(VERSION_INFO, 'utf-8').trim();\n  } else {\n    return `${packageInfo.version}-DEV`;\n  }\n}\n\nmodule.exports = {\n  getVersion\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/config/version.js\n// module id = 147\n// module chunks = 0","module.exports = {\"name\":\"environmentmanager\",\"version\":\"6.12.2\",\"description\":\"EnvironmentManager Server\",\"homepage\":\"https://trainline.github.io/environment-manager/\",\"bugs\":{\"url\":\"https://github.com/trainline/environment-manager/issues\",\"email\":\"platform.development@thetrainline.com\"},\"config\":{\"git-tag-version\":false},\"repository\":{\"type\":\"git\",\"url\":\"https://github.com/trainline/environment-manager.git\"},\"main\":\"index.js\",\"scripts\":{\"build\":\"webpack\",\"start\":\"node lib/server.js\",\"dev\":\"webpack --watch --progress --colors --config webpack.config.dev.js\",\"lint\":\"eslint src --ext .js --quiet && tslint --project tsconfig.json src/**/*.ts\",\"test\":\"mocha-webpack --require src/test/bootstrap.js --webpack-config webpack.config.test.js --recursive \\\"src/test/**/*.js\\\"\",\"test:watch\":\"mocha-webpack --watch --require src/test/bootstrap.js --webpack-config webpack.config.test.js --recursive \\\"src/test/**/*.js\\\"\"},\"author\":{\"name\":\"Platform Development\",\"email\":\"platform.development@thetrainline.com\"},\"license\":\"Apache-2.0\",\"dependencies\":{\"activedirectory\":\"~0.7.2\",\"ajv\":\"~4.10.0\",\"async\":\"~2.1.4\",\"aws-sdk\":\"~2.151.0\",\"bluebird\":\"~3.4.6\",\"body-parser\":\"~1.15.2\",\"cache-manager\":\"~2.4.0\",\"co\":\"~4.6.0\",\"compression\":\"~1.6.2\",\"consul\":\"~0.27.0\",\"cookie-parser\":\"~1.4.3\",\"deep-freeze-strict\":\"^1.1.1\",\"es6-template-strings\":\"~2.0.1\",\"express\":\"~4.14.0\",\"express-request-id\":\"~1.3.0\",\"glob-intersection\":\"~0.1.3\",\"ioredis\":\"~2.5.0\",\"js-joda\":\"~1.1.17\",\"js-yaml\":\"~3.7.0\",\"jsonwebtoken\":\"~7.1.9\",\"later\":\"~1.2.0\",\"lodash\":\"~4.17.2\",\"md5\":\"^2.2.1\",\"moment\":\"~2.17.1\",\"moment-timezone\":\"~0.5.11\",\"ms\":\"~0.7.2\",\"nconf\":\"~0.8.4\",\"newrelic\":\"~1.36.2\",\"request\":\"~2.79.0\",\"retry\":\"~0.10.0\",\"semver\":\"~5.3.0\",\"source-map-support\":\"^0.5.0\",\"swagger-tools\":\"~0.10.1\",\"uuid\":\"^3.1.0\",\"winston\":\"~2.3.0\"},\"devDependencies\":{\"@types/core-js\":\"^0.9.43\",\"@types/node\":\"^8.0.51\",\"@types/uuid\":\"^3.4.3\",\"chai\":\"^3.5.0\",\"eslint\":\"^3.11.1\",\"eslint-config-airbnb-base\":\"^10.0.1\",\"eslint-import-resolver-typescript\":\"^1.0.2\",\"eslint-import-resolver-webpack\":\"^0.8.3\",\"eslint-plugin-dependencies\":\"^2.4.0\",\"eslint-plugin-import\":\"^2.2.0\",\"inject-loader\":\"^3.0.1\",\"mocha\":\"^3.2.0\",\"mocha-duplicate-reporter\":\"^0.2.1\",\"mocha-teamcity-reporter\":\"^1.1.1\",\"mocha-webpack\":\"^1.0.1\",\"mock-express-request\":\"^0.2.0\",\"mock-express-response\":\"^0.2.0\",\"should\":\"^11.1.1\",\"sinon\":\"^1.17.6\",\"supertest\":\"^2.0.1\",\"ts-loader\":\"^3.1.1\",\"ts-node\":\"^3.3.0\",\"tslint\":\"^5.8.0\",\"typescript\":\"^2.6.1\",\"webpack\":\"^3.8.1\",\"webpack-node-externals\":\"^1.6.0\",\"webpack-shell-plugin\":\"^0.5.0\"},\"engines\":{\"node\":\">=6.7.0\",\"npm\":\">=3.10.3\"},\"os\":[\"darwin\",\"linux\",\"win32\"],\"jshintConfig\":{\"esversion\":6,\"globals\":{\"setInterval\":true,\"Buffer\":true,\"console\":true,\"process\":true,\"global\":true,\"__dirname\":true,\"require\":true,\"module\":true,\"describe\":true,\"before\":true,\"after\":true,\"it\":true},\"undef\":true,\"strict\":\"global\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./package.json\n// module id = 148\n// module chunks = 0","module.exports = require(\"winston\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"winston\"\n// module id = 149\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet config = require('../../config');\nlet LocalConfigurationProvider = require('./LocalConfigurationProvider');\nlet S3ConfigurationProvider = require('./S3ConfigurationProvider');\nlet logger = require('../logger');\n\n\nmodule.exports = function ConfigurationProvider() {\n  this.init = function () {\n    let configurationProvider = (() => {\n      if (config.get('IS_PRODUCTION')) {\n        return new S3ConfigurationProvider();\n      } else {\n        return new LocalConfigurationProvider();\n      }\n    })();\n\n    function loadConfiguration() {\n      return configurationProvider.get()\n        .then(configuration => config.setUserValue('local', configuration), logger.error.bind(logger));\n    }\n\n    return loadConfiguration();\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/configuration/ConfigurationProvider.js\n// module id = 150\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nconst console = require('console');\nconst fs = require('fs');\nconst Promise = require('bluebird');\nconst findInAncestor = require('../find-in-ancestor');\n\nconst readFile = Promise.promisify(fs.readFile);\nconst configFileNotFoundMessage = `Please create configuration.json to start the app in development mode.\nYou can find sample configuration file in configuration.sample.json`;\n\nmodule.exports = function LocalConfigurationProvider() {\n  this.get = () =>\n    readFile(findInAncestor('configuration.json', __dirname))\n      .then(text => JSON.parse(text))\n      .catch((error) => {\n        if (error.code === 'ENOENT') {\n          console.log(configFileNotFoundMessage);\n        }\n        return Promise.reject(error);\n      });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/configuration/LocalConfigurationProvider.js\n// module id = 151\n// module chunks = 0","module.exports = require(\"console\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"console\"\n// module id = 152\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet masterAccountClient = require('../amazon-client/masterAccountClient');\nlet config = require('../../config');\n\nconst S3_BUCKET = config.get('EM_AWS_S3_BUCKET');\nconst S3_KEY = config.get('EM_AWS_S3_KEY');\n\nmodule.exports = function S3ConfigurationProvider() {\n  this.get = function getConfigurationFromS3() {\n    let parameters = {\n      Bucket: S3_BUCKET,\n      Key: S3_KEY\n    };\n\n    return masterAccountClient\n      .createS3Client()\n      .then(client => client.getObject(parameters).promise())\n      .then(object => JSON.parse(object.Body.toString('utf8')));\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/configuration/S3ConfigurationProvider.js\n// module id = 153\n// module chunks = 0","'use strict';\n\nlet co = require('co');\nlet permissionsDb = require('./data-access/permissions');\nlet logger = require('./logger');\nlet guid = require('uuid/v1');\nlet config = require('../config');\n\nfunction checkAppPrerequisites() {\n  return co(function* () {\n    logger.info('Checking app prerequisites..');\n\n    let permissionsExist = yield checkIfPermissionsExist();\n\n    if (!permissionsExist) {\n      yield insertDefaultAdminPermission();\n    }\n\n    logger.info('App prerequisites satisfied.');\n  });\n}\n\nfunction checkIfPermissionsExist() {\n  return co(function* () {\n    let results = yield permissionsDb.scan({ Limit: 1 });\n    return !!(results && results.length);\n  });\n}\n\nfunction insertDefaultAdminPermission() {\n  return co(function* () {\n    logger.info('Inserting default admin permission.');\n    let localConfig = config.getUserValue('local');\n    let defaultAdmin = localConfig.authentication.defaultAdmin;\n\n    if (!defaultAdmin) {\n      throw new Error('The value \"authentication.defaultAdmin\" was not found in config. This is required to create the first permission.');\n    }\n\n    yield permissionsDb.create({\n      record: {\n        Name: defaultAdmin,\n        Permissions: [{ Resource: '**', Access: 'ADMIN' }]\n      },\n      metadata: {\n        TransactionID: guid(),\n        User: 'system'\n      }\n    });\n  });\n}\n\n// eslint-disable-next-line arrow-body-style\nmodule.exports = () => {\n  return co(function* () {\n    return checkAppPrerequisites();\n  });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/checkAppPrerequisites.js\n// module id = 154\n// module chunks = 0","module.exports = require(\"deep-freeze-strict\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"deep-freeze-strict\"\n// module id = 155\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet { updateAuditMetadata } = require('./dynamoAudit');\nlet { compareAndSetVersionOnUpdate, setVersionOnUpdate } = require('./dynamoVersion');\nlet { flow } = require('lodash/fp');\n\nfunction softDelete({ key, metadata, expectedVersion }) {\n  let updateExpression = ['update', ['set', ['at', '__Deleted'], ['val', true]]];\n  let updateWithDeleteMarker = expectedVersion\n    ? flow(\n      updateAuditMetadata,\n      UpdateExpression => ({\n        key,\n        expressions: { UpdateExpression },\n        expectedVersion\n      }),\n      compareAndSetVersionOnUpdate\n    )\n    : flow(\n      updateAuditMetadata,\n      UpdateExpression => ({\n        key,\n        expressions: { UpdateExpression }\n      }),\n      setVersionOnUpdate\n    );\n  return updateWithDeleteMarker({ key, metadata, updateExpression });\n}\n\nmodule.exports = {\n  softDelete\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/data-access/dynamoSoftDelete.js\n// module id = 156\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet dynamoTable = require('./dynamoTable');\nlet cacheManager = require('../cacheManager');\nlet logger = require('../logger');\n\nfunction logError(message, tableName) {\n  return (error) => {\n    logger.error(`${message}. table=${tableName}`);\n    logger.error(error);\n  };\n}\n\nfunction dynamoTableCache(logicalTableName, { ttl }) {\n  let cache = cacheManager.create(logicalTableName, dynamoTable.scan, { stdTTL: ttl });\n\n  function create(tableName, createSpec) {\n    return dynamoTable.create(tableName, createSpec)\n      .then(() => cache.del(tableName).catch(logError('Could not invalidate cache', tableName)));\n  }\n\n  function $delete(tableName, deleteSpec) {\n    return dynamoTable.delete(tableName, deleteSpec)\n      .then(() => cache.del(tableName).catch(logError('Could not invalidate cache', tableName)));\n  }\n\n  function get(tableName, key) {\n    return dynamoTable.get(tableName, key);\n  }\n\n  function query(tableName, expressions) {\n    return dynamoTable.query(tableName, expressions);\n  }\n\n  function replace(tableName, replaceSpec) {\n    return dynamoTable.replace(tableName, replaceSpec)\n      .then(() => cache.del(tableName).catch(logError('Could not invalidate cache', tableName)));\n  }\n\n  function scan(tableName, filter) {\n    if (filter) {\n      return dynamoTable.scan(tableName, filter);\n    } else {\n      return cache.get(tableName).catch((error) => {\n        logError('Could not get from cache', tableName)(error);\n        return dynamoTable.scan(tableName);\n      });\n    }\n  }\n\n  function update(tableName, updateSpec) {\n    return dynamoTable.update(tableName, updateSpec)\n      .then(() => cache.del(tableName).catch(logError('Could not invalidate cache', tableName)));\n  }\n\n  return {\n    create,\n    delete: $delete,\n    get,\n    query,\n    replace,\n    scan,\n    update\n  };\n}\n\nmodule.exports = dynamoTableCache;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/data-access/dynamoTableCache.js\n// module id = 157\n// module chunks = 0","module.exports = require(\"cache-manager\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"cache-manager\"\n// module id = 158\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet fp = require('lodash/fp');\nlet logger = require('../logger');\nlet memoize = require('../memoize');\nlet Redis = require('ioredis');\nlet timers = require('timers');\n\nconst NOT_FOUND = undefined;\n\nfunction delay(milliseconds) {\n  return new Promise(resolve => setTimeout(resolve, milliseconds));\n}\n\nfunction timeout(t) {\n  return delay(t).then(() => Promise.reject(new Error(`operation timed out after ${t} milliseconds`)));\n}\n\nfunction logError(error) {\n  logger.error(error);\n  return NOT_FOUND;\n}\n\nfunction circuitBreaker(policy) {\n  let state = 'CLOSED';\n  let failures = 0;\n  function open() {\n    state = 'OPEN';\n    timers.setTimeout(() => { state = 'HALF OPEN'; }, policy.resetperiod);\n  }\n  function close() {\n    state = 'CLOSED';\n  }\n  return (fn) => {\n    if (state === 'OPEN') {\n      return Promise.reject(new Error('Circuit Breaker open.'));\n    } else if (state === 'HALF OPEN') {\n      return Promise.resolve(fn()).then((x) => { close(); return x; }, (e) => { open(); return Promise.reject(e); });\n    } else {\n      return Promise.resolve(fn()).catch((e) => {\n        failures += 1;\n        timers.setTimeout(() => { failures -= 1; }, policy.failurettl);\n        if (failures > policy.maxfailures) {\n          open();\n        }\n        return Promise.reject(e);\n      });\n    }\n  };\n}\n\nfunction connectToRedis({ address, port }) {\n  let client = new Redis({\n    host: address,\n    port,\n    lazyConnect: true,\n    connectTimeout: 1000,\n    reconnectOnError: () => {\n      return 2;\n    }\n  });\n  let events = ['close', 'connect', 'end', 'error', 'ready', 'reconnecting'];\n  events.forEach((name) => {\n    client.on(name, (e) => {\n      logger.debug(`${name}: redis ${address}:${port}`);\n      if (e) {\n        logger.debug(e);\n      }\n    });\n  });\n  client.on('error', e => logger.error(e));\n  return client;\n}\n\nfunction encryptedRedisStore(args) {\n  const WRITE_TIMEOUT = args.writeTimeout || 1000;\n  const READ_TIMEOUT = args.readTimeout || 1000;\n\n  let redis = connectToRedis({ address: args.host, port: args.port });\n  let breaker = circuitBreaker({ failurettl: 1000, maxfailures: 2, resetperiod: 1000 });\n  let id = x => x;\n  let keyToStore = fp.get(['keyTransform', 'toStore'])(args) || id;\n  let valueToStore = fp.get(['valueTransform', 'toStore'])(args) || fp.flow(JSON.stringify, str => new Buffer(str));\n  let valueFromStore = fp.get(['valueTransform', 'fromStore'])(args) || fp.flow(buf => buf.toString(), JSON.parse);\n\n  function del(key, options, callback) {\n    let cb = (typeof options === 'function') ? options : callback;\n\n    let skey = keyToStore(key);\n    let promise = breaker(() => Promise.race([timeout(WRITE_TIMEOUT), redis.del(skey)]))\n      .catch((error) => {\n        logger.error(`Redis operation failed: DEL key=${key}`);\n        return logError(error);\n      });\n\n    if (cb) {\n      return promise.then(cb.bind(null, null), cb.bind(null));\n    } else {\n      return promise;\n    }\n  }\n\n  function get(key, options, callback) {\n    let cb = (typeof options === 'function') ? options : callback;\n\n    let skey = keyToStore(key);\n\n    let promise = breaker(() => Promise.race([timeout(READ_TIMEOUT), redis.getBuffer(skey)]))\n      .then(value => (value ? valueFromStore(value) : NOT_FOUND), logError)\n      .catch((error) => {\n        logger.error(`Redis operation failed: GET key=${key}`);\n        return logError(error);\n      });\n\n    if (cb) {\n      return promise.then(cb.bind(null, null), cb.bind(null));\n    } else {\n      return promise;\n    }\n  }\n\n  function keys(cb) {\n    let error = new Error('Encrypted Redis store does not support the \"keys\" operation');\n    if (cb) {\n      return cb(error);\n    } else {\n      return Promise.reject(error);\n    }\n  }\n\n  function reset(cb) {\n    let promise = breaker(() => Promise.race([timeout(WRITE_TIMEOUT), redis.flushdb()]))\n      .catch((error) => {\n        logger.error('Redis operation failed: FLUSHDB');\n        return logError(error);\n      });\n\n    if (cb) {\n      return promise.then(cb.bind(null, null), cb.bind(null));\n    } else {\n      return promise;\n    }\n  }\n\n  function set(key, value, options, callback) {\n    let cb = (typeof options === 'function') ? options : callback;\n    let opts = (typeof options === 'function') ? {} : (options || {});\n\n    let skey = keyToStore(key);\n    let svalue = valueToStore(value);\n    let redisOperation = (() => {\n      let ttl = fp.get('ttl')(opts) || args.ttl;\n      if (ttl) {\n        return () => redis.setexBuffer(skey, ttl, svalue);\n      } else {\n        return () => redis.setBuffer(skey, svalue);\n      }\n    })();\n\n    let promise = breaker(() => Promise.race([timeout(WRITE_TIMEOUT), redisOperation()]))\n      .catch((error) => {\n        logger.error(`Redis operation failed: SET key=${key}`);\n        return logError(error);\n      });\n\n    if (cb) {\n      return promise.then(cb.bind(null, null), cb.bind(null));\n    } else {\n      return promise;\n    }\n  }\n\n  return {\n    del,\n    get,\n    keys,\n    reset,\n    set\n  };\n}\n\nmodule.exports = {\n  create: memoize(encryptedRedisStore)\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/data-access/cacheManagerEncryptedRedis.js\n// module id = 159\n// module chunks = 0","module.exports = require(\"crypto\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"crypto\"\n// module id = 160\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet path = require('path');\nlet express = require('express');\nlet bodyParser = require('body-parser');\nlet cookieParser = require('cookie-parser');\nlet logger = require('./logger');\nlet config = require('../config');\nlet compression = require('compression');\nlet expressRequestId = require('express-request-id');\nlet ServerFactoryConfiguration = require('./serverFactoryConfiguration');\nlet serverFactoryConfiguration = new ServerFactoryConfiguration();\nlet tokenAuthentication = require('./authentications/tokenAuthentication');\nlet cookieAuthentication = require('./authentications/cookieAuthentication');\nlet authentication = require('./authentication');\nlet deploymentMonitorScheduler = require('./monitoring/DeploymentMonitorScheduler');\nlet apiV1 = require('../api/v1');\nlet initialData = require('../api/em-internal/controllers/initial-data');\nlet httpServerFactory = require('./http-server-factory');\nlet loggingMiddleware = require('./express-middleware/loggingMiddleware');\nlet deprecateMiddleware = require('./express-middleware/deprecateMiddleware');\nlet cacheRouter = require('./cacheRouter');\n\nconst APP_VERSION = require('../config').get('APP_VERSION');\n\nlet serverInstance;\n\nfunction createExpressApp() {\n  /* eslint-disable global-require */\n  let httpHealthChecks = require('./httpHealthChecks');\n  let routes = {\n    home: require('../routes/home'),\n    deploymentNodeLogs: require('../routes/deploymentNodeLogs')\n  };\n  /* eslint-enable */\n\n  let app = express();\n  /* enable the 'trust proxy' setting so that we resolve\n   * the client IP address when app is behind HTTP Proxy\n   * http://expressjs.com/en/guide/behind-proxies.html\n   * */\n  app.enable('trust proxy');\n\n  let loggerMiddleware = loggingMiddleware.loggerMiddleware(logger);\n  let errorLoggerMiddleware = loggingMiddleware.errorLoggerMiddleware(logger);\n\n  return apiV1().then(({\n    swaggerAuthorizer,\n    swaggerBasePath,\n    swaggerErrorHandler,\n    swaggerMetadata,\n    swaggerRouter,\n    swaggerUi,\n    swaggerValidator,\n    swaggerNewRelic\n  }) => {\n    app.use(expressRequestId());\n    app.use(compression());\n    app.use(cookieParser());\n    app.use(bodyParser.urlencoded({ extended: false, limit: '50mb' }));\n    app.use(bodyParser.json({ extended: false, limit: '50mb' }));\n\n    // Deprecate routes that are part of the pre-v1 API.\n    app.use('/api', deprecateMiddleware(req => (req.originalUrl.startsWith(swaggerBasePath)\n      ? undefined\n      : `this operation will be removed after ${new Date(2017, 2, 17).toUTCString()}`)));\n\n    /* notice how the router goes after the logger.\n     * https://www.npmjs.com/package/express-winston#request-logging */\n    app.use(loggerMiddleware);\n\n    const PUBLIC_DIR = config.get('PUBLIC_DIR');\n    logger.info(`Serving static files from \"${PUBLIC_DIR}\"`);\n    logger.info(`Serving js files from \"${__dirname}\"`);\n\n    let staticPaths = ['*.js', '*.css', '*.html', '*.ico', '*.gif',\n      '*.woff2', '*.ttf', '*.woff', '*.svg', '*.eot', '*.jpg', '*.png', '*.map'];\n\n    app.get(staticPaths, authentication.allowUnknown, express.static(PUBLIC_DIR));\n    app.get('/', express.static(PUBLIC_DIR));\n\n    app.get('*.js', authentication.allowUnknown, express.static(path.resolve(__dirname, '../shared'))); /* HACK ALERT */\n\n    app.use('/schema', authentication.allowUnknown, express.static(`${PUBLIC_DIR}/schema`));\n\n    app.use('/diagnostics/healthchecks', httpHealthChecks.router);\n    app.use('/flushcache', cacheRouter.router);\n\n    app.use(cookieAuthentication.middleware);\n    app.use(tokenAuthentication.middleware);\n\n    app.get('/deployments/nodes/logs', authentication.denyUnauthorized, routes.deploymentNodeLogs);\n\n    app.get('/em/initial-data', initialData);\n\n    app.use(swaggerMetadata);\n    app.use(swaggerValidator);\n    app.use(swaggerBasePath, [swaggerNewRelic, swaggerAuthorizer]);\n    app.use(swaggerRouter);\n    app.use(swaggerUi);\n    app.use(errorLoggerMiddleware);\n    app.use(swaggerErrorHandler);\n\n    return Promise.resolve(app);\n  });\n}\n\nfunction createServer(app) {\n  let parameters = {\n    port: serverFactoryConfiguration.getPort()\n  };\n\n  return httpServerFactory.create(app, parameters).then((server) => {\n    logger.info(`Main server created using ${httpServerFactory.constructor.name} service.`);\n    logger.info(`Main server listening at port ${parameters.port}.`);\n    return server;\n  });\n}\n\nfunction initializeServer(server) {\n  serverInstance = server;\n  deploymentMonitorScheduler.start();\n  logger.info(`EnvironmentManager v.${APP_VERSION} started!`);\n}\n\nmodule.exports = {\n  start: () => {\n    return createExpressApp()\n      .then(createServer)\n      .then(initializeServer);\n  },\n  stop: () => {\n    serverInstance.close();\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/MainServer.js\n// module id = 161\n// module chunks = 0","module.exports = require(\"body-parser\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"body-parser\"\n// module id = 162\n// module chunks = 0","module.exports = require(\"cookie-parser\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"cookie-parser\"\n// module id = 163\n// module chunks = 0","module.exports = require(\"compression\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"compression\"\n// module id = 164\n// module chunks = 0","module.exports = require(\"express-request-id\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"express-request-id\"\n// module id = 165\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet assert = require('assert');\nlet config = require('../config');\n\nmodule.exports = function ServerFactoryConfiguration() {\n  this.getPort = () => configuration.port;\n\n  let loadConfiguration = function () {\n    let configuration = config.getUserValue('local');\n\n    assert(configuration.server, 'missing \\'server\\' field in configuration');\n    assert(configuration.server.port, 'missing \\'server.port\\' field in configuration');\n    return {\n      port: configuration.server.port\n    };\n  };\n\n  let configuration = loadConfiguration();\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/serverFactoryConfiguration.js\n// module id = 166\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet userService = require('../user-service');\n\nconst PATTERN = /bearer\\s+(.*)/i;\n\nmodule.exports = {\n  middleware(req, res, next) {\n    if (req.user) return next();\n\n    let authorization = req.headers.authorization;\n    if (!authorization) return next();\n\n    let match = PATTERN.exec(authorization);\n    if (!match) return next();\n\n    return userService.getUserByToken(match[1])\n      .then((user) => {\n        req.user = user;\n        req.authenticatedBy = 'bearer';\n        return next();\n      }, (error) => {\n        res.status(401);\n        res.send(error.message);\n      });\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/authentications/tokenAuthentication.js\n// module id = 167\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet ms = require('ms');\nlet User = require('../../../shared/user');\nlet utils = require('../utilities');\nlet ActiveDirectoryError = require('../errors/ActiveDirectoryError.class');\n\nfunction authenticateUser(credentials, duration) {\n  if (!credentials.username) {\n    return Promise.reject(new Error('User must belong to \"corp\" domain.'));\n  }\n  let name = credentials.username.toLowerCase().replace('corp\\\\', '');\n  let groups = [];\n  let permissions = [{ Access: 'ADMIN', Resource: '**' }];\n  let expiration = getExpiration(duration);\n  let user = User.new(name, expiration, groups, permissions);\n  let userJson = JSON.stringify(user.toJson());\n  return Promise.resolve(new Buffer(userJson).toString('base64'));\n}\n\nfunction getUserByToken(token) {\n  let userJson = new Buffer(token, 'base64').toString('utf8');\n  let data = utils.safeParseJSON(userJson);\n  if (!data) return Promise.reject(new ActiveDirectoryError('Wrong cookie'));\n  return Promise.resolve(User.new(data.name, data.expiration, data.groups, data.permissions));\n}\n\nfunction signOut() {\n  return Promise.resolve();\n}\n\nfunction getExpiration(duration) {\n  let durationMs = ms(duration);\n  let dateNow = new Date();\n  let dateEnd = new Date(dateNow.setMilliseconds(dateNow.getMilliseconds() + durationMs));\n  return dateEnd.getTime();\n}\n\nmodule.exports = {\n  authenticateUser,\n  getUserByToken,\n  signOut\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/user-service/userService.mock.js\n// module id = 168\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet _ = require('lodash');\nlet ms = require('ms');\nlet jsonwebtoken = require('jsonwebtoken');\nlet guid = require('uuid/v1');\nlet co = require('co');\nlet User = require('../../../shared/user');\nlet UserRolesProvider = require('../userRolesProvider');\nlet activeDirectoryAdapter = require('../active-directory-adapter');\nlet logger = require('../logger');\nlet md5 = require('md5');\nlet UserSessionStore = require('../userSessionStore');\nlet Promise = require('bluebird');\nlet SslComponentsRepository = require('../sslComponentsRepository');\n\nlet userRolesProvider = new UserRolesProvider();\n\nmodule.exports = function UserService() {\n  let sslComponentsRepository = new SslComponentsRepository();\n\n  this.authenticateUser = authenticateUser;\n  this.getUserByToken = getUserByToken;\n  this.signOut = signOut;\n\n  function authenticateUser(credentials, duration) {\n    return co(function* () {\n      let scope = credentials.scope || 'api';\n      let durationInMillis = ms(duration);\n      let expiration = getExpiration(durationInMillis);\n      let userSession = yield authenticate(credentials, expiration, scope);\n\n      let session = {\n        sessionId: userSession.sessionId,\n        user: userSession.user.toJson(),\n        password: md5(credentials.password)\n      };\n\n      yield storeSession(session, scope, durationInMillis);\n      return yield createSessionToken(session, duration);\n    }).catch((err) => {\n      logger.error(err);\n      throw err;\n    });\n  }\n\n  function authenticate(credentials, expiration, scope) {\n    return co(function* () {\n      let session = yield getExistingSessionForUser(credentials, scope);\n\n      if (session) {\n        if (session.password === md5(credentials.password)) {\n          return {\n            sessionId: session.sessionId,\n            user: User.parse(session.user)\n          };\n        }\n      }\n\n      let activeDirectoryUser = yield activeDirectoryAdapter.authorizeUser(credentials);\n\n      let name = activeDirectoryUser.name;\n      let groups = activeDirectoryUser.roles;\n      let permissions = yield userRolesProvider.getPermissionsFor(_.union([name], groups));\n\n      return {\n        sessionId: guid(),\n        user: User.new(name, expiration, groups, permissions)\n      };\n    });\n  }\n\n  function signOut(encryptedToken) {\n    return co(function* () {\n      let token = yield readToken(encryptedToken);\n      return yield deleteSessionFromStore(token.sessionId);\n    });\n  }\n\n  function getExistingSessionForUser(credentials, scope) {\n    return co(function* () {\n      let store = yield getStore();\n      let userScopeSessionKey = getLatestSessionIdForUserAndScope(credentials.username, scope);\n      let sessionId = yield store.get(userScopeSessionKey);\n      if (sessionId) {\n        return yield getSessionFromStore(sessionId);\n      }\n      return null;\n    });\n  }\n\n  function createSessionToken(session, duration) {\n    return co(function* () {\n      let sslComponents = yield sslComponentsRepository.get();\n      let options = {\n        // TODO: Look into whether can upgrade this algorithm\n        algorithm: 'RS256',\n        expiresIn: duration\n      };\n      let token = { sessionId: session.sessionId };\n\n      return createSignedWebToken(token, sslComponents.privateKey, options);\n    });\n  }\n\n  function getUserByToken(encryptedToken) {\n    return co(function* () {\n      let token = yield readToken(encryptedToken);\n      let session = yield getSessionFromStore(token.sessionId);\n      return User.parse(session.user);\n    });\n  }\n\n  function readToken(encryptedToken) {\n    return co(function* () {\n      let sslComponents = yield sslComponentsRepository.get();\n      let options = {\n        algorithm: 'RS256',\n        ignoreExpiration: false\n      };\n      return verifyAndDecryptWebToken(encryptedToken, sslComponents.certificate, options);\n    });\n  }\n\n  let createSignedWebToken = jsonwebtoken.sign;\n  let verifyAndDecryptWebToken = Promise.promisify(jsonwebtoken.verify);\n\n  function getExpiration(durationMs) {\n    let dateNow = new Date();\n    let dateEnd = new Date(dateNow.setMilliseconds(dateNow.getMilliseconds() + durationMs));\n    return dateEnd.getTime();\n  }\n\n  function storeSession(session, scope, duration) {\n    return co(function* () {\n      let store = yield getStore();\n      yield store.psetex(getSessionKey(session.sessionId), duration, session);\n      yield store.psetex(getLatestSessionIdForUserAndScope(session.user.name, scope), duration, session.sessionId);\n    });\n  }\n\n  function getSessionFromStore(sessionId) {\n    return co(function* () {\n      let sessionKey = getSessionKey(sessionId);\n      let store = yield getStore();\n      return yield store.get(sessionKey);\n    });\n  }\n\n  function deleteSessionFromStore(sessionId) {\n    return co(function* () {\n      let sessionKey = getSessionKey(sessionId);\n      let store = yield getStore();\n      return yield store.del(sessionKey);\n    });\n  }\n\n  function getStore() {\n    return UserSessionStore.get();\n  }\n\n  function getSessionKey(sessionId) {\n    return `session-${sessionId}`;\n  }\n\n  function getLatestSessionIdForUserAndScope(username, scope) {\n    return `latest-${scope}-session-${md5(username)}`;\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/user-service/userService.prod.js\n// module id = 169\n// module chunks = 0","module.exports = require(\"jsonwebtoken\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"jsonwebtoken\"\n// module id = 170\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet _ = require('lodash');\nlet permissionsDb = require('./data-access/permissions');\n\nmodule.exports = function UserRolesProvider() {\n  this.getPermissionsFor = (names) => {\n    if (!names) {\n      return Promise.resolve([]);\n    }\n\n    let tasks = names.map(getPermissions);\n\n    return Promise.all(tasks).then((results) => {\n      let users = _.flatten(results);\n      let permissions = _.flatten(users.map(user => user.Permissions));\n\n      return permissions;\n    });\n  };\n\n  this.getFromActiveDirectoryGroupMembership = (groupMembership) => {\n    let roles = [];\n\n    if (groupMembership.indexOf('GG-APP-EnvironmentManager-ReadOnly') >= 0) {\n      addIfMissing(roles, 'view');\n    }\n\n    if (groupMembership.indexOf('GG-APP-EnvironmentManager-Toggle') >= 0) {\n      addIfMissing(roles, 'view');\n      addIfMissing(roles, 'toggle');\n    }\n\n    if (groupMembership.indexOf('GG-APP-EnvironmentManager-Editor') >= 0) {\n      addIfMissing(roles, 'view');\n      addIfMissing(roles, 'toggle');\n      addIfMissing(roles, 'edit');\n    }\n\n    if (groupMembership.indexOf('GG-APP-EnvironmentManager-Test') >= 0) {\n      addIfMissing(roles, 'view');\n      addIfMissing(roles, 'toggle');\n      addIfMissing(roles, 'edit');\n    }\n\n    return roles;\n  };\n\n  let addIfMissing = function (roles, roleName) {\n    if (roles.indexOf(roleName) >= 0) return;\n    roles.push(roleName);\n  };\n\n  let getPermissions = function (name) {\n    return permissionsDb.get({ Name: name })\n      .then(result => (result === null ? [] : [result]));\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/userRolesProvider.js\n// module id = 171\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet config = require('../../config');\nconst mock = require('./activeDirectoryAdapter.mock.js');\nconst prod = require('./activeDirectoryAdapter.prod.js');\n\nlet Implementation = config.get('IS_PRODUCTION') ? prod : mock;\n\nmodule.exports = new Implementation();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/active-directory-adapter/index.js\n// module id = 172\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nmodule.exports = function ActiveDirectoryAdapter() {\n  this.configure = () => { };\n\n  this.authorizeUser = (credentials) => {\n    let roles = [];\n\n    switch (credentials.username) {\n      case 'jbloggs':\n        roles.push('GG-APP-EnvironmentManager-Test');\n        break;\n\n      case 'tuser':\n        roles.push('GG-APP-EnvironmentManager-Test');\n        roles.push('GG-APP-EnvironmentManager-Test2');\n        break;\n\n      default:\n        roles.push('GG-APP-EnvironmentManager-Admin');\n        break;\n    }\n\n    let name = credentials.username.toLowerCase();\n    return Promise.resolve({ name, roles });\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/active-directory-adapter/activeDirectoryAdapter.mock.js\n// module id = 173\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet co = require('co');\nlet Promise = require('bluebird');\nlet ActiveDirectory = require('activedirectory');\nlet ActiveDirectoryError = require('../errors/ActiveDirectoryError.class');\nlet InvalidCredentialsError = require('../errors/InvalidCredentialsError.class');\nlet ActiveDirectoryAdapterConfiguration = require('./activeDirectoryAdapterConfiguration');\n\nlet activeDirectoryAdapterConfiguration = new ActiveDirectoryAdapterConfiguration();\n\nmodule.exports = function ActiveDirectoryAdapter() {\n  let configuration = activeDirectoryAdapterConfiguration.get();\n  let adClient = Promise.promisifyAll(new ActiveDirectory(configuration));\n\n  function standardizeError(error) {\n    switch (error.name) {\n      case 'InvalidCredentialsError':\n        return new InvalidCredentialsError('Provided CORP username or password are invalid.');\n      default:\n        return new ActiveDirectoryError(error.message);\n    }\n  }\n\n  // eslint-disable-next-line arrow-body-style\n  this.authorizeUser = (credentials) => {\n    return co(function* () {\n      // Authenticate ActiveDirectory via its credentials\n      yield adClient.authenticateAsync(credentials.username, credentials.password);\n\n      // Get the user information\n      let segments = credentials.username.split('\\\\');\n\n      let username = segments.length < 2 ? segments[0] : segments[1];\n\n      let groups = yield adClient.getGroupMembershipForUserAsync(username);\n\n      let activeDirectoryUser = {\n        name: username,\n        roles: groups.map(group => group.cn)\n      };\n\n      return activeDirectoryUser;\n    }).catch((error) => {\n      throw standardizeError(error);\n    });\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/active-directory-adapter/activeDirectoryAdapter.prod.js\n// module id = 174\n// module chunks = 0","module.exports = require(\"activedirectory\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"activedirectory\"\n// module id = 175\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet util = require('util');\nlet BaseError = require('./BaseError.class');\n\nmodule.exports = function InvalidCredentialsError(message, innerError) {\n  this.name = this.constructor.name;\n  this.message = message;\n  this.innerError = innerError;\n\n  Error.captureStackTrace(this, this.constructor);\n};\n\nutil.inherits(module.exports, BaseError);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/errors/InvalidCredentialsError.class.js\n// module id = 176\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet config = require('../../config');\n\nmodule.exports = function ActiveDirectoryAdapterConfiguration() {\n  let configuration;\n\n  this.get = function getConfiguration() {\n    if (!configuration) {\n      configuration = config.getUserValue('local').ActiveDirectory;\n    }\n\n    return configuration;\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/active-directory-adapter/activeDirectoryAdapterConfiguration.js\n// module id = 177\n// module chunks = 0","module.exports = require(\"md5\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"md5\"\n// module id = 178\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet logger = require('../logger');\nlet Redis = require('ioredis');\nlet config = require('../../config');\nlet co = require('co');\nlet emCrypto = require('../emCrypto');\nlet masterAccountClient = require('../amazon-client/masterAccountClient');\n\nconst EM_REDIS_ADDRESS = config.get('EM_REDIS_ADDRESS');\nconst EM_REDIS_PORT = config.get('EM_REDIS_PORT');\nconst EM_REDIS_CRYPTO_KEY = config.get('EM_REDIS_CRYPTO_KEY');\nconst EM_REDIS_CRYPTO_KEY_S3_BUCKET = config.get('EM_REDIS_CRYPTO_KEY_S3_BUCKET');\nconst EM_REDIS_CRYPTO_KEY_S3_KEY = config.get('EM_REDIS_CRYPTO_KEY_S3_KEY');\n\nfunction createStore(db) {\n  return co(function* () {\n    let client = connectToRedis(db);\n    let cryptoKey = yield getCryptoKey();\n\n    return createEncryptedRedisStore(client, cryptoKey);\n  });\n}\n\nfunction createEncryptedRedisStore(client, cryptoKey) {\n  let TIMEOUT = 5000;\n\n  function status() {\n    return client.status;\n  }\n\n  function get(key) {\n    return withTimeout(client.getBuffer(key).then((value) => {\n      if (value === null) return null;\n      return decrypt(value);\n    }));\n  }\n\n  function del(key) {\n    return withTimeout(client.del(key));\n  }\n\n  function psetex(key, ttl, value) {\n    return withTimeout(client.psetexBuffer(key, ttl, encrypt(value)));\n  }\n\n  function withTimeout(promise) {\n    return Promise.race([timeout(TIMEOUT), promise]);\n  }\n\n  function timeout(t) {\n    return delay(t).then(() => Promise.reject(new Error(`operation timed out after ${t} milliseconds`)));\n  }\n\n  function delay(milliseconds) {\n    return new Promise(resolve => setTimeout(resolve, milliseconds));\n  }\n\n  function encrypt(plaintext) {\n    return emCrypto.encrypt(cryptoKey, new Buffer(JSON.stringify(plaintext)));\n  }\n\n  function decrypt(ciphertext) {\n    return JSON.parse(emCrypto.decrypt(cryptoKey, ciphertext).toString());\n  }\n\n  return {\n    status,\n    get,\n    del,\n    psetex\n  };\n}\n\nfunction connectToRedis(db) {\n  let client = new Redis({\n    host: EM_REDIS_ADDRESS,\n    port: EM_REDIS_PORT,\n    db,\n    lazyConnect: true,\n    connectTimeout: 1000,\n    reconnectOnError: () => {\n      return 2;\n    }\n  });\n\n  let events = ['close', 'connect', 'end', 'error', 'ready', 'reconnecting'];\n  events.forEach((name) => {\n    client.on(name, (e) => {\n      logger.debug(`${name}: redis ${EM_REDIS_ADDRESS}:${EM_REDIS_PORT}`);\n      if (e) {\n        logger.debug(e);\n      }\n    });\n  });\n  client.on('error', e => logger.error(e));\n  return client;\n}\n\nfunction getCryptoKey() {\n  if (EM_REDIS_CRYPTO_KEY) {\n    return Promise.resolve(EM_REDIS_CRYPTO_KEY);\n  } else if (EM_REDIS_CRYPTO_KEY_S3_BUCKET && EM_REDIS_CRYPTO_KEY_S3_KEY) {\n    return masterAccountClient.createS3Client().then(s3 => s3.getObject({\n      Bucket: EM_REDIS_CRYPTO_KEY_S3_BUCKET,\n      Key: EM_REDIS_CRYPTO_KEY_S3_KEY\n    }).promise()).then(rsp => rsp.Body, (error) => {\n      logger.warn(`Failed to get Redis Crypto Key: Bucket=${EM_REDIS_CRYPTO_KEY_S3_BUCKET} Key=${EM_REDIS_CRYPTO_KEY_S3_KEY}`);\n      logger.error(error);\n      return Promise.resolve();\n    });\n  } else {\n    return Promise.resolve();\n  }\n}\n\nmodule.exports = {\n  createStore\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/data-access/encryptedRedisStore.js\n// module id = 179\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nmodule.exports = function SSLComponentsRepository() {\n  this.get = function () {\n    return Promise.resolve({\n      privateKey: `-----BEGIN RSA PRIVATE KEY-----\nMIICXAIBAAKBgQCKqo+T1gWfmXO5sxVHECRmIK109holtPp9PnXWH01SP7zY1Syo\n5MzLnewmsdXqlkp7jMQdAi4fDcbb4VCA9PX3roOcHQWL+tjCaLMAJ/24yff65cnL\nYSpWSDSF79ijxPmEBlml273KT/+t53BIzGK5SDBoh3JMtjFTLz9HH+PFWwIDAQAB\nAoGAEZmAS6U4ZX9WftVJ+BEGbafsHBI4U1zbBhZtYlXqvGu2jlbQKkeP7rAGjwq3\nOeUFYxUEtyHVtL9M5A9+5j8xEKTCmrhCs0MeN3VccmvB6ePlNM49KAA5fZcf7xee\nIIibarSqQwh5VAnLvb08KBNYk/rtDT9piMMAEl2uR5sJXwECQQDGti5Ny7Dm+vCZ\nuztRAwBLUbtis/O2Jw7kgaObhACXlE2jgGQuLNq+OAzPfTx7FJ/35Nhjl8PXqdam\nDHey+xlBAkEAsqTCHF69qSYwPoFY3nqEHmhtUyLyJ6x+lXLM7DTfC8nvSiLSbbls\nDp3ZUrxo+Hau50Dos27vJ4F5R/5jiym7mwJAJCwhvbOonkNr7PAyWgrr0MouDEep\nw6zUfzBCMhsTaIRspajHk8hCgYH+gv7PNbCJdjzIT0jfM7ENC+kVGRWwgQJADm7v\nW/lvm24Bcdtjgb4mVIqdYp0tMXVnWM3IrsDq0HoFQlkj5UeY6mloeJ3OYVy9buO4\nqV6qJef5E48DHehGRwJBAKmSv8vkdcC6ITaal62Teuly68r/SN9GR40TkPRUALEQ\nb8SAV6DI+hOqRW5bzSCiayKPUiDrNV6ZtqRfTHPHQ/o=\n-----END RSA PRIVATE KEY-----`,\n      certificate: `-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCKqo+T1gWfmXO5sxVHECRmIK10\n9holtPp9PnXWH01SP7zY1Syo5MzLnewmsdXqlkp7jMQdAi4fDcbb4VCA9PX3roOc\nHQWL+tjCaLMAJ/24yff65cnLYSpWSDSF79ijxPmEBlml273KT/+t53BIzGK5SDBo\nh3JMtjFTLz9HH+PFWwIDAQAB\n-----END PUBLIC KEY-----`\n    });\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/sslComponentsRepository/sslComponentsRepository.mock.js\n// module id = 180\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet async = require('async');\nlet S3GetObjectRequest = require('../S3GetObjectRequest');\nlet amazonClientFactory = require('../amazon-client/masterAccountClient');\nconst SslComponentsRepositoryConfiguration = require('./sslComponentsRepository.prod.config.js');\nlet sslComponentsCache = null;\n\nmodule.exports = function SSLComponentsRepository() {\n  let sslComponentsRepositoryConfiguration = new SslComponentsRepositoryConfiguration();\n\n  this.get = function () {\n    return new Promise((resolve, reject) => {\n      if (sslComponentsCache) {\n        resolve(sslComponentsCache);\n      } else {\n        loadSSLComponentsFromS3((error, sslComponents) => {\n          if (error) reject(error);\n          else {\n            sslComponentsCache = sslComponents;\n            resolve(sslComponents);\n          }\n        });\n      }\n    });\n  };\n\n  function loadSSLComponentsFromS3(mainCallback) {\n    async.waterfall([\n      // Creates a new instance of S3 client\n      (callback) => {\n        amazonClientFactory.createS3Client().then(\n          client => callback(null, client),\n          error => callback(error)\n        );\n      },\n\n      // SSL private key and certificate files are stored on S3.\n      // Following function creates a couple of request in order to download\n      // these two S3 objects.\n      (client, callback) => {\n        let privateKeyRequestParameters = {\n          bucketName: sslComponentsRepositoryConfiguration.getBucketName(),\n          objectPath: sslComponentsRepositoryConfiguration.getPrivateKeyObjectPath()\n        };\n\n        let privateKeyRequest = new S3GetObjectRequest(client, privateKeyRequestParameters);\n\n        let certificateRequestParameters = {\n          bucketName: sslComponentsRepositoryConfiguration.getBucketName(),\n          objectPath: sslComponentsRepositoryConfiguration.getCertificateObjectPath()\n        };\n\n        let certificateRequest = new S3GetObjectRequest(client, certificateRequestParameters);\n\n        async.parallel({\n          privateKeyS3Object: privateKeyRequest.execute,\n          certificateS3Object: certificateRequest.execute\n        }, callback);\n      },\n\n      // Previous function returns a couple of S3 objects. The following one\n      // gets their content.\n      (response, callback) => {\n        callback(null, {\n          privateKey: response.privateKeyS3Object.Body.toString('utf8'),\n          certificate: response.certificateS3Object.Body.toString('utf8')\n        });\n      }\n    ], mainCallback);\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/sslComponentsRepository/sslComponentsRepository.prod.js\n// module id = 181\n// module chunks = 0","module.exports = require(\"async\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"async\"\n// module id = 182\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet assert = require('assert');\nlet config = require('../../config');\n\nmodule.exports = function SSLComponentsRepositoryConfiguration() {\n  let configuration = loadConfiguration();\n\n  this.getBucketName = () => configuration.bucketName;\n  this.getPrivateKeyObjectPath = () => configuration.privateKeyObjectPath;\n  this.getCertificateObjectPath = () => configuration.certificateObjectPath;\n\n  function loadConfiguration() {\n    let localConfig = config.getUserValue('local');\n\n    assert(localConfig.server, 'missing \\'server\\' field in configuration');\n    assert(localConfig.server.ssl, 'missing \\'server.ssl\\' field in configuration');\n    assert(localConfig.server.ssl.S3, 'missing \\'server.ssl.S3\\' field in configuration');\n    assert(localConfig.server.ssl.S3.bucket, 'missing \\'server.ssl.S3.bucket\\' field in configuration');\n    assert(localConfig.server.ssl.S3.key, 'missing \\'server.ssl.S3.key\\' field in configuration');\n    assert(localConfig.server.ssl.S3.cert, 'missing \\'server.ssl.S3.cert\\' field in configuration');\n\n    return {\n      bucketName: localConfig.server.ssl.S3.bucket,\n      privateKeyObjectPath: localConfig.server.ssl.S3.key,\n      certificateObjectPath: localConfig.server.ssl.S3.cert\n    };\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/sslComponentsRepository/sslComponentsRepository.prod.config.js\n// module id = 183\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nfunction isUserAuthenticated(user) {\n  return !!user;\n}\n\nmodule.exports = {\n  allowUnknown(request, response, next) {\n    return next();\n  },\n\n  denyUnauthorized(request, response, next) {\n    // User not authenticated\n    if (!isUserAuthenticated(request.user)) {\n      response.status(403);\n      response.json({\n        error: 'Access denied. Please log in'\n      });\n    } else {\n      next();\n    }\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/authentication.js\n// module id = 184\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet logger = require('../logger');\nlet deploymentMonitor = require('./DeploymentMonitor');\nconst MAX_MONITOR_INTERVAL = 60;\nconst MIN_MONITOR_INTERVAL = 45;\n\nlet monitorInterval = 0;\n\nfunction scheduleDeploymentMonitor(isPeakTime) {\n  let interval = getDeploymentMonitorInterval(isPeakTime);\n\n  logger.debug(`DeploymentMonitor: Next execution will start in ${interval} seconds`);\n\n  setTimeout(() => {\n    deploymentMonitor.monitorActiveDeployments().then(\n\n      (activeDeploymentsMonitored) => {\n        scheduleDeploymentMonitor(activeDeploymentsMonitored > 0);\n      },\n\n      (error) => {\n        logger.error(`DeploymentMonitor: An error has occurred: ${error.toString(true)}`);\n        scheduleDeploymentMonitor(false);\n      }\n\n    );\n  }, interval * 1000);\n}\n\nfunction getDeploymentMonitorInterval(isPeakTime) {\n  if (isPeakTime) {\n    monitorInterval = 0;\n  } else {\n    monitorInterval *= 2;\n  }\n\n  if (monitorInterval > MAX_MONITOR_INTERVAL) {\n    monitorInterval = MAX_MONITOR_INTERVAL;\n  } else if (monitorInterval < MIN_MONITOR_INTERVAL) {\n    monitorInterval = MIN_MONITOR_INTERVAL;\n  }\n\n  return monitorInterval;\n}\n\nmodule.exports = {\n  start() {\n    scheduleDeploymentMonitor(false);\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/monitoring/DeploymentMonitorScheduler.js\n// module id = 185\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet _ = require('lodash');\nlet fs = require('fs');\nlet co = require('co');\nlet ms = require('ms');\nlet logger = require('../logger');\nlet activeDeploymentsStatusProvider = require('./activeDeploymentsStatusProvider');\n\nlet DEFAULT_INFRASTRUCTURE_PROVISIONING_TIMEOUT = '60m';\nlet Enums = require('../../Enums');\nlet NodeDeploymentStatus = require('../../Enums').NodeDeploymentStatus;\nlet deploymentLogger = require('../DeploymentLogger');\n\nmodule.exports = {\n  detectNodesDeploymentStatus,\n  monitorActiveDeployments() {\n    try {\n      let stats = fs.lstatSync('DONT_RUN_DEPLOYMENT_MONITOR');\n      if (stats.isFile()) {\n        // Return 0 monitored deployments\n        logger.info('DeploymentMonitor: DONT_RUN_DEPLOYMENT_MONITOR env is defined, so not running');\n        return Promise.resolve(0);\n      }\n    } catch (err) {\n      if (err.code !== 'ENOENT') {\n        // If error is other than not found file, rethrow\n        throw err;\n      }\n    }\n\n    return co(function* () {\n      let activeDeployments = yield activeDeploymentsStatusProvider.all();\n      let activeDeploymentsStatus = yield activeDeploymentsStatusProvider.getActiveDeploymentsFullStatus(activeDeployments);\n\n      yield activeDeploymentsStatus.map(\n        activeDeploymentStatus => monitorActiveDeploymentStatus(activeDeploymentStatus)\n      );\n\n      return activeDeploymentsStatus.length;\n    });\n  }\n};\n\nfunction monitorActiveDeploymentStatus(deploymentStatus) {\n  return co(function* () {\n    if (deploymentStatus.error) {\n      if (deploymentStatus.error.indexOf('Missing credentials in config') !== -1) {\n        // That is to not modify deployment if we catch mysterious 'Missing credentials' from AWS\n        return;\n      }\n\n      let newStatus = {\n        name: Enums.DEPLOYMENT_STATUS.Failed,\n        reason: sanitiseError(deploymentStatus.error)\n      };\n      deploymentLogger.updateStatus(deploymentStatus, newStatus);\n      return;\n    }\n\n    // Checking the overall deployment execution time does not exceeded the timeout.\n    // This execution time takes into account creation of AWS expected infrastructure,\n    // EC2 Instances bootstrapping, and service installation on them.\n    if (isOverallDeploymentTimedOut(deploymentStatus.startTime)) {\n      let newStatus = {\n        name: Enums.DEPLOYMENT_STATUS.Failed,\n        reason: `Deployment failed because exceeded overall timeout of ${DEFAULT_INFRASTRUCTURE_PROVISIONING_TIMEOUT}`\n      };\n      deploymentLogger.updateStatus(deploymentStatus, newStatus);\n      return;\n    }\n\n    timeOutNodes(deploymentStatus.nodesDeployment, deploymentStatus.installationTimeout);\n    let newStatus = detectNodesDeploymentStatus(deploymentStatus.nodesDeployment);\n\n    logger.debug(`DeploymentMonitor: Deployment '${deploymentStatus.deploymentId}' nodes status is ${JSON.stringify(newStatus)}`);\n\n    if (newStatus.name === Enums.DEPLOYMENT_STATUS.InProgress) {\n      return;\n    }\n\n    if (newStatus.name === Enums.DEPLOYMENT_STATUS.Success || newStatus.name === Enums.DEPLOYMENT_STATUS.Failed) {\n      deploymentLogger.updateStatus(deploymentStatus, newStatus);\n    }\n  });\n}\n\nfunction sanitiseError(error) {\n  if (_.isObjectLike(error)) { return JSON.stringify(error); }\n  return error.toString(true);\n}\n\nfunction isOverallDeploymentTimedOut(deploymentStartTime) {\n  let initialTime = new Date(deploymentStartTime);\n  let currentTime = new Date();\n  let elapsedMs = currentTime.getTime() - initialTime.getTime();\n\n  let timedOut = elapsedMs > ms(DEFAULT_INFRASTRUCTURE_PROVISIONING_TIMEOUT);\n\n  return timedOut;\n}\n\nfunction detectNodesDeploymentStatus(nodes) {\n  let totalNodeCount = nodes.length;\n\n  if (totalNodeCount < 1) {\n    // There are no nodes yet. Maybe an ASG is being created or scaled out from zero?\n    return { name: Enums.DEPLOYMENT_STATUS.InProgress };\n  }\n\n  if (nodes.every(succeeded)) {\n    // Deployment succeeded on every node.\n    return {\n      name: Enums.DEPLOYMENT_STATUS.Success,\n      reason: 'Deployed all nodes successfully'\n    };\n  }\n\n  if (nodes.every(completed)) {\n    let succeededLength = _.filter(nodes, succeeded).length;\n    // Deployment completed on every node but did not succeeded on every node.\n    return {\n      name: Enums.DEPLOYMENT_STATUS.Failed,\n      reason: `Deployment failed: deployed ${succeededLength}/${nodes.length} nodes`\n    };\n  }\n\n  return { name: Enums.DEPLOYMENT_STATUS.InProgress };\n\n  function succeeded(node) {\n    return node.Status === NodeDeploymentStatus.Success;\n  }\n\n  function completed(node) {\n    return node.Status === NodeDeploymentStatus.Success || node.Status === NodeDeploymentStatus.Failed;\n  }\n}\n\nfunction timeOutNodes(nodesDeployment, installationTimeout) {\n  nodesDeployment.forEach((nodeDeployment) => {\n    if (isNodeDeploymentTimedOut(nodeDeployment, installationTimeout)) {\n      nodeDeployment.Status = NodeDeploymentStatus.Failed;\n      nodeDeployment.LastCompletedStage = 'Timed Out';\n    }\n  });\n}\n\nfunction isNodeDeploymentTimedOut(nodeDeployment, installationTimeout) {\n  if (nodeDeployment.Status !== NodeDeploymentStatus.InProgress) return false;\n\n  let initialTime = new Date(nodeDeployment.StartTime);\n  let currentTime = new Date();\n  let elapsedMs = currentTime.getTime() - initialTime.getTime();\n\n  let timedOut = elapsedMs > installationTimeout;\n\n  return timedOut;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/monitoring/DeploymentMonitor.js\n// module id = 186\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet util = require('util');\nlet BaseError = require('./BaseError.class');\n\nmodule.exports = function DynamoItemNotFoundError(message, innerError) {\n  this.name = this.constructor.name;\n  this.message = message;\n  this.innerError = innerError;\n\n  Error.captureStackTrace(this, this.constructor);\n};\n\nutil.inherits(module.exports, BaseError);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/errors/DynamoItemNotFoundError.class.js\n// module id = 187\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet assert = require('assert');\n\nmodule.exports = function Image(imageSummary) {\n  assert(imageSummary, 'Expected \"ami\" argument not to be null.');\n\n  this.id = imageSummary.ImageId;\n  this.creationDate = imageSummary.CreationDate;\n  this.platform = imageSummary.Platform;\n  this.name = imageSummary.Name;\n  this.description = imageSummary.Description;\n  this.type = imageSummary.AmiType;\n  this.version = imageSummary.AmiVersion;\n  this.isCompatibleImage = imageSummary.IsCompatibleImage;\n  this.encrypted = imageSummary.Encrypted;\n  this.isStable = imageSummary.IsStable;\n  this.rootVolumeSize = imageSummary.RootVolumeSize;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/provisioning/Image.class.js\n// module id = 188\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet util = require('util');\nlet BaseError = require('./BaseError.class');\n\nmodule.exports = function ImageNotFoundError(message, innerError) {\n  this.name = this.constructor.name;\n  this.message = message;\n  this.innerError = innerError;\n\n  Error.captureStackTrace(this, this.constructor);\n};\n\nutil.inherits(module.exports, BaseError);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/errors/ImageNotFoundError.class.js\n// module id = 189\n// module chunks = 0","module.exports = require(\"semver\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"semver\"\n// module id = 190\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet _ = require('lodash');\nlet ResourceNotFoundError = require('../modules/errors/ResourceNotFoundError.class');\nlet deploymentMaps = require('../modules/data-access/deploymentMaps');\n\nclass DeploymentMap {\n\n  constructor(data) {\n    _.assign(this, data);\n  }\n\n  static getByName(deploymentMapName) {\n    return deploymentMaps.get({ DeploymentMapName: deploymentMapName })\n      .then(deploymentMap => (deploymentMap !== null\n        ? new DeploymentMap(deploymentMap.Value)\n        : Promise.reject(new ResourceNotFoundError(`Deployment map \"${deploymentMapName}\" not found.`))),\n        error => Promise.reject(\n          new Error(`An error has occurred retrieving \"${deploymentMapName}\" deployment map: ${error.message}`)));\n  }\n\n  getServerRolesByServiceName(serviceName) {\n    let deploymentTargets = this.DeploymentTarget.filter(target =>\n      target.Services.some(service => service.ServiceName === serviceName)\n    );\n\n    if (deploymentTargets.length === 0) {\n      throw new ResourceNotFoundError(\n        `Target server role cannot be identified through \"${serviceName}\" service because there ` +\n        'is no reference to it in the deployment map.'\n      );\n    }\n\n    return deploymentTargets;\n  }\n\n}\n\nmodule.exports = DeploymentMap;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/models/DeploymentMap.js\n// module id = 191\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet co = require('co');\nconst asgResourceFactory = require('../../modules/resourceFactories/asgResourceFactory');\n\nfunction* handleQuery(query) {\n  // Create an instance of the resource to work with based on the resource\n  // descriptor and AWS account name.\n  let parameters = { accountName: query.accountName };\n  let resource = yield asgResourceFactory.create(undefined, parameters);\n\n  // Get AutoScalingGroup by name\n  return resource.get({ name: query.autoScalingGroupName, clearCache: query.clearCache });\n}\n\nmodule.exports = co.wrap(handleQuery);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/queryHandlersUtil/getASG.js\n// module id = 192\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet AsgResourceBase = require('./AsgResourceBase');\nlet AutoScalingGroup = require('../../models/AutoScalingGroup');\n\nfunction AsgResource(accountId) {\n  const base = new AsgResourceBase(accountId);\n  const self = Object.create(new AsgResourceBase(accountId));\n  self.get = function (parameters) {\n    return base.get(parameters).then(x => new AutoScalingGroup(x));\n  };\n  self.all = function (parameters) {\n    return base.all(parameters).then(xs => xs.map(x => new AutoScalingGroup(x)));\n  };\n  return self;\n}\n\nmodule.exports = AsgResource;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/resourceFactories/AsgResource.js\n// module id = 193\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet util = require('util');\nlet BaseError = require('./BaseError.class');\n\nmodule.exports = function AutoScalingGroupAlreadyExistsError(message, innerError) {\n  this.name = this.constructor.name;\n  this.message = message;\n  this.innerError = innerError;\n\n  Error.captureStackTrace(this, this.constructor);\n};\n\nutil.inherits(module.exports, BaseError);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/errors/AutoScalingGroupAlreadyExistsError.class.js\n// module id = 194\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet ConsulManager = require('./ConsulManager');\nlet co = require('co');\nlet consulClient = require('../../consul-client');\n\nfunction* setInstanceMaintenanceMode(accountName, host, environment, enable) {\n  let options = { accountName, host, environment };\n  let consulManager = yield consulClient.create(options).then(client => new ConsulManager(client));\n\n  yield consulManager.setServerMaintenanceMode(enable);\n}\n\nmodule.exports = {\n  setInstanceMaintenanceMode: co.wrap(setInstanceMaintenanceMode)\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/service-targets/consul/consulMacroManager.js\n// module id = 195\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet Promise = require('bluebird');\nlet logger = require('../../logger');\n\nmodule.exports = class ConsulManager {\n  constructor(client) {\n    this.client = client;\n  }\n\n  setServerMaintenanceMode(enable) {\n    logger.debug(`consul: setting maintenance mode to ${enable}`);\n    let promisified = Promise.promisify(this.client.agent.maintenance, { context: this.client.agent });\n    return promisified({ enable, reason: 'Maintanance mode triggered from EnvironmentManager' }).catch((err) => {\n      throw new Error(`Couldn't connect to consul client: ${err.message}`);\n    });\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/service-targets/consul/ConsulManager.js\n// module id = 196\n// module chunks = 0","module.exports = require(\"consul\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"consul\"\n// module id = 197\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nmodule.exports = parameters => (\n  Promise.resolve({\n    host: '10.249.16.74',\n    port: '8500',\n    defaults: {\n      dc: 'tl-c50'\n    },\n    promisify: parameters.promisify\n  })\n);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/consul-client/clientConfig.mock.js\n// module id = 198\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet co = require('co');\nlet configurationCache = require('../configurationCache');\nlet consulSecretCache = require('../consulSecretCache');\nlet _ = require('lodash');\n\nfunction* getConsulClientOptions(parameters) {\n  let environmentName = parameters.environment;\n  let environment = yield configurationCache.getEnvironmentByName(environmentName);\n  let environmentType = yield configurationCache.getEnvironmentTypeByName(environment.EnvironmentType);\n  let consul = environmentType.Consul;\n  let secret = yield consulSecretCache.get(consul.SecurityTokenPath);\n  let token = secret.consul.token;\n  if (token === null) {\n    token = undefined;\n  }\n\n  // if host is undefined, we connect to a random consul agent\n  let host = (parameters.host !== undefined) ? parameters.host : _.sample(consul.Servers);\n\n  let options = {\n    host,\n    port: consul.Port,\n    defaults: {\n      dc: consul.DataCenter,\n      token\n    }\n  };\n\n  options.promisify = parameters.promisify;\n  return options;\n}\n\nmodule.exports = co.wrap(getConsulClientOptions);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/consul-client/clientConfig.prod.js\n// module id = 199\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet awsMasterClient = require('./amazon-client/masterAccountClient');\nlet cacheManager = require('./cacheManager');\nlet logger = require('./logger');\n\nconst TTL = 10 * 60; // seconds\n\ncacheManager.create('ConsulToken', createToken, { stdTTL: TTL });\n\n/**\n * retrieve a ConsulToken\n * @param {s3Location} s3Location - the S3 bucket and key\n */\nfunction getToken(s3Location) {\n  let cacheKey = JSON.stringify(s3Location);\n  return cacheManager.get('ConsulToken').get(cacheKey);\n}\n\nfunction createToken(cacheKey) {\n  let query = Object.assign({}, JSON.parse(cacheKey));\n  return awsMasterClient.createS3Client()\n    .then(client => client.getObject(query).promise())\n    .then(response => JSON.parse(response.Body.toString('utf8')))\n    .catch((error) => {\n      logger.error(`Failed to get Consul token from ${cacheKey}`);\n      return Promise.reject(error);\n    });\n}\n\nmodule.exports = {\n  get: getToken\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/consulSecretCache.js\n// module id = 200\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet assert = require('assert');\nlet utils = require('../../utilities');\nlet ResourceNotFoundError = require('../../errors/ResourceNotFoundError.class');\nlet HttpRequestError = require('../../errors/HttpRequestError.class');\nlet consulClient = require('../../consul-client');\nlet logger = require('../../logger');\nlet retry = require('retry');\nlet _ = require('lodash');\n\nfunction encodeValue(value) {\n  if (!value) return null;\n  return (typeof value === 'object') ? JSON.stringify(value) : value;\n}\n\nfunction decodeValue(encodedValue) {\n  if (!encodedValue) return null;\n  let value = utils.safeParseJSON(encodedValue);\n  return value || encodedValue;\n}\n\nfunction asKeyValuePair(item) {\n  return {\n    key: item.Key,\n    value: decodeValue(item.Value)\n  };\n}\n\nfunction getTargetState(environment, parameters) {\n  assert(parameters, 'Expected \"parameters\" not to be null or empty.');\n\n  let promiseFactoryMethod = () => createConsulClient(environment).then(clientInstance => clientInstance.kv.get({ key: parameters.key, recurse: parameters.recurse }).catch((error) => {\n    throw new HttpRequestError(`An error has occurred contacting consul agent: ${error.message}`);\n  }).then((result) => {\n    if (parameters.recurse) {\n      let data = result ? result.map(asKeyValuePair) : [];\n      return data;\n    }\n    if (result) {\n      return asKeyValuePair(result);\n    }\n    throw new ResourceNotFoundError(`Key \"${parameters.key}\" in Consul key/value storage has not been found.`);\n  }));\n\n  return executeAction(promiseFactoryMethod);\n}\n\nfunction getAllServiceTargets(environmentName, runtimeServerRole) {\n  assert(runtimeServerRole, 'runTimeServerRole needs to be defined');\n  assert(environmentName, 'environmentName needs to be defined');\n  let key = `environments/${environmentName}/roles/${runtimeServerRole}/services`;\n  return getTargetState(environmentName, { key, recurse: true }).then(data => _.map(data, 'value'))\n    .then((data) => {\n      // Note: this is for backwards compatibility. Once all server role services have \"Action\" attribute, we can remove that\n      _.each(data, (service) => {\n        if (service.Action === undefined) {\n          service.Action = 'Install';\n        }\n      });\n      return data;\n    });\n}\n\nfunction getInstanceServiceDeploymentInfo(environmentName, deploymentId, instanceId) {\n  let key = `deployments/${deploymentId}/nodes/${instanceId}`;\n  return getTargetState(environmentName, { key, recurse: true }).then(data => _.get(data, '[0].value'));\n}\n\nfunction getServiceDeploymentCause(environmentName, deploymentId, instanceId) {\n  let key = `deployments/${deploymentId}/nodes/${instanceId}`;\n  let value = '[0].value.Cause';\n  let defaultValue = 'Unknown';\n\n  return getTargetState(environmentName, { key, recurse: true }).then(data => _.get(data, value, defaultValue));\n}\n\nfunction setTargetState(environment, parameters) {\n  assert(parameters, 'Expected \"parameters\" not to be null or empty.');\n  let promiseFactoryMethod = () => new Promise((resolve, reject) => {\n    createConsulClient(environment).then((clientInstance) => {\n      let encodedValue = encodeValue(parameters.value);\n      let options = {};\n\n      if (parameters.options) {\n        if (parameters.options.expectedVersion !== undefined) {\n          options.cas = parameters.options.expectedVersion;\n        }\n      }\n      clientInstance.kv.set(parameters.key, encodedValue, options, (error, created) => {\n        if (error) {\n          return reject(new HttpRequestError(\n            `An error has occurred contacting consul agent: ${error.message}`\n          ));\n        }\n        if (!created) {\n          return reject(new Error(\n            `Consul '${parameters.key}' key cannot be updated`\n          ));\n        }\n        logChange('SET', parameters.key, encodedValue);\n        return resolve();\n      });\n    });\n  });\n  return executeAction(promiseFactoryMethod);\n}\n\nfunction removeRuntimeServerRoleTargetState(environmentName, runtimeServerRoleName) {\n  return removeTargetState(environmentName, {\n    key: `environments/${environmentName}/roles/${runtimeServerRoleName}`,\n    recurse: true\n  });\n}\n\nfunction removeTargetState(environment, { key, recurse }) {\n  assert(key, 'Expected \"key\" not to be null or empty.');\n  let promiseFactoryMethod = () => new Promise((resolve, reject) => {\n    createConsulClient(environment).then((clientInstance) => {\n      clientInstance.kv.get({ key, recurse }, (getError, result) => {\n        clientInstance.kv.del({ key, recurse }, (delError) => {\n          if (!delError) {\n            logChange('DELETE', key, result);\n            return resolve();\n          }\n          return reject(new HttpRequestError(\n            `An error has occurred contacting consul agent: ${delError.message}`\n          ));\n        });\n      });\n    });\n  });\n\n  return executeAction(promiseFactoryMethod);\n}\n\nfunction executeAction(promiseFactoryMethod) {\n  let operation = retry.operation({\n    retries: 3,\n    minTimeout: 1000\n  });\n\n  return new Promise((resolve, reject) => {\n    operation.attempt(() => {\n      promiseFactoryMethod()\n        .then(result => resolve(result))\n        .catch((error) => {\n          if ((error instanceof HttpRequestError) && operation.retry(error)) return;\n          reject(error);\n        });\n    });\n  });\n}\n\nfunction createConsulClient(environment) {\n  return consulClient.create({ environment, promisify: true });\n}\n\nfunction logChange(operation, key, value) {\n  logger.debug(`Consul key value store operation: ${operation} ${key}. ${value}`);\n}\n\nmodule.exports = {\n  getTargetState,\n  setTargetState,\n  removeTargetState,\n  removeRuntimeServerRoleTargetState,\n  getAllServiceTargets,\n  getServiceDeploymentCause,\n  getInstanceServiceDeploymentInfo\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/service-targets/consul/keyValueStore.js\n// module id = 201\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet util = require('util');\nlet BaseError = require('./BaseError.class');\n\nmodule.exports = function LaunchConfigurationAlreadyExistsError(message, innerError) {\n  this.name = this.constructor.name;\n  this.message = message;\n  this.innerError = innerError;\n\n  Error.captureStackTrace(this, this.constructor);\n};\n\nutil.inherits(module.exports, BaseError);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/errors/LaunchConfigurationAlreadyExistsError.class.js\n// module id = 202\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet User = require('../../shared/user');\nlet systemUser = User.new('System', null, [], [{ Access: 'ADMIN', Resource: '**' }]);\n\nmodule.exports = systemUser;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/systemUser.js\n// module id = 203\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nconst swaggerTools = require('swagger-tools');\nconst config = require('../config');\nconst swaggerAuthorizer = require('../modules/express-middleware/swaggerAuthorizerMiddleware');\nconst swaggerNewRelic = require('../modules/express-middleware/swaggerNewRelicMiddleware');\nconst defaultErrorHandler = require('./error-handler/defaultErrorHandler');\nconst apiSpec = require('./swagger-doc');\nconst controllers = require('./controllers');\n\nconst NODE_ENV = process.env.NODE_ENV;\nconst API_BASE_PATH = apiSpec.basePath;\n\nif (config.get('IS_PRODUCTION') === false) {\n  apiSpec.host = 'localhost:8080';\n  apiSpec.schemes = ['http'];\n}\n\nlet swaggerOptions = { controllers: controllers() };\n\nfunction setup() {\n  return new Promise((resolve, reject) => {\n    try {\n      swaggerTools.initializeMiddleware(apiSpec, ({ swaggerMetadata, swaggerValidator, swaggerRouter, swaggerUi }) => {\n        let result = {\n          swaggerAuthorizer: swaggerAuthorizer(),\n          swaggerBasePath: API_BASE_PATH,\n          swaggerErrorHandler: defaultErrorHandler,\n          swaggerMetadata: swaggerMetadata(),\n          swaggerRouter: swaggerRouter(swaggerOptions),\n          swaggerUi: swaggerUi(),\n          swaggerValidator: swaggerValidator({ validateResponse: NODE_ENV === 'development' }),\n          swaggerNewRelic\n        };\n        resolve(Object.freeze(result));\n      });\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n\nmodule.exports = setup;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/v1.js\n// module id = 204\n// module chunks = 0","module.exports = require(\"swagger-tools\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"swagger-tools\"\n// module id = 205\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet _ = require('lodash');\nlet authorization = require('../authorization');\nlet authorizers = require('../authorizers');\n\nfunction authorize(req, res, next) {\n  if (req.swagger === undefined) {\n    next();\n    return;\n  }\n\n  // We need to rewrite this for authorizers to work with swagger\n  _.each(req.swagger.params, (param, key) => {\n    req.params[key] = param.value;\n  });\n\n  let authorizerName = req.swagger.operation['x-authorizer'] || 'simple';\n\n  if (authorizerName !== 'allow-anonymous') {\n    let authorizer = authorizers[authorizerName];\n    authorization(authorizer, req, res, next);\n  } else {\n    next();\n  }\n}\n\nmodule.exports = () => authorize;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/express-middleware/swaggerAuthorizerMiddleware.js\n// module id = 206\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet logger = require('./logger');\nlet authorize = require('./authorizer');\n\nlet errorResponseCodes = {\n  BadRequestError: 400,\n  ResourceNotFoundError: 404\n};\n\nfunction authorizeRequest(authorizer, request, response, next) {\n  if (!request.user) {\n    response.status(401);\n    return response.send('Access Denied. Please sign in and try again.');\n  } else {\n    if (request.method === 'GET') return next();\n    return handleSecureRequest(authorizer, request, response, next);\n  }\n}\n\nfunction handleSecureRequest(authorizer, request, response, next) {\n  let usersPermissions = request.user.getPermissions();\n  authorizer.getRules(request).then((requiredPermissions) => {\n    logRequestAndRequirements(request, requiredPermissions, usersPermissions);\n\n    let authorizationResult = authorize(usersPermissions, requiredPermissions);\n    logResult(authorizationResult);\n\n    if (authorizationResult.authorized) return next();\n\n    if (authorizationResult.protectedAction !== undefined) {\n      return sendProtectedActionResponse(\n        authorizationResult.protectedAction,\n        authorizationResult.environmentType,\n        response\n      );\n    } else {\n      return sendUnauthorizedResponse(authorizationResult.unsatisfiedPermissions, response);\n    }\n  }).catch((error) => {\n    let errorCode = errorResponseCodes[error.name];\n    if (errorCode) {\n      response.status(errorCode);\n      response.send(error.message);\n    } else {\n      sendAuthorizationErrorResponse(error, response);\n    }\n  });\n}\n\nfunction sendProtectedActionResponse(action, envType, response) {\n  response.status(403);\n  response.send(`The Environment Type '${envType}' is protected against ${action} operations`);\n}\n\nfunction sendAuthorizationErrorResponse(error, response) {\n  logger.error(`An error has occurred authorizing user: ${error.message}`);\n  logger.error(error.toString(true));\n  logger.error(error.stack);\n\n  response.status(500);\n  response.send('An error has occurred. Please try again.');\n}\n\nfunction sendUnauthorizedResponse(unsatisfiedPermissions, response) {\n  // TODO: Return data instead of pre-rendered HTML\n  let message = 'You are not authorized to perform that action. You are missing the following permissions: <br \\><br \\>';\n\n  unsatisfiedPermissions.forEach((permission) => {\n    message += `* ${permission.access} > ${permission.resource}`;\n    if (permission.clusters) {\n      message += ` / clusters: ${permission.clusters.join(', ')}`;\n    }\n    if (permission.environmentTypes) {\n      message += ` / environment types: ${permission.environmentTypes.join(', ')}`;\n    }\n    message += '<br \\>';\n  });\n\n  response.status(403);\n  response.send(message);\n}\n\nfunction logRequestAndRequirements(request, requiredPermissions, usersPermissions) {\n  logger.info({\n    method: request.method,\n    url: request.url,\n    user: request.user.getName()\n  }, `Authorizing ${request.method} ${request.url} request`);\n\n  if (requiredPermissions) {\n    logger.info({\n      requiredPermissions,\n      usersPermissions,\n      user: request.user.getName()\n    }, `Authorizing ${request.user.getName()} user`);\n  }\n}\n\nfunction logResult(authorizationResult) {\n  if (authorizationResult.authorized) logger.info('Authorised');\n  else logger.info('Not Authorized');\n\n  logger.info('');\n}\n\nmodule.exports = authorizeRequest;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/authorization.js\n// module id = 207\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet _ = require('lodash');\nlet intersect = require('glob-intersection');\n\nmodule.exports = (usersPermissions, requiredPermissions) => {\n  let protectedEnvironment = _.find(requiredPermissions, rp => rp.protectedAction !== undefined);\n  if (protectedEnvironment !== undefined) {\n    // The requested action is not permitted against the given environment\n    return {\n      authorized: false,\n      protectedAction: protectedEnvironment.protectedAction,\n      environmentType: protectedEnvironment.environmentTypes[0]\n    };\n  }\n\n  // Else check other permissions\n  let unsatisfiedPermissions =\n    requiredPermissions.filter(requiredPermission => !permissionIsSatisfied(requiredPermission, usersPermissions));\n\n  return {\n    authorized: unsatisfiedPermissions.length === 0,\n    unsatisfiedPermissions: _.uniqWith(unsatisfiedPermissions, _.isEqual)\n  };\n};\n\nfunction permissionIsSatisfied(requiredPermission, usersPermissions) {\n  let matchingPermissionFound = false;\n  let resourceSatisfied = false;\n  let requiredClusters = toRequiredAttributes(requiredPermission.clusters);\n  let requiredEnvironmentTypes = toRequiredAttributes(requiredPermission.environmentTypes);\n\n  usersPermissions.forEach((permission) => {\n    if (resourceAndAccessMatch(requiredPermission, permission)) {\n      if (!isLimitedResourcePermission(permission)) {\n        resourceSatisfied = true;\n      } else if (limitationsOnResourcePermissionMatch(requiredPermission, permission)) {\n        matchingPermissionFound = true;\n      }\n    }\n\n    if (isClusterPermission(permission)) {\n      satisfyRequiredClustersFromClusterPermission(requiredClusters, permission);\n    }\n\n    if (isEnvironmentTypePermission(permission)) {\n      satisfyRequiredEnvironmentTypesFromEnvironmentTypePermission(requiredEnvironmentTypes, permission);\n    }\n  });\n\n  return matchingPermissionFound || (resourceSatisfied &&\n    attributesAreSatisfied(requiredClusters) &&\n    attributesAreSatisfied(requiredEnvironmentTypes));\n}\n\nfunction limitationsOnResourcePermissionMatch(requiredPermission, permission) {\n  let requiredClusters = toRequiredAttributes(requiredPermission.clusters);\n  let requiredEnvironmentTypes = toRequiredAttributes(requiredPermission.environmentTypes);\n\n  if (isClusterLimitedResourcePermission(permission)) {\n    satisfyRequiredClustersFromResourcePermission(requiredClusters, permission);\n  }\n\n  if (isEnvironmentTypeLimitedResourcePermission(permission)) {\n    satisfyRequiredEnvironmentTypesFromResourcePermission(requiredEnvironmentTypes, permission);\n  }\n\n  return attributesAreSatisfied(requiredClusters) && attributesAreSatisfied(requiredEnvironmentTypes);\n}\n\nfunction isClusterPermission(permission) {\n  let isLegacyClusterPermission = intersect(toLower(permission.Resource), '/permissions/clusters/*');\n  let hasPermission = !!permission.Cluster;\n  return hasPermission || isLegacyClusterPermission;\n}\n\nfunction isEnvironmentTypePermission(permission) {\n  let isLegacyEnvironmentTypePermission = intersect(toLower(permission.Resource), '/permissions/environmenttypes/*');\n  let hasPermission = !!permission.EnvironmentType;\n  return hasPermission || isLegacyEnvironmentTypePermission;\n}\n\nfunction isLimitedResourcePermission(permission) {\n  return isClusterLimitedResourcePermission(permission) ||\n    isEnvironmentTypeLimitedResourcePermission(permission);\n}\n\nfunction isClusterLimitedResourcePermission(permission) {\n  return permission.Clusters;\n}\n\nfunction isEnvironmentTypeLimitedResourcePermission(permission) {\n  return permission.EnvironmentTypes;\n}\n\nfunction satisfyRequiredClustersFromResourcePermission(requiredClusters, permission) {\n  requiredClusters.forEach((requiredCluster) => {\n    if (typeof permission.Clusters === 'string' && permission.Clusters.toLowerCase() === 'all') {\n      requiredCluster.satisfied = true;\n    } else {\n      permission.Clusters.forEach((permittedCluster) => {\n        if (permittedCluster === requiredCluster.name) {\n          requiredCluster.satisfied = true;\n        }\n      });\n    }\n  });\n}\n\nfunction satisfyRequiredEnvironmentTypesFromResourcePermission(requiredEnvironmentTypes, permission) {\n  requiredEnvironmentTypes.forEach((requiredEnvironmentType) => {\n    if (typeof permission.EnvironmentTypes === 'string' && permission.EnvironmentTypes.toLowerCase() === 'all') {\n      requiredEnvironmentType.satisfied = true;\n    } else {\n      permission.EnvironmentTypes.forEach((permittedEnvironmentType) => {\n        if (permittedEnvironmentType === requiredEnvironmentType.name) {\n          requiredEnvironmentType.satisfied = true;\n        }\n      });\n    }\n  });\n}\n\nfunction satisfyRequiredClustersFromClusterPermission(requiredClusters, permission) {\n  requiredClusters.forEach((requiredCluster) => {\n    let permittedCluster = toLower(permission.Cluster);\n\n    let matchingCluster = (permittedCluster === 'all' || permittedCluster === requiredCluster.name);\n    let matchingLegacyCluster = intersect(toLower(permission.Resource), `/permissions/clusters/${requiredCluster.name}`);\n\n    if (matchingCluster || matchingLegacyCluster) {\n      requiredCluster.satisfied = true;\n    }\n  });\n}\n\nfunction satisfyRequiredEnvironmentTypesFromEnvironmentTypePermission(requiredEnvironmentTypes, permission) {\n  requiredEnvironmentTypes.forEach((requiredEnvironmentType) => {\n    let permittedEnvironmentType = toLower(permission.EnvironmentType);\n\n    let matchingEnvironmentType = (permittedEnvironmentType === 'all' || permittedEnvironmentType === requiredEnvironmentType.name);\n    let matchingLegacyEnvironmentType = intersect(toLower(permission.Resource), `/permissions/environmenttypes/${requiredEnvironmentType.name}`);\n\n    if (matchingEnvironmentType || matchingLegacyEnvironmentType) {\n      requiredEnvironmentType.satisfied = true;\n    }\n  });\n}\n\nfunction attributesAreSatisfied(attributes) {\n  return attributes.every(attr => attr.satisfied);\n}\n\nfunction toRequiredAttributes(attributes) {\n  if (!(attributes && attributes.length > 0)) return [];\n  return attributes.map(attribute => ({\n    name: attribute.toLowerCase(),\n    satisfied: false\n  }));\n}\n\nfunction resourceAndAccessMatch(requiredPermission, permission) {\n  let requiredResource = requiredPermission.resource.toLowerCase();\n  let requiredAccess = requiredPermission.access.toLowerCase();\n\n  let permittedResource = toLower(permission.Resource);\n  let permittedAccess = toLower(permission.Access);\n\n  let resourceMatches = intersect(permittedResource, requiredResource);\n  let accessMatches = permittedAccess === requiredAccess || permittedAccess === 'admin';\n\n  return resourceMatches && accessMatches;\n}\n\nfunction toLower(str) {\n  if (str) return str.toLowerCase();\n  return '';\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/authorizer.js\n// module id = 208\n// module chunks = 0","module.exports = require(\"glob-intersection\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"glob-intersection\"\n// module id = 209\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nconst allowAuthenticated = require('./allow-authenticated');\nconst asgs = require('./asgs');\nconst deployAuthorizer = require('./deploy-authorizer');\nconst deployments = require('./deployments');\nconst environments = require('./environments');\nconst environmentsSchedule = require('./environments-schedule');\nconst instances = require('./instances');\nconst loadBalancerSettings = require('./load-balancer-settings');\nconst packageUploadUrl = require('./package-upload-url');\nconst services = require('./services');\nconst simple = require('./simple');\nconst toggleServiceStatus = require('./toggle-service-status');\nconst upstreams = require('./upstreams');\n\nconst modules = {\n  'allow-authenticated': allowAuthenticated,\n  'asgs': asgs,\n  'deploy-authorizer': deployAuthorizer,\n  'deployments': deployments,\n  'environments': environments,\n  'environments-schedule': environmentsSchedule,\n  'instances': instances,\n  'load-balancer-settings': loadBalancerSettings,\n  'package-upload-url': packageUploadUrl,\n  'services': services,\n  'simple': simple,\n  'toggle-service-status': toggleServiceStatus,\n  'upstreams': upstreams\n};\n\nmodule.exports = modules;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/authorizers/index.js\n// module id = 210\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nexports.getRules = () => Promise.resolve([]);\n\nexports.docs = {\n  requiresClusterPermissions: false,\n  requiresEnvironmentTypePermissions: false\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/authorizers/allow-authenticated.js\n// module id = 211\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet configEnvironments = require('../data-access/configEnvironments');\n\nfunction getEnvironment(name) {\n  return configEnvironments.get({ EnvironmentName: name });\n}\n\nfunction getModifyPermissionsForEnvironment(environmentName, user) {\n  return getEnvironment(environmentName, user).then((environment) => {\n    if (environment) {\n      return {\n        cluster: environment.Value.OwningCluster.toLowerCase(),\n        environmentType: environment.Value.EnvironmentType.toLowerCase()\n      };\n    }\n    throw new Error(`Could not find environment: ${environmentName}`);\n  });\n}\n\nexports.getRules = (request) => {\n  let r = /^(.*?)-/;\n  let match = r.exec(request.params.name);\n\n  if (match && match[1]) {\n    return getModifyPermissionsForEnvironment(match[1], request.user).then(envPermissions => (\n      [{\n        resource: request.url.replace(/\\/+$/, ''),\n        access: request.method,\n        clusters: [envPermissions.cluster],\n        environmentTypes: [envPermissions.environmentType]\n      }]\n    ));\n  }\n\n  return Promise.resolve();\n};\n\nexports.docs = {\n  requiresClusterPermissions: true,\n  requiresEnvironmentTypePermissions: true\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/authorizers/asgs.js\n// module id = 212\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet _ = require('lodash');\nlet BadRequestError = require('../errors/BadRequestError.class');\n\nlet infrastructureConfigurationProvider = require('../provisioning/infrastructureConfigurationProvider');\nlet logger = require('../logger');\nlet Environment = require('../../models/Environment');\nlet co = require('co');\n\n// Only deployments targeted to Secure subnet in Production require an additional permission\nfunction isSecureServerRole(configuration) {\n  if (configuration.serverRole.SecurityZone === 'Secure') return true;\n  return false;\n}\n\nmodule.exports = {\n  getRules(request) {\n    return co(function* () {\n      let environmentName = request.params.environment || request.body.environment;\n      let serviceName = request.params.service || request.body.service;\n\n      let environment = yield Environment.getByName(environmentName);\n      let deploymentMap = yield environment.getDeploymentMap();\n      let serverRoles = _.map(yield deploymentMap.getServerRolesByServiceName(serviceName), 'ServerRoleName');\n\n      let serverRoleName;\n      let inputServerRole = request.query.server_role || request.body.server_role || request.body.serverRole;\n      if (inputServerRole) {\n        serverRoleName = inputServerRole;\n        if (serverRoles.indexOf(serverRoleName) === -1) {\n          return Promise.reject(new BadRequestError(`\"${serverRoleName}\" is not a potential target for deploy of \"${serviceName}\", available roles: ${serverRoles.join(', ')}`));\n        }\n      } else if (serverRoles.length !== 1) {\n        return Promise.reject(new BadRequestError(`\"server_role\" param required, available server roles for \"${serviceName}\": ${serverRoles.join(', ')}`));\n      } else {\n        serverRoleName = serverRoles[0];\n      }\n\n      // Attach serverRoles to request object\n      request.serverRoleName = serverRoleName;\n\n      let requiredPermissions = [];\n      let requiredPermission = {\n        resource: request.url.replace(/\\/+$/, ''),\n        access: request.method,\n        clusters: [],\n        environmentTypes: []\n      };\n      requiredPermissions.push(requiredPermission);\n\n      return infrastructureConfigurationProvider\n        .get(environmentName, serviceName, serverRoleName)\n        .then((configuration) => {\n          requiredPermission.clusters.push(configuration.cluster.Name.toLowerCase());\n\n          requiredPermission.environmentTypes.push(configuration.environmentTypeName.toLowerCase());\n\n          if (isSecureServerRole(configuration)) {\n            requiredPermissions.push({\n              resource: '/permissions/securityzones/secure',\n              access: 'POST'\n            });\n          }\n\n          return requiredPermissions;\n        }).catch((error) => {\n          logger.warn(error.toString(true));\n          return Promise.reject(new BadRequestError(error.toString()));\n        });\n    });\n  },\n\n  docs: {\n    requiresClusterPermissions: true,\n    requiresEnvironmentTypePermissions: true,\n    requiresSecurityZonePermissions: true\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/authorizers/deploy-authorizer.js\n// module id = 213\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet util = require('util');\nlet BaseError = require('./BaseError.class');\n\nmodule.exports = function BadRequestError(message, innerError) {\n  this.name = this.constructor.name;\n  this.message = message;\n  this.innerError = innerError;\n\n  Error.captureStackTrace(this, this.constructor);\n};\n\nutil.inherits(module.exports, BaseError);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/errors/BadRequestError.class.js\n// module id = 214\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet co = require('co');\nlet deploymentsHelper = require('../queryHandlersUtil/deployments-helper');\n\nmodule.exports = {\n  getRules(request) {\n    return co(function* () {\n      let key = request.swagger.params.id.value;\n      let deployment = yield deploymentsHelper.get({ key });\n\n      return [{\n        resource: request.url.replace(/\\/+$/, ''),\n        access: request.method,\n        clusters: [deployment.Value.OwningCluster],\n        environmentTypes: [deployment.Value.EnvironmentType]\n      }];\n    });\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/authorizers/deployments.js\n// module id = 215\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet _ = require('lodash');\nlet deployments = require('../modules/data-access/deployments');\n\nclass Deployment {\n\n  constructor(data, expectedNodes = undefined) {\n    _.assign(this, data);\n    if (expectedNodes !== undefined) {\n      _.assign(this, { ExpectedNodes: expectedNodes });\n    }\n  }\n\n  static getById(key) {\n    return deployments.get({ DeploymentID: key });\n  }\n}\n\nmodule.exports = Deployment;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/models/Deployment.js\n// module id = 216\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet _ = require('lodash');\nlet configEnvironments = require('../data-access/configEnvironments');\n\nfunction getCurrentEnvironment(name) {\n  return configEnvironments.get({ EnvironmentName: name });\n}\n\nexports.getRules = (request) => {\n  let requiredPermission = {\n    resource: request.url.replace(/\\/+$/, ''),\n    access: request.method,\n    clusters: [],\n    environmentTypes: []\n  };\n\n  if (request.method === 'POST') {\n    let newCluster = request.body.Value.OwningCluster;\n    if (newCluster) {\n      requiredPermission.clusters.push(newCluster.toLowerCase());\n    }\n\n    let environmentType = request.body.Value.EnvironmentType;\n    if (environmentType) {\n      requiredPermission.environmentTypes.push(environmentType.toLowerCase());\n    }\n\n    return Promise.resolve([requiredPermission]);\n  }\n\n  if (request.method === 'PUT') {\n    // TODO: subsequent parameters are for v1 API.\n    // Once old API is gone, should use request.swagger.params.\n    let environmentType = request.body.EnvironmentType || request.body.Value.EnvironmentType;\n\n    if (environmentType) {\n      requiredPermission.environmentTypes.push(environmentType.toLowerCase());\n    }\n  }\n\n  // TODO: subsequent parameters are for v1 API.\n  // Once old API is gone, should use request.swagger.params.\n  let environmentName = request.params.key || request.params.name || request.params.environment\n    || _.get(request, 'swagger.params.environment.value');\n\n  let user = request.user;\n\n  return getCurrentEnvironment(environmentName, user).then((environment) => {\n    if (environment) {\n      requiredPermission.clusters.push(environment.Value.OwningCluster.toLowerCase());\n      requiredPermission.environmentTypes.push(environment.Value.EnvironmentType.toLowerCase());\n    }\n\n    return [requiredPermission];\n  });\n};\n\nexports.docs = {\n  requiresClusterPermissions: true,\n  requiresEnvironmentTypePermissions: true\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/authorizers/environments.js\n// module id = 217\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet co = require('co');\nlet configEnvironments = require('../data-access/configEnvironments');\nlet environmentProtection = require('./environmentProtection');\n\nconst ACTION = environmentProtection.SCHEDULE_ENVIRONMENT;\n\nfunction getCurrentEnvironment(name) {\n  return configEnvironments.get({ EnvironmentName: name });\n}\n\nfunction* getRules(request) {\n  let requiredPermission = {\n    resource: request.url.replace(/\\/+$/, ''),\n    access: request.method\n  };\n\n  // Need to check 'name' because of swagger\n  let environmentName = request.params.key || request.params.name;\n  let user = request.user;\n  let environment = yield getCurrentEnvironment(environmentName, user);\n  let environmentTypeName = environment.Value.EnvironmentType.toLowerCase();\n  if (environment) {\n    requiredPermission.clusters = [environment.Value.OwningCluster.toLowerCase()];\n    requiredPermission.environmentTypes = [environmentTypeName];\n  }\n\n  let isProtected = yield environmentProtection.isActionProtected(environmentName, ACTION);\n  if (isProtected) {\n    requiredPermission.protectedAction = ACTION;\n  }\n\n  return [requiredPermission];\n}\n\nmodule.exports = {\n  getRules: co.wrap(getRules),\n  docs: {\n    requiresClusterPermissions: true,\n    requiresEnvironmentTypePermissions: true\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/authorizers/environments-schedule.js\n// module id = 218\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet Instance = require('../../models/Instance');\nlet co = require('co');\n\nexports.getRules = function getRules(request) {\n  const id = request.swagger.params.id.value;\n\n  return co(function* _() {\n    const instance = yield Instance.getById(id);\n    const owningCluster = instance.getTag('OwningCluster');\n\n    return [{\n      resource: request.url.replace(/\\/+$/, ''),\n      access: request.method,\n      clusters: [owningCluster]\n    }];\n  });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/authorizers/instances.js\n// module id = 219\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet util = require('util');\nlet BaseError = require('./BaseError.class');\n\nmodule.exports = function InstanceNotFoundError(message, innerError) {\n  this.name = this.constructor.name;\n  this.message = message;\n  this.innerError = innerError;\n\n  Error.captureStackTrace(this, this.constructor);\n};\n\nutil.inherits(module.exports, BaseError);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/errors/InstanceNotFoundError.class.js\n// module id = 220\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet configEnvironments = require('../data-access/configEnvironments');\n\nfunction getEnvironment(name) {\n  return configEnvironments.get({ EnvironmentName: name });\n}\n\nfunction getModifyPermissionsForEnvironment(environmentName, user) {\n  return getEnvironment(environmentName, user).then((environment) => {\n    if (environment) {\n      return {\n        cluster: environment.Value.OwningCluster.toLowerCase(),\n        environmentType: environment.Value.EnvironmentType.toLowerCase()\n      };\n    }\n\n    throw new Error(`Could not find environment: ${environmentName}`);\n  });\n}\n\nexports.getRules = (request) => {\n  let environmentName = request.params.key || request.params.environment;\n  if (environmentName === undefined) {\n    // Environment is in the body\n    let body = request.params.body || request.body;\n    environmentName = body.EnvironmentName || body.Value.EnvironmentName;\n  }\n  return getModifyPermissionsForEnvironment(environmentName, request.user).then(envPermissions => [{\n    resource: request.url.replace(/\\/+$/, ''),\n    access: request.method,\n    clusters: [envPermissions.cluster],\n    environmentTypes: [envPermissions.environmentType]\n  }]);\n};\n\nexports.docs = {\n  requiresClusterPermissions: true,\n  requiresEnvironmentTypePermissions: true\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/authorizers/load-balancer-settings.js\n// module id = 221\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet Environment = require('../../models/Environment');\nlet Service = require('../../models/Service');\n\nlet fp = require('lodash/fp');\n\nlet param = p => fp.get(['swagger', 'params', p, 'value']);\n\nfunction getRules(request) {\n  let resource = request.url.replace(/\\/+$/, '');\n  let access = request.method;\n  let environment = param('environment')(request);\n  let service = param('service')(request);\n\n  if (environment !== undefined) {\n    return Environment.getByName(environment).then(env => ({\n      resource,\n      access,\n      clusters: [env.OwningCluster],\n      environmentTypes: [env.EnvironmentType] }));\n  } else {\n    return Service.getByName(service).then(svc => ({\n      resource,\n      access,\n      clusters: [svc.OwningCluster] }));\n  }\n}\n\nmodule.exports = {\n  docs: {\n    requiresClusterPermissions: true,\n    requiresEnvironmentTypePermissions: true\n  },\n  getRules\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/authorizers/package-upload-url.js\n// module id = 222\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nexports.getRules = (request) => {\n  let body = request.params.body || request.body;\n  let cluster = request.params.range || request.params.cluster || body.OwningCluster;\n\n  return Promise.resolve([{\n    resource: request.url.replace(/\\/+$/, ''),\n    access: request.method,\n    clusters: [cluster.toLowerCase()]\n  }]);\n};\n\nexports.docs = {\n  requiresClusterPermissions: true,\n  requiresEnvironmentTypePermissions: false\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/authorizers/services.js\n// module id = 223\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nexports.getRules = request => Promise.resolve([{\n  resource: request.url.replace(/\\/+$/, ''),\n  access: request.method\n}]);\n\nexports.docs = {\n  requiresClusterPermissions: false,\n  requiresEnvironmentTypePermissions: false\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/authorizers/simple.js\n// module id = 224\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet co = require('co');\nlet environments = require('../data-access/configEnvironments');\nlet services = require('../data-access/services');\n\nmodule.exports = {\n  getRules(request) {\n    return co(function* () {\n      let environmentName = request.swagger.params.environment.value;\n      let environment = yield environments.get({ EnvironmentName: environmentName });\n\n      let serviceName = request.swagger.params.service.value;\n      let service = yield services.get({ ServiceName: serviceName });\n\n      return [{\n        resource: request.url.replace(/\\/+$/, ''),\n        access: request.method,\n        clusters: [service.OwningCluster],\n        environmentTypes: [environment.Value.EnvironmentType]\n      }];\n    });\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/authorizers/toggle-service-status.js\n// module id = 225\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet co = require('co');\nlet configEnvironments = require('../data-access/configEnvironments');\nlet loadBalancerUpstreams = require('../data-access/loadBalancerUpstreams');\nlet Environment = require('../../models/Environment');\nlet logger = require('../logger');\n\nfunction getUpstream(upstreamName) {\n  return loadBalancerUpstreams.get({ Key: upstreamName });\n}\n\nfunction getEnvironment(name) {\n  return configEnvironments.get({ EnvironmentName: name });\n}\n\nfunction getModifyPermissionsForEnvironment(environmentName) {\n  return getEnvironment(environmentName).then(environment => ({\n    cluster: environment.Value.OwningCluster.toLowerCase(),\n    environmentType: environment.Value.EnvironmentType.toLowerCase()\n  }));\n}\n\nfunction getEnvironmentPermissionsPromise(upstreamName, environmentName, accountName, method) {\n  if (method === 'POST') {\n    return getModifyPermissionsForEnvironment(environmentName);\n  }\n\n  return getUpstream(upstreamName)\n    .then((upstream) => {\n      if (upstream) {\n        let envName = upstream.Environment;\n        return getModifyPermissionsForEnvironment(envName);\n      }\n\n      throw new Error(`Could not find upstream: ${upstreamName}`);\n    });\n}\n\nexports.getRules = (request) => {\n  let r = /^\\/(.*)\\/config$/;\n  let upstreamName = request.params.key || request.params.name || request.params.body.key;\n  let accountName = request.params.account;\n\n  return co(function* () {\n    let body = request.params.body || request.body;\n    logger.debug('Upstreams authorizer', { body, url: request.url });\n    let environmentName = upstreamName.substr(1, 3);\n\n    if (accountName === undefined) {\n      accountName = yield Environment.getAccountNameForEnvironment(environmentName);\n    }\n\n    let match = r.exec(upstreamName);\n    let path = `/${request.params.account}/config/lbUpstream/${match[1]}`;\n    let getEnvironmentPermissions = getEnvironmentPermissionsPromise(upstreamName, environmentName, accountName, request.method);\n\n    return getEnvironmentPermissions.then(envPermissions => [{\n      resource: path,\n      access: request.method,\n      clusters: [envPermissions.cluster],\n      environmentTypes: [envPermissions.environmentType]\n    }]);\n  });\n};\n\nexports.docs = {\n  requiresClusterPermissions: true,\n  requiresEnvironmentTypePermissions: true\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/authorizers/upstreams.js\n// module id = 226\n// module chunks = 0","'use strict';\n\nconst path = require('path');\nconst apiSpec = require('../../api/swagger-doc');\nconst API_BASE_PATH = apiSpec.basePath;\nconst isNewRelicInUse = require('../new-relic/check');\n\nfunction newRelicSwaggerMiddleware(req, res, next) {\n  let newrelic = require('newrelic'); // eslint-disable-line global-require\n  newrelic.setTransactionName(path.join(API_BASE_PATH, req.path));\n  next();\n}\n\nfunction newRelicSwaggerMiddlewareNoOp(req, res, next) {\n  next();\n}\n\nconst swaggerNewRelic = isNewRelicInUse() ? newRelicSwaggerMiddleware : newRelicSwaggerMiddlewareNoOp;\n\nmodule.exports = swaggerNewRelic;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/express-middleware/swaggerNewRelicMiddleware.js\n// module id = 227\n// module chunks = 0","module.exports = require(\"js-yaml\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"js-yaml\"\n// module id = 228\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nmodule.exports = () => process.env.NEW_RELIC_APP_NAME !== undefined;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/new-relic/check.js\n// module id = 229\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nconst IS_PROD = require('../../config').get('IS_PRODUCTION');\nlet _ = require('lodash');\n\nfunction defaultErrorHandler(err, req, res, next) {\n  try {\n    let friendlyError = {};\n    if (res.statusCode >= 400 && res.statusCode < 500) {\n      try {\n        friendlyError.error = err.message;\n        friendlyError.details = _.map(_.get(err, 'results.errors'), error => `${error.path}: ${error.message}`);\n      } catch (error) {\n        friendlyError = err;\n      }\n    } else {\n      if (res.statusCode === 200) {\n        res.status(getStatusByErrorType(err));\n      }\n      friendlyError.error = err.message;\n    }\n\n    friendlyError.originalException = err;\n\n    if (IS_PROD && res.statusCode === 500) {\n      friendlyError = {\n        error: 'An internal error has occurred.'\n      };\n    } else if (res.statusCode === 409) {\n      friendlyError = {\n        error: 'The item you are attempting to update has already been modified. Check your expected-version.'\n      };\n    }\n\n    res.json(friendlyError);\n  } catch (error) {\n    next(error);\n  }\n}\n\nfunction getStatusByErrorType(error) {\n  switch (error.name) {\n    case 'AutoScalingGroupNotFoundError':\n    case 'ImageNotFoundError':\n    case 'InstanceNotFoundError':\n    case 'InstanceProfileNotFoundError':\n    case 'ResourceNotFoundError':\n    case 'RoleNotFoundError':\n    case 'SecurityGroupNotFoundError':\n    case 'TopicNotFoundError':\n    case 'DynamoItemNotFoundError': return 404;\n    case 'ResourceLockedError': return 423;\n    case 'EvalError':\n    case 'InternalError':\n    case 'RangeError':\n    case 'ReferenceError':\n    case 'SyntaxError':\n    case 'TypeError':\n    case 'URIError':\n    case 'AssertionError': return 500;\n\n    default: return 400;\n  }\n}\n\nmodule.exports = defaultErrorHandler;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/error-handler/defaultErrorHandler.js\n// module id = 230\n// module chunks = 0","'use strict';\n\nconst asgController = require('./asgs/asgController');\nconst auditController = require('./audit/auditController');\nconst accountsController = require('./config/accounts/accountsController');\nconst clusterController = require('./config/clusters/clusterController');\nconst deploymentMapController = require('./config/deployment-maps/deploymentMapController');\nconst environmentTypeController = require('./config/environment-types/environmentTypeController');\nconst environmentsConfigController = require('./config/environments/environmentsConfigController');\nconst exportController = require('./config/export/exportController');\nconst importController = require('./config/import/importController');\nconst lbSettingsController = require('./config/lb-settings/lbSettingsController');\nconst notificationSettingsController = require('./config/notification-settings/notificationSettingsController');\nconst permissionsController = require('./config/permissions/permissionsController');\nconst serverRoleController = require('./config/server-roles/serverRoleController');\nconst servicesConfigController = require('./config/services/servicesConfigController');\nconst upstreamsConfigController = require('./config/upstreams/upstreamsConfigController');\nconst deploymentsController = require('./deployments/deploymentsController');\nconst diagnosticsController = require('./diagnostics/diagnosticsController');\nconst environmentsController = require('./environments/environmentsController');\nconst imagesController = require('./images/imagesController');\nconst instancesController = require('./instances/instancesController');\nconst loadBalancerController = require('./load-balancer/loadBalancerController');\nconst dynamicResponseCreator = require('./package-upload-url/dynamicResponseCreator');\nconst packageUploadUrlController = require('./package-upload-url/packageUploadUrlController');\nconst servicesController = require('./services/servicesController');\nconst targetStateController = require('./target-state/targetStateController');\nconst tokenController = require('./token/tokenController');\nconst upstreamsController = require('./upstreams/upstreamsController');\nconst userController = require('./user/userController');\n\nfunction getFunctions(obj) {\n  return Object.keys(obj)\n    .map(k => [k, obj[k]])\n    .filter(([, v]) => typeof v === 'function');\n}\n\nconst controllerModules = {\n  asgController,\n  auditController,\n  accountsController,\n  clusterController,\n  deploymentMapController,\n  environmentTypeController,\n  environmentsConfigController,\n  exportController,\n  importController,\n  lbSettingsController,\n  notificationSettingsController,\n  permissionsController,\n  serverRoleController,\n  servicesConfigController,\n  upstreamsConfigController,\n  deploymentsController,\n  diagnosticsController,\n  environmentsController,\n  imagesController,\n  instancesController,\n  loadBalancerController,\n  dynamicResponseCreator,\n  packageUploadUrlController,\n  servicesController,\n  targetStateController,\n  tokenController,\n  upstreamsController,\n  userController\n};\n\nfunction controllers() {\n  return Object.keys(controllerModules)\n    .map(k => [k, controllerModules[k]])\n    .map(([moduleName, $module]) => {\n      return getFunctions($module).reduce((acc, [memberName, fun]) => Object.assign(acc, { [`${moduleName}_${memberName}`]: fun }), {});\n    })\n    .reduce((acc, nxt) => Object.assign(acc, nxt), {});\n}\nmodule.exports = controllers;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/controllers/index.js\n// module id = 231\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet Promise = require('bluebird');\nlet co = require('co');\nlet getAllASGs = require('../../../queryHandlers/ScanCrossAccountAutoScalingGroups');\nlet getAccountASGs = require('../../../queryHandlers/ScanAutoScalingGroups');\nlet getASG = require('../../../queryHandlers/GetAutoScalingGroup');\nlet AutoScalingGroup = require('../../../models/AutoScalingGroup');\nlet asgips = require('../../../modules/data-access/asgips');\nlet GetLaunchConfiguration = require('../../../queryHandlers/GetLaunchConfiguration');\nlet SetLaunchConfiguration = require('../../../commands/launch-config/SetLaunchConfiguration');\nlet SetAutoScalingGroupSize = require('../../../commands/asg/SetAutoScalingGroupSize');\nlet SetAutoScalingGroupSchedule = require('../../../commands/asg/SetAutoScalingGroupSchedule');\nlet UpdateAutoScalingGroup = require('../../../commands/asg/UpdateAutoScalingGroup');\nlet GetAutoScalingGroupScheduledActions = require('../../../queryHandlers/GetAutoScalingGroupScheduledActions');\nlet GetAutoScalingGroupLifeCycleHooks = require('../../../queryHandlers/GetAutoScalingGroupLifeCycleHooks');\nlet getASGReady = require('../../../modules/environment-state/getASGReady');\nlet Environment = require('../../../models/Environment');\nlet sns = require('../../../modules/sns/EnvironmentManagerEvents');\nlet opsEnvironment = require('../../../modules/data-access/opsEnvironment');\n\nclass ValidationError extends Error {\n  constructor(obj) {\n    super();\n    Object.assign(this, obj);\n  }\n}\n\nfunction checkEnvironmentExists(environmentName) {\n  return environment => (environment\n    ? Promise.resolve(environment)\n    : Promise.reject(new ValidationError({\n      errors: [\n        { title: 'Environment Not Found', detail: `environment name: ${environmentName}` }\n      ],\n      status: 400\n    })));\n}\n\nfunction checkEnvironmentUnlocked(environment) {\n  return Promise.resolve()\n    .then(() => {\n      let { EnvironmentName, Value: { DeploymentsLocked = false } = {} } = environment || {};\n      return DeploymentsLocked\n        ? Promise.reject(new ValidationError({\n          errors: [\n            { title: 'Environment Locked', detail: `environment name: ${EnvironmentName}` }\n          ],\n          status: 400\n        }))\n        : Promise.resolve(environment);\n    });\n}\n\nfunction handleValidationErrors(res) {\n  return error => (error instanceof ValidationError\n    ? res.status(error.status || 400).json({ errors: error.errors })\n    : Promise.reject(error));\n}\n\n/**\n * GET /asgs\n */\nfunction getAsgs(req, res, next) {\n  const accountName = req.swagger.params.account.value;\n  const environment = req.swagger.params.environment.value;\n\n  return co(function* () {\n    let list;\n    if (environment !== undefined) {\n      let account = yield Environment.getAccountNameForEnvironment(environment);\n      let t = yield getAccountASGs({\n        accountName: account\n      });\n      list = t.filter(asg => asg.getTag('Environment') === environment);\n    } else if (accountName !== undefined) {\n      list = yield getAccountASGs({\n        accountName\n      });\n    } else {\n      list = yield getAllASGs();\n    }\n\n    res.json(list);\n  }).catch(next);\n}\n\n/**\n * GET /asgs/{name}\n */\nfunction getAsgByName(req, res, next) {\n  const autoScalingGroupName = req.swagger.params.name.value;\n  const environmentName = req.swagger.params.environment.value;\n\n  return co(function* () {\n    let accountName = yield Environment.getAccountNameForEnvironment(environmentName);\n    let lifecycleHooks = yield GetAutoScalingGroupLifeCycleHooks({ accountName, autoScalingGroupName });\n    return getASG({ accountName, autoScalingGroupName }).then((data) => {\n      res.json(Object.assign({}, data, { LifecycleHooks: lifecycleHooks }));\n    });\n  }).catch(next);\n}\n\n\n/**\n * GET /asgs/{name}/ready\n */\nfunction getAsgReadyByName(req, res, next) {\n  const autoScalingGroupName = req.swagger.params.name.value;\n  const environmentName = req.swagger.params.environment.value;\n\n  return getASGReady({\n    autoScalingGroupName,\n    environmentName\n  })\n    .then(data => res.json(data)).catch(next);\n}\n\n\n/**\n * GET /asgs/{name}/ips\n */\nfunction getAsgIps(req, res, next) {\n  const key = req.swagger.params.name.value;\n  const environmentName = req.swagger.params.environment.value;\n  return co(function* () {\n    let accountName = yield Environment.getAccountNameForEnvironment(environmentName);\n    asgips.get(accountName, { AsgName: key }).then(data => res.json(data));\n  }).catch(next);\n}\n\n/**\n * GET /asgs/{name}/launch-config\n */\nfunction getAsgLaunchConfig(req, res, next) {\n  const environmentName = req.swagger.params.environment.value;\n  const autoScalingGroupName = req.swagger.params.name.value;\n\n  return co(function* () {\n    let accountName = yield Environment.getAccountNameForEnvironment(environmentName);\n    GetLaunchConfiguration({ accountName, autoScalingGroupName }).then(data => res.json(data));\n  }).catch(next);\n}\n\n/**\n * GET /asgs/{name}/scaling-schedule\n */\nfunction getScalingSchedule(req, res, next) {\n  const environmentName = req.swagger.params.environment.value;\n  const autoScalingGroupName = req.swagger.params.name.value;\n\n  return co(function* () {\n    let accountName = yield Environment.getAccountNameForEnvironment(environmentName);\n    GetAutoScalingGroupScheduledActions({ accountName, autoScalingGroupName }).then(data => res.json(data));\n  }).catch(next);\n}\n\n/**\n * PUT /asgs/{name}\n */\nfunction putAsg(req, res, next) {\n  const environmentName = req.swagger.params.environment.value;\n  const autoScalingGroupName = req.swagger.params.name.value;\n  const parameters = req.swagger.params.body.value;\n\n  return opsEnvironment.get({ EnvironmentName: environmentName })\n    .then(checkEnvironmentExists(environmentName))\n    .then(checkEnvironmentUnlocked)\n    .then(() => UpdateAutoScalingGroup({\n      environmentName,\n      autoScalingGroupName,\n      parameters\n    }))\n    .then(data => res.json(data))\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: `/asgs/${autoScalingGroupName}`,\n          Method: 'PUT'\n        }\n      }),\n      topic: sns.TOPICS.OPERATIONS_CHANGE,\n      attributes: {\n        Environment: environmentName,\n        Action: sns.ACTIONS.PUT,\n        ID: autoScalingGroupName\n      }\n    }))\n    .catch(handleValidationErrors(res))\n    .catch(next);\n}\n\n/**\n * DELETE /asgs/{name}\n */\nfunction deleteAsg(req, res, next) {\n  const environmentName = req.swagger.params.environment.value;\n  const autoScalingGroupName = req.swagger.params.name.value;\n\n  return opsEnvironment.get({ EnvironmentName: environmentName })\n    .then(checkEnvironmentExists(environmentName))\n    .then(checkEnvironmentUnlocked)\n    .then(() => Environment.getAccountNameForEnvironment(environmentName))\n    .then(accountName => AutoScalingGroup.getByName(accountName, autoScalingGroupName))\n    .then(asg => asg.deleteASG())\n    .then((status) => { res.json({ Ok: status }); })\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: `/asgs/${autoScalingGroupName}`,\n          Method: 'DELETE'\n        }\n      }),\n      topic: sns.TOPICS.OPERATIONS_CHANGE,\n      attributes: {\n        Environment: environmentName,\n        Action: sns.ACTIONS.DELETE,\n        ID: autoScalingGroupName\n      }\n    }))\n    .catch(handleValidationErrors(res))\n    .catch(next);\n}\n\n/**\n * PUT /asgs/{name}/scaling-schedule\n */\nfunction putScalingSchedule(req, res, next) {\n  const { propagateToInstances, schedule } = req.swagger.params.body.value;\n  const environmentName = req.swagger.params.environment.value;\n  const autoScalingGroupName = req.swagger.params.name.value;\n\n  return opsEnvironment.get({ EnvironmentName: environmentName })\n    .then(checkEnvironmentExists(environmentName))\n    .then(checkEnvironmentUnlocked)\n    .then(() => Environment.getAccountNameForEnvironment(environmentName))\n    .then(accountName => SetAutoScalingGroupSchedule({\n      accountName,\n      autoScalingGroupName,\n      schedule,\n      propagateToInstances\n    }))\n    .then(data => res.json(data))\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: `/asgs/${autoScalingGroupName}/scaling-schedule`,\n          Method: 'PUT'\n        }\n      }),\n      topic: sns.TOPICS.OPERATIONS_CHANGE,\n      attributes: {\n        Environment: environmentName,\n        Action: sns.ACTIONS.PUT,\n        ID: autoScalingGroupName\n      }\n    }))\n    .catch(handleValidationErrors(res))\n    .catch(next);\n}\n\n/**\n * PUT /asgs/{name}/size\n */\nfunction putAsgSize(req, res, next) {\n  const environmentName = req.swagger.params.environment.value;\n  const autoScalingGroupName = req.swagger.params.name.value;\n  const body = req.swagger.params.body.value;\n  const autoScalingGroupMinSize = body.min;\n  const autoScalingGroupDesiredSize = body.desired;\n  const autoScalingGroupMaxSize = body.max;\n\n  return opsEnvironment.get({ EnvironmentName: environmentName })\n    .then(checkEnvironmentExists(environmentName))\n    .then(checkEnvironmentUnlocked)\n    .then(() => Environment.getAccountNameForEnvironment(environmentName))\n    .then(accountName => SetAutoScalingGroupSize({\n      accountName,\n      autoScalingGroupName,\n      autoScalingGroupMinSize,\n      autoScalingGroupDesiredSize,\n      autoScalingGroupMaxSize\n    }))\n    .then(data => res.json(data))\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: `/asgs/${autoScalingGroupName}/size`,\n          Method: 'PUT'\n        }\n      }),\n      topic: sns.TOPICS.OPERATIONS_CHANGE,\n      attributes: {\n        Environment: environmentName,\n        Action: sns.ACTIONS.PUT,\n        ID: autoScalingGroupName\n      }\n    }))\n    .catch(handleValidationErrors(res))\n    .catch(next);\n}\n\n/**\n * PUT /asgs/{name}/launch-config\n */\nfunction putAsgLaunchConfig(req, res, next) {\n  const environmentName = req.swagger.params.environment.value;\n  const data = req.swagger.params.body.value;\n  const autoScalingGroupName = req.swagger.params.name.value;\n\n  return opsEnvironment.get({ EnvironmentName: environmentName })\n    .then(checkEnvironmentExists(environmentName))\n    .then(checkEnvironmentUnlocked)\n    .then(() => Environment.getAccountNameForEnvironment(environmentName))\n    .then(accountName => SetLaunchConfiguration({\n      accountName,\n      autoScalingGroupName,\n      data\n    }))\n    .then(x => res.json(x))\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: `/asgs/${autoScalingGroupName}/launch-config`,\n          Method: 'PUT'\n        }\n      }),\n      topic: sns.TOPICS.OPERATIONS_CHANGE,\n      attributes: {\n        Environment: environmentName,\n        Action: sns.ACTIONS.PUT,\n        ID: autoScalingGroupName\n      }\n    }))\n    .catch(handleValidationErrors(res))\n    .catch(next);\n}\n\nmodule.exports = {\n  getAsgs,\n  getAsgByName,\n  getAsgReadyByName,\n  getAsgIps,\n  getAsgLaunchConfig,\n  putScalingSchedule,\n  getScalingSchedule,\n  deleteAsg,\n  putAsg,\n  putAsgSize,\n  putAsgLaunchConfig\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/controllers/asgs/asgController.js\n// module id = 232\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet scanCrossAccount = require('../modules/queryHandlersUtil/scanCrossAccount');\nlet ScanAutoScalingGroups = require('./ScanAutoScalingGroups');\n\nmodule.exports = function ScanCrossAccountAutoScalingGroups(query) {\n  return scanCrossAccount(ScanAutoScalingGroups, query, 'ScanAutoScalingGroups');\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/queryHandlers/ScanCrossAccountAutoScalingGroups.js\n// module id = 233\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet sender = require('../sender');\nlet scanCrossAccountFn = require('./scanCrossAccountFn');\n\nfunction scanCrossAccount(query, simpleScanQueryName) {\n  function queryAccount(account) {\n    let childQuery = Object.assign({ name: simpleScanQueryName, accountName: account.AccountName }, query);\n    return sender.sendQuery({ query: childQuery, parent: query });\n  }\n  return scanCrossAccountFn(queryAccount);\n}\n\nmodule.exports = scanCrossAccount;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/queryHandlersUtil/scanCrossAccount.js\n// module id = 234\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet co = require('co');\nlet AutoScalingGroup = require('../models/AutoScalingGroup');\nlet instanceDevicesProvider = require('../modules/provisioning/launchConfiguration/instanceDevicesProvider');\nlet Image = require('../models/Image');\nlet SecurityGroup = require('../models/SecurityGroup');\n\nlet _ = require('lodash');\n\nmodule.exports = function GetLaunchConfiguration(query) {\n  let accountName = query.accountName;\n  let autoScalingGroupName = query.autoScalingGroupName;\n\n  return co(function* () {\n    let autoScalingGroup = yield AutoScalingGroup.getByName(accountName, autoScalingGroupName);\n    let awsLaunchConfig = yield autoScalingGroup.getLaunchConfiguration();\n\n    let Volumes = instanceDevicesProvider.fromAWS(awsLaunchConfig.BlockDeviceMappings);\n\n    let image = yield Image.getById(awsLaunchConfig.ImageId);\n\n    let environmentType = yield autoScalingGroup.getEnvironmentType();\n    let vpcId = environmentType.VpcId;\n\n    let securityGroups = yield SecurityGroup.getAllByIds(accountName, vpcId, awsLaunchConfig.SecurityGroups);\n    let securityGroupsNames = _.map(securityGroups, group => group.getTag('Name'));\n\n    let ret = {\n      ImageId: image.ImageId,\n      AMI: image.Name, // TODO: find AMI\n      InstanceProfileName: awsLaunchConfig.IamInstanceProfile,\n      InstanceType: awsLaunchConfig.InstanceType,\n      SecurityGroups: securityGroupsNames,\n      Volumes,\n      UserData: new Buffer(awsLaunchConfig.UserData, 'base64').toString('ascii')\n    };\n\n    return ret;\n  });\n};\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/queryHandlers/GetLaunchConfiguration.js\n// module id = 235\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet _ = require('lodash');\nlet sender = require('../modules/sender');\nlet co = require('co');\nlet ScanCrossAccountImages = require('../queryHandlers/ScanCrossAccountImages');\n\nclass Image {\n\n  constructor(data) {\n    _.assign(this, data);\n  }\n\n  static getById(id) {\n    return co(function* () {\n      let images = yield sender.sendQuery(ScanCrossAccountImages, {\n        query: {\n          name: 'ScanCrossAccountImages'\n        }\n      });\n      let image = _.find(images, { ImageId: id });\n      return new Image(image);\n    });\n    // let image = yield imageProvider.get(awsLaunchConfig.ImageId);\n  }\n\n}\n\nmodule.exports = Image;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/models/Image.js\n// module id = 236\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nconst securityGroupResourceFactory = require('../modules/resourceFactories/securityGroupResourceFactory');\n\nmodule.exports = function ScanSecurityGroupsQueryHandler(query) {\n  let parameters = { accountName: query.accountName };\n\n  return securityGroupResourceFactory.create(undefined, parameters).then((resource) => {\n    let request = {\n      vpcId: query.vpcId,\n      groupIds: query.groupIds,\n      groupNames: query.groupNames\n    };\n\n    return resource.scan(request);\n  });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/queryHandlers/ScanSecurityGroups.js\n// module id = 237\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet amazonClientFactory = require('../amazon-client/childAccountClient');\nlet SecurityGroupResource = require('./SecurityGroupResource');\n\nmodule.exports = {\n\n  canCreate: resourceDescriptor =>\n    resourceDescriptor.type.toLowerCase() === 'ec2/sg',\n\n  create: (resourceDescriptor, parameters) =>\n    amazonClientFactory.createEC2Client(parameters.accountName).then(client => new SecurityGroupResource(client))\n\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/resourceFactories/securityGroupResourceFactory.js\n// module id = 238\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nfunction createRequest(parameters) {\n  if (!parameters) return {};\n\n  let request = {\n    Filters: [\n      { Name: 'vpc-id', Values: [parameters.vpcId] }\n    ]\n  };\n\n  if (parameters.groupIds) {\n    request.Filters.push({ Name: 'group-id', Values: parameters.groupIds });\n  }\n\n  if (parameters.groupNames) {\n    request.Filters.push({ Name: 'tag-key', Values: ['Name'] });\n    request.Filters.push({ Name: 'tag-value', Values: parameters.groupNames });\n  }\n\n  return request;\n}\n\nfunction SecurityGroupResource(client) {\n  this.scan = function (parameters) {\n    let request = createRequest(parameters);\n    return client.describeSecurityGroups(request).promise().then(response => response.SecurityGroups);\n  };\n}\n\nmodule.exports = SecurityGroupResource;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/resourceFactories/SecurityGroupResource.js\n// module id = 239\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet launchConfigUpdater = require('./launchConfigUpdater');\nlet co = require('co');\nlet sender = require('../../modules/sender');\nlet logger = require('../../modules/logger');\nlet _ = require('lodash');\n\nlet imageProvider = require('../../modules/provisioning/launchConfiguration/imageProvider');\nlet instanceDevicesProvider = require('../../modules/provisioning/launchConfiguration/instanceDevicesProvider');\nlet securityGroupsProvider = require('../../modules/provisioning/launchConfiguration/securityGroupsProvider');\n\nlet AutoScalingGroup = require('../../models/AutoScalingGroup');\nlet GetInstanceProfile = require('../../queryHandlers/GetInstanceProfile');\n\nmodule.exports = function SetLaunchConfiguration(command) {\n  return co(function* () {\n    let data = command.data;\n    let updated = {};\n    let autoScalingGroup = yield AutoScalingGroup.getByName(command.accountName, command.autoScalingGroupName);\n    let originalLaunchConfiguration = yield autoScalingGroup.getLaunchConfiguration();\n\n    // Get the image and disk size specified\n    let image = yield imageProvider.get(data.AMI || originalLaunchConfiguration.ImageId);\n    let osDiskSize = getOSDiskSize(data.Volumes, originalLaunchConfiguration.BlockDeviceMappings);\n\n    // Check the OS disk size supports that image\n    if (osDiskSize < image.rootVolumeSize) {\n      throw new Error(`The specified OS volume size (${osDiskSize} GB) is not sufficient for image '${image.name}' (${image.rootVolumeSize} GB)`);\n    }\n\n    let environmentType = yield autoScalingGroup.getEnvironmentType();\n    let vpcId = environmentType.VpcId;\n\n    if (data.InstanceProfileName !== undefined) {\n      // That's checking if this instance profile name exists\n      yield getInstanceProfileByName(command.accountName, data.InstanceProfileName);\n      updated.IamInstanceProfile = data.InstanceProfileName;\n    }\n\n    if (data.InstanceType !== undefined) {\n      updated.InstanceType = data.InstanceType;\n    }\n\n    if (data.Volumes !== undefined) {\n      updated.BlockDeviceMappings = instanceDevicesProvider.toAWS(data.Volumes);\n    }\n\n    if (data.SecurityGroups !== undefined) {\n      let securityGroupsNamesAndReasons = _.map(data.SecurityGroups, name => ({\n        name,\n        reason: 'It was set by user in LaunchConfig form'\n      }));\n      let securityGroups = yield securityGroupsProvider.getFromSecurityGroupNames(command.accountName, vpcId, securityGroupsNamesAndReasons, logger);\n      updated.SecurityGroups = _.map(securityGroups, 'GroupId');\n    }\n\n    if (data.AMI !== undefined) {\n      updated.ImageId = image.id;\n    }\n\n    if (data.UserData !== undefined) {\n      updated.UserData = new Buffer(data.UserData).toString('base64');\n    }\n\n    let accountName = command.accountName;\n    let autoScalingGroupName = command.autoScalingGroupName;\n\n    logger.debug(`Updating ASG ${autoScalingGroupName} with: ${JSON.stringify(updated)}`);\n\n    return launchConfigUpdater.set(\n      accountName,\n      autoScalingGroup,\n      (launchConfiguration) => {\n        _.assign(launchConfiguration, updated);\n      }\n    );\n  });\n};\n\nfunction getOSDiskSize(newVolumes, originalBlockDeviceMappings) {\n  if (newVolumes !== undefined) {\n    let newOSVolume = _.find(newVolumes, v => v.Name === 'OS');\n    return newOSVolume.Size;\n  }\n\n  let originalOSBlockDeviceMapping = _.find(originalBlockDeviceMappings, d => _.includes(['/dev/sda1', '/dev/xvda'], d.DeviceName));\n  return originalOSBlockDeviceMapping.Ebs.VolumeSize;\n}\n\nfunction getInstanceProfileByName(accountName, instanceProfileName) {\n  let query = {\n    name: 'GetInstanceProfile',\n    accountName,\n    instanceProfileName\n  };\n\n  return sender.sendQuery(GetInstanceProfile, { query });\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/commands/launch-config/SetLaunchConfiguration.js\n// module id = 240\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet co = require('co');\nconst asgResourceFactory = require('../../modules/resourceFactories/asgResourceFactory');\nconst launchConfigurationResourceFactory = require('../../modules/resourceFactories/launchConfigurationResourceFactory');\n\nmodule.exports = {\n  //\n  set(accountName, autoScalingGroup, updateAction) {\n    return co(function* () {\n      // Obtain an object containing resource instances to work with\n      // LaunchConfigurations and AutoScalingGroups\n      //\n      let autoScalingGroupName = autoScalingGroup.$autoScalingGroupName;\n\n      let launchConfigurationClient = yield launchConfigurationResourceFactory.create(undefined, { accountName });\n      let autoScalingGroupClient = yield asgResourceFactory.create(undefined, { accountName });\n\n      // Send a request to obtain the LaunchConfiguration for the specific\n      // AutoScalingGroup\n      // [AutoScalingGroup] <---> [LaunchConfiguration]\n      //\n      let originalLaunchConfiguration = yield autoScalingGroup.getLaunchConfiguration();\n\n      // Clone the original LaunchConfiguration creating a backup version\n      // [AutoScalingGroup] <---> [LaunchConfiguration]\n      //                          [LaunchConfiguration_Backup] (creating ...)\n\n      let backupLaunchConfiguration = Object.assign({}, originalLaunchConfiguration);\n      backupLaunchConfiguration.LaunchConfigurationName += '_Backup';\n\n      yield launchConfigurationClient.post(backupLaunchConfiguration);\n\n      // Attach the backup LaunchConfiguration just created to the target AutoScalingGroup\n      //                          [LaunchConfiguration]\n      // [AutoScalingGroup] <---> [LaunchConfiguration_Backup]\n\n      yield attachLaunchConfigurationToAutoScalingGroup(\n        autoScalingGroupClient, autoScalingGroupName, backupLaunchConfiguration\n      );\n\n      // Delete the original LaunchConfiguration (a LaunchConfiguration cannot be\n      // changed. Only way is delete it and create it again).\n      //                          [LaunchConfiguration] (deleting...)\n      // [AutoScalingGroup] <---> [LaunchConfiguration_Backup]\n\n      yield launchConfigurationClient.delete({ name: originalLaunchConfiguration.LaunchConfigurationName });\n\n      // Create a new LaunchConfiguration starting from the original applying an\n      // updateAction function on it.\n      //                          [LaunchConfiguration] (creating ...)\n      // [AutoScalingGroup] <---> [LaunchConfiguration_Backup]\n\n      let updatedLaunchConfiguration = Object.assign({}, originalLaunchConfiguration);\n      updateAction(updatedLaunchConfiguration);\n\n      yield launchConfigurationClient.post(updatedLaunchConfiguration);\n\n      // Attach new LaunchConfiguration to the target AutoScalingGroup.\n      // NOTE: this LaunchConfiguration is equal to the original one but updated.\n      // [AutoScalingGroup] <---> [LaunchConfiguration]\n      //                          [LaunchConfiguration_Backup]\n\n      yield attachLaunchConfigurationToAutoScalingGroup(\n        autoScalingGroupClient, autoScalingGroupName, updatedLaunchConfiguration\n      );\n\n      // Delete the backup LaunchConfiguration as no longer needed.\n      // [AutoScalingGroup] <---> [LaunchConfiguration]\n      //                          [LaunchConfiguration_Backup] (deleting...)\n      yield launchConfigurationClient.delete({ name: backupLaunchConfiguration.LaunchConfigurationName });\n    });\n  }\n};\n\nfunction attachLaunchConfigurationToAutoScalingGroup(autoScalingGroupClient, autoScalingGroupName, launchConfiguration) {\n  let parameters = {\n    name: autoScalingGroupName,\n    launchConfigurationName: launchConfiguration.LaunchConfigurationName\n  };\n\n  return autoScalingGroupClient.put(parameters);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/commands/launch-config/launchConfigUpdater.js\n// module id = 241\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet amazonClientFactory = require('../amazon-client/childAccountClient');\n\nlet AwsError = require('../errors/AwsError.class');\nlet InstanceProfileNotFoundError = require('../errors/InstanceProfileNotFoundError.class');\nlet assert = require('assert');\n\nfunction InstanceProfileResource(client) {\n  this.client = client;\n\n  this.get = function (parameters) {\n    assert(parameters.instanceProfileName);\n\n    let request = {\n      InstanceProfileName: parameters.instanceProfileName\n    };\n\n    return client.getInstanceProfile(request).promise()\n      .then(response => response.InstanceProfile)\n      .catch((error) => {\n        throw prettifyError(error, request);\n      });\n  };\n\n  function prettifyError(error, request) {\n    if (error.code === 'NoSuchEntity') {\n      return new InstanceProfileNotFoundError(`Instance profile \"${request.InstanceProfileName}\" not found.`);\n    } else {\n      return new AwsError(`An error has occurred getting Iam instance profile: ${error.message}`);\n    }\n  }\n}\n\nmodule.exports = {\n  canCreate: resourceDescriptor =>\n    resourceDescriptor.type.toLowerCase() === 'iam/instanceprofiles',\n\n  create: (resourceDescriptor, parameters) =>\n    amazonClientFactory.createIAMClient(parameters.accountName).then(client => new InstanceProfileResource(client))\n\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/resourceFactories/iamInstanceProfileResourceFactory.js\n// module id = 242\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet util = require('util');\nlet BaseError = require('./BaseError.class');\n\nmodule.exports = function InstanceProfileNotFoundError(message, innerError) {\n  this.name = this.constructor.name;\n  this.message = message;\n  this.innerError = innerError;\n\n  Error.captureStackTrace(this, this.constructor);\n};\n\nutil.inherits(module.exports, BaseError);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/errors/InstanceProfileNotFoundError.class.js\n// module id = 243\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet _ = require('lodash');\nlet co = require('co');\nlet autoScalingGroupClientFactory = require('../../modules/resourceFactories/asgResourceFactory');\n\n// TODO: Check redundant escapes in regex (eslint no-useless-escape)\nlet SCHEDULE_PATTERN = /^(NOSCHEDULE\\s+)?((247|OFF|on|on6)|(((Start|Stop): [\\d\\,\\-\\*\\\\]+ [\\d\\,\\-\\*\\\\]+ [\\d\\,\\-\\*\\\\\\w]+ [\\d\\,\\-\\*\\\\\\w]+ [\\d\\,\\-\\*\\\\\\w]+\\s?[\\d\\,\\-\\*]*)(\\s*\\;?\\s+|$))+)?(\\s*NOSCHEDULE)?(\\s*|.*)?$/i;\nlet InvalidOperationError = require('../../modules/errors/InvalidOperationError.class');\nlet ec2InstanceClientFactory = require('../../modules/resourceFactories/ec2InstanceResourceFactory');\nlet AutoScalingGroup = require('../../models/AutoScalingGroup');\n\nmodule.exports = function SetAutoScalingGroupScheduleCommandHandler(command) {\n  return co(function* () {\n    let schedule = command.schedule;\n    let accountName = command.accountName;\n    let autoScalingGroupName = command.autoScalingGroupName;\n    let propagateToInstances = command.propagateToInstances;\n\n    let scalingSchedule;\n    if (_.isArray(command.schedule)) {\n      scalingSchedule = command.schedule;\n      schedule = 'NOSCHEDULE';\n    } else {\n      scalingSchedule = [];\n      schedule = command.schedule;\n    }\n\n    if (!SCHEDULE_PATTERN.exec(schedule)) {\n      return Promise.reject(new InvalidOperationError(\n        `Provided schedule is invalid. Current value: \"${schedule}\".`\n      ));\n    }\n\n    let result = {\n      ChangedAutoScalingGroups: undefined,\n      ChangedInstances: undefined\n    };\n\n    result.ChangedAutoScalingGroups = yield setAutoScalingGroupSchedule(\n      autoScalingGroupName,\n      schedule,\n      scalingSchedule,\n      accountName\n    );\n\n    if (propagateToInstances) {\n      let autoScalingGroup = yield AutoScalingGroup.getByName(accountName, autoScalingGroupName);\n      let instanceIds = autoScalingGroup.Instances.map(instance => instance.InstanceId);\n\n      result.ChangedInstances = yield setEC2InstancesScheduleTag(\n        instanceIds,\n        schedule,\n        accountName\n      );\n    }\n\n    return result;\n  });\n};\n\nfunction setAutoScalingGroupSchedule(autoScalingGroupName, schedule, scalingSchedule, accountName) {\n  return autoScalingGroupClientFactory.create(undefined, { accountName }).then((client) => {\n    let setScheduleTask = setAutoScalingGroupScalingSchedule(client, autoScalingGroupName, scalingSchedule, accountName);\n    let setTagsTask = setAutoScalingGroupScheduleTag(client, autoScalingGroupName, schedule, accountName);\n\n    return Promise\n      .all([setScheduleTask, setTagsTask])\n      .then(() => [autoScalingGroupName]);\n  });\n}\n\nfunction setAutoScalingGroupScheduleTag(client, autoScalingGroupName, schedule) {\n  let parameters = {\n    name: autoScalingGroupName,\n    tagKey: 'Schedule',\n    tagValue: schedule\n  };\n\n  return client.setTag(parameters);\n}\n\nfunction setAutoScalingGroupScalingSchedule(client, autoScalingGroupName, newScheduledActions) {\n  let defaultIfNil = (def, obj) => (obj !== null && obj !== undefined ? obj : def);\n  return co(function* () {\n    let existingScheduledActions = yield getScheduledActions(client, autoScalingGroupName);\n    yield existingScheduledActions.map(action => deleteScheduledAction(client, action));\n\n    if (!(newScheduledActions instanceof Array)) return Promise.resolve();\n\n    return yield newScheduledActions.map((action, index) => {\n      let desiredCapacityIfNil = defaultIfNil.bind(null, action.DesiredCapacity);\n      let namedAction = {\n        AutoScalingGroupName: autoScalingGroupName,\n        ScheduledActionName: `EM-Scheduled-Action-${index + 1}`,\n        MinSize: desiredCapacityIfNil(action.MinSize),\n        MaxSize: desiredCapacityIfNil(action.MaxSize),\n        DesiredCapacity: action.DesiredCapacity,\n        Recurrence: action.Recurrence\n      };\n      return client.createScheduledAction(namedAction);\n    });\n  });\n}\n\nfunction getScheduledActions(client, autoScalingGroupName) {\n  let parameters = {\n    AutoScalingGroupName: autoScalingGroupName\n  };\n  return client.describeScheduledActions(parameters);\n}\n\nfunction deleteScheduledAction(client, action) {\n  let parameters = {\n    AutoScalingGroupName: action.AutoScalingGroupName,\n    ScheduledActionName: action.ScheduledActionName\n  };\n  return client.deleteScheduledAction(parameters);\n}\n\nfunction setEC2InstancesScheduleTag(instanceIds, schedule, accountName) {\n  if (!instanceIds.length) return Promise.resolve();\n  return ec2InstanceClientFactory.create(undefined, { accountName }).then((client) => {\n    let parameters = {\n      instanceIds,\n      tagKey: 'Schedule',\n      tagValue: schedule\n    };\n\n    return client.setTag(parameters).then(() => instanceIds);\n  });\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/commands/asg/SetAutoScalingGroupSchedule.js\n// module id = 244\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet co = require('co');\nlet _ = require('lodash');\nlet InvalidOperationError = require('../../modules/errors/InvalidOperationError.class');\nlet subnetsProvider = require('../../modules/provisioning/autoScaling/subnetsProvider');\nlet Environment = require('../../models/Environment');\nlet EnvironmentType = require('../../models/EnvironmentType');\nconst asgResourceFactory = require('../../modules/resourceFactories/asgResourceFactory');\n\nfunction* handler(command) {\n  // Validation\n  let size = command.parameters.size;\n\n  if (!_.isNil(size.min)) {\n    if (!_.isNil(size.max) && size.min > size.max) {\n      throw new InvalidOperationError(\n        `Provided Max size '${size.max}' must be greater than or equal to the Min size '${size.min}'.`\n      );\n    }\n\n    if (!_.isNil(size.desired) && size.desired < size.min) {\n      throw new InvalidOperationError(\n        `Provided Desired size '${size.desired}' must be greater than or equal to the Min size '${size.min}'.`\n      );\n    }\n  }\n\n  if (!_.isNil(size.max)) {\n    if (!_.isNil(size.min) && size.min > size.max) {\n      throw new InvalidOperationError(\n        `Provided Min size '${size.min}' must be less than or equal to the Max size '${size.max}'.`\n      );\n    }\n\n    if (!_.isNil(size.desired) && size.desired > size.max) {\n      throw new InvalidOperationError(\n        `Provided Desired size '${size.desired}' must be less than or equal to the Max size '${size.max}'.`\n      );\n    }\n  }\n\n  // Get a resource instance to work with AutoScalingGroup in the proper\n  // AWS account.\n  let accountName = yield Environment.getAccountNameForEnvironment(command.environmentName);\n  let resource = yield asgResourceFactory.create(undefined, {\n    accountName\n  });\n\n  let subnets;\n\n  let network = command.parameters.network;\n  if (!_.isNil(network)) {\n    let environment = yield Environment.getByName(command.environmentName);\n    let environmentType = yield EnvironmentType.getByName(environment.EnvironmentType);\n    let asg = yield resource.get({\n      name: command.autoScalingGroupName\n    });\n\n    let currentSubnet = asg.VPCZoneIdentifier.split(',')[0];\n    let currentSubnetType = getSubnetTypeBySubnet(environmentType.Subnets, currentSubnet);\n\n    subnets = yield subnetsProvider.get({\n      serverRole: {\n        SecurityZone: asg.getTag('SecurityZone'),\n        SubnetTypeName: currentSubnetType.name,\n        AvailabilityZoneName: network.availabilityZoneName\n      },\n      environmentType,\n      environmentTypeName: environment.EnvironmentType\n    });\n  }\n\n  let scaling = command.parameters.scaling;\n\n  let parameters = {\n    name: command.autoScalingGroupName,\n    minSize: size.min,\n    desiredSize: size.desired,\n    maxSize: size.max,\n    subnets,\n    scaling\n  };\n\n  return resource.put(parameters);\n}\n\nfunction getSubnetTypeBySubnet(subnetTypes, subnet) {\n  let subnetTypeArray = _.keys(subnetTypes).map((key) => {\n    let subnetType = unMapSubnetType(key, subnetTypes[key]);\n    return subnetType;\n  });\n  return _.find(subnetTypeArray, subnetType => subnetType.hasSubnet(subnet));\n}\n\nfunction unMapSubnetType(subnetTypeName, subnetType) {\n  let azs = _.keys(subnetType)\n    .filter(key => key.startsWith('AvailabilityZone'))\n    .map(key => ({\n      name: key,\n      subnet: subnetType[key]\n    }));\n\n  return {\n    name: subnetTypeName,\n    availabilityZones: azs,\n    secure: !!subnetType.Secure,\n    hasSubnet: subnet => _.some(azs, az => az.subnet === subnet)\n  };\n}\n\nmodule.exports = co.wrap(handler);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/commands/asg/UpdateAutoScalingGroup.js\n// module id = 245\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet assert = require('assert');\nlet co = require('co');\nconst asgScheduledActionsResourceFactory = require('../modules/resourceFactories/asgScheduledActionsResourceFactory');\n\nfunction* GetAutoScalingGroupScheduledActions(query) {\n  assert(query.accountName);\n  assert(query.autoScalingGroupName);\n\n  // Create an instance of the resource to work with based on the resource\n  // descriptor and AWS account name.\n  let parameters = { accountName: query.accountName };\n  let resource = yield asgScheduledActionsResourceFactory.create(undefined, parameters);\n\n  // Get AutoScalingGroup's Scheduled Actions by name\n  return resource.get({ name: query.autoScalingGroupName });\n}\n\nmodule.exports = co.wrap(GetAutoScalingGroupScheduledActions);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/queryHandlers/GetAutoScalingGroupScheduledActions.js\n// module id = 246\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet amazonClientFactory = require('../amazon-client/childAccountClient');\nlet AsgScheduledActionsResource = require('./AsgScheduledActionsResource');\nlet logger = require('../logger');\n\nmodule.exports = {\n\n  canCreate: resourceDescriptor => resourceDescriptor.type.toLowerCase() === 'asgs-scheduled-actions',\n\n  create: (resourceDescriptor, parameters) => {\n    logger.debug(`Getting ASG client for account \"${parameters.accountName}\"...`);\n    return amazonClientFactory.createASGClient(parameters.accountName)\n      .then(client => new AsgScheduledActionsResource(client));\n  }\n\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/resourceFactories/asgScheduledActionsResourceFactory.js\n// module id = 247\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet AwsError = require('../errors/AwsError.class');\nlet AutoScalingGroupNotFoundError = require('../errors/AutoScalingGroupNotFoundError.class');\n\nfunction AsgScheduledActionsResource(client) {\n  function describeScheduledActions(name) {\n    return client.describeScheduledActions({ AutoScalingGroupName: name }).promise();\n  }\n\n  this.get = function (parameters) {\n    return describeScheduledActions(parameters.name).then((result) => {\n      if (result.ScheduledUpdateGroupActions) {\n        return {\n          ScheduledActions: result.ScheduledUpdateGroupActions.map(action => (\n            {\n              MinSize: action.MinSize,\n              MaxSize: action.MaxSize,\n              DesiredCapacity: action.DesiredCapacity,\n              Recurrence: action.Recurrence\n            }\n          ))\n        };\n      }\n      throw new AutoScalingGroupNotFoundError(`AutoScalingGroup \"${parameters.name}\" not found.`);\n    }).catch((error) => {\n      throw new AwsError(error.message);\n    });\n  };\n}\n\nmodule.exports = AsgScheduledActionsResource;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/resourceFactories/AsgScheduledActionsResource.js\n// module id = 248\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet assert = require('assert');\nlet co = require('co');\nconst asgLifeCycleHooksResourceFactory = require('../modules/resourceFactories/asgLifeCycleHooksResourceFactory');\n\nfunction* GetAutoScalingGroupLifeCycleHooks(query) {\n  assert(query.accountName);\n  assert(query.autoScalingGroupName);\n\n  // Create an instance of the resource to work with based on the resource\n  // descriptor and AWS account name.\n  let parameters = { accountName: query.accountName };\n  let resource = yield asgLifeCycleHooksResourceFactory.create(undefined, parameters);\n\n  // Get AutoScalingGroup's Scheduled Actions by name\n  return resource.get({ name: query.autoScalingGroupName });\n}\n\nmodule.exports = co.wrap(GetAutoScalingGroupLifeCycleHooks);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/queryHandlers/GetAutoScalingGroupLifeCycleHooks.js\n// module id = 249\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet amazonClientFactory = require('../amazon-client/childAccountClient');\nlet AsgLifeCycleHooksResource = require('./AsgLifeCycleHooksResource');\nlet logger = require('../logger');\n\nmodule.exports = {\n\n  canCreate: resourceDescriptor => resourceDescriptor.type.toLowerCase() === 'asgs-scheduled-actions',\n\n  create: (resourceDescriptor, parameters) => {\n    logger.debug(`Getting ASG client for account \"${parameters.accountName}\"...`);\n    return amazonClientFactory.createASGClient(parameters.accountName)\n      .then(client => new AsgLifeCycleHooksResource(client));\n  }\n\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/resourceFactories/asgLifeCycleHooksResourceFactory.js\n// module id = 250\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet AwsError = require('../errors/AwsError.class');\nlet AutoScalingGroupNotFoundError = require('../errors/AutoScalingGroupNotFoundError.class');\n\nfunction AsgLifeCycleHooksResource(client) {\n  function describeLifeCycleHooks(name) {\n    return client.describeLifecycleHooks({ AutoScalingGroupName: name }).promise();\n  }\n\n  this.get = function (parameters) {\n    return describeLifeCycleHooks(parameters.name).then((result) => {\n      if (result.LifecycleHooks) {\n        return result.LifecycleHooks;\n      }\n      throw new AutoScalingGroupNotFoundError(`AutoScalingGroup \"${parameters.name}\" not found.`);\n    }).catch((error) => {\n      throw new AwsError(error.message);\n    });\n  };\n}\n\nmodule.exports = AsgLifeCycleHooksResource;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/resourceFactories/AsgLifeCycleHooksResource.js\n// module id = 251\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet _ = require('lodash');\nlet Enums = require('../../Enums');\nlet co = require('co');\nlet getASG = require('../../queryHandlers/GetAutoScalingGroup');\nlet Environment = require('../../models/Environment');\n\nfunction* getASGReady({ autoScalingGroupName, environmentName }) {\n  return co(function* () {\n    let accountName = yield Environment.getAccountNameForEnvironment(environmentName);\n    return getASG({ accountName, autoScalingGroupName }).then((data) => {\n      let instances = data.Instances;\n      let instancesInService = _.filter(instances, { LifecycleState: Enums.ASGLifecycleState.IN_SERVICE });\n      let instancesByLifecycleState = _(instances).groupBy('LifecycleState').mapValues(list => list.length).value();\n\n      return {\n        ReadyToDeploy: instancesInService.length === instances.length,\n        InstancesByLifecycleState: instancesByLifecycleState,\n        InstancesTotalCount: instances.length\n      };\n    });\n  });\n}\n\nmodule.exports = co.wrap(getASGReady);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/environment-state/getASGReady.js\n// module id = 252\n// module chunks = 0","'use strict';\n\nlet aws = require('aws-sdk');\n\nfunction passSafetyNet(name) {\n  let root = name.split('/')[0];\n  if (root !== 'EnvironmentManagerConfigurationChange'\n    && root !== 'EnvironmentManagerOperationsChange') {\n    return false;\n  }\n\n  return true;\n}\n\nmodule.exports = (name) => {\n  const sns = new aws.SNS();\n  const valid = /^[a-zA-Z0-9\\-\\_]+$/;\n\n  return new Promise((resolve, reject) => {\n    if (!name) {\n      reject('When creating a topic, a name parameter must be provided.');\n    }\n    if (name.length > 256) {\n      reject('When creating a topic, a name parameter should be a maximum of 256 characters.');\n    }\n    if (!valid.test(name)) {\n      /* eslint-disable max-len*/\n      reject('When creating a topic, a name parameter must be made up of only uppercase and lowercase ASCII letters, numbers, underscores, and hyphens.');\n    }\n    if (!passSafetyNet(name)) {\n      reject(`Current allowed topics list does not contain ${name}`);\n    }\n\n    sns.createTopic({ Name: name }, (err, result) => {\n      if (err) reject(err);\n      resolve(result);\n    });\n  });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/sns/EnvironmentManagerEvents/createTopic.js\n// module id = 253\n// module chunks = 0","/* Copyright (c) Trainline Limited. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nmodule.exports = (ResponseMetadata) => {\n  if (!ResponseMetadata.TopicArn) {\n    throw new Error('ResponseMetadata does not contain a TopicArn value to extract.');\n  }\n\n  return ResponseMetadata.TopicArn;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/sns/EnvironmentManagerEvents/getTargetArn.js\n// module id = 254\n// module chunks = 0","/* Copyright (c) Trainline Limited. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nconst util = require('util');\n\nmodule.exports = (event) => {\n  // eslint-disable-next-line no-console\n  console.log(`Creating event for ${util.inspect(event, { depth: null })}`);\n\n  if (!event) {\n    throw new Error('Expected a configuration object when creating an event.');\n  }\n  if (!event.message) {\n    throw new Error('Missing expected message attribute.');\n  }\n  if (event.attributes) {\n    checkAttributes(event);\n  }\n  return (target) => {\n    return {\n      Message: event.message,\n      MessageAttributes: event.attributes,\n      TargetArn: target\n    };\n  };\n};\n\nfunction checkAttributes(event) {\n  const validAttrs = [\n    'EnvironmentType',\n    'Environment',\n    'OwningCluster',\n    'User',\n    'Result',\n    'Timestamp',\n    'Action',\n    'ID',\n    'EntityURL'\n  ];\n\n  let foundNonValidAttributes = [];\n\n  Object.keys(event.attributes).forEach((k) => {\n    if (!validAttrs.includes(k)) {\n      foundNonValidAttributes.push(k);\n    } else {\n      event.attributes[k] = turnProvidedValueIntoSnsAttribute(event.attributes[k]);\n    }\n  });\n\n  if (!event.attributes.Timestamp) {\n    event.attributes.Timestamp = turnProvidedValueIntoSnsAttribute(Date.now().toString());\n  }\n\n  if (foundNonValidAttributes.length > 0) {\n    throw new Error(`Non valid attributes provided: ${foundNonValidAttributes.join(',')}`);\n  }\n}\n\nfunction turnProvidedValueIntoSnsAttribute(value) {\n  return {\n    DataType: 'String',\n    StringValue: value\n  };\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/sns/EnvironmentManagerEvents/createEvent.js\n// module id = 255\n// module chunks = 0","/* Copyright (c) Trainline Limited. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet aws = require('aws-sdk');\n\nmodule.exports = (event) => {\n  if (!event.TargetArn) {\n    throw new Error('An event to be published must contain a TargetArn property.');\n  }\n\n  if (!event.Message) {\n    throw new Error('An event to be published must contain a Message property.');\n  }\n\n  if (event.MessageAttributes) {\n    Object.keys(event.MessageAttributes).forEach((k) => {\n      if (!event.MessageAttributes[k].DataType) {\n        throw new Error('All MessageAttribute values must contain a DataType property.');\n      }\n    });\n  }\n\n  const sns = new aws.SNS();\n\n  return new Promise((resolve, reject) => {\n    sns.publish(event, (err, result) => {\n      if (err) reject(err);\n      return resolve(result);\n    });\n  });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/sns/EnvironmentManagerEvents/publishEvent.js\n// module id = 256\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet notImplemented = require('../../api-utils/notImplemented');\nlet { getTableName } = require('../../../modules/awsResourceNameProvider');\n\n/* eslint-disable import/no-extraneous-dependencies */\nlet auditLogReader = require('../../../modules/auditLogReader');\nlet base64 = require('../../../modules/base64');\nlet logger = require('../../../modules/logger');\nlet weblink = require('../../../modules/weblink');\n/* eslint-enable import/no-extraneous-dependencies */\n\nlet fp = require('lodash/fp');\nlet Instant = require('js-joda').Instant;\nlet LocalDate = require('js-joda').LocalDate;\nlet ZoneOffset = require('js-joda').ZoneOffset;\nlet url = require('url');\n\nfunction createAuditLogQuery(since, until, exclusiveStartKey, perPage, filter) {\n  let rq = {\n    maxDate: until.toString(),\n    minDate: since.toString()\n  };\n  if (perPage) {\n    rq.limit = perPage;\n  }\n  if (exclusiveStartKey) {\n    rq.exclusiveStartKey = exclusiveStartKey;\n  }\n  if (filter) {\n    rq.filter = filter;\n  }\n  return rq;\n}\n\nfunction createFilter(query) {\n  logger.debug('Audit History: Creating filter.');\n  let exprs = {\n    'Entity.Type': val => (val === 'ConfigLBUpstream' || val === 'ConfigLBSettings'\n      ? ['or',\n        ['=', ['attr', 'Entity', 'Type'], ['val', getTableName(val)]],\n        ['=', ['attr', 'Entity', 'Type'], ['val', getTableName(`Infra${val}`)]]]\n      : ['=', ['attr', 'Entity', 'Type'], ['val', getTableName(val)]]),\n    'ChangeType': val => ['=', ['attr', 'ChangeType'], ['val', val]],\n    'Entity.Key': val => ['=', ['attr', 'Entity', 'Key'], ['val', val]]\n  };\n\n  let filter = fp.flow(\n    fp.pick(fp.keys(exprs)),\n    fp.toPairs,\n    fp.map(x => exprs[x[0]](x[1])),\n    predicates => (predicates.length > 0 ? ['and'].concat(predicates) : undefined));\n\n  return filter(query);\n}\n\n/**\n * GET /audit\n */\nfunction getAuditLogs(request, response, next) {\n  let redirectUrl = url.parse(request.originalUrl, true);\n  redirectUrl.search = null;\n  let query = redirectUrl.query;\n\n  function paramOrDefault(param, fn, defaultValue) {\n    function f(x) {\n      try {\n        return fn(x);\n      } catch (error) {\n        logger.error(error);\n        throw new Error(`Error parsing parameter: ${param}`);\n      }\n    }\n    let t = fp.has(param)(query) ? fp.flow(fp.get(param), f)(query) : defaultValue;\n    return t;\n  }\n\n  function convertDateOrNow(date) {\n    if (date === undefined) {\n      return LocalDate.now(ZoneOffset.UTC);\n    }\n    return LocalDate.ofInstant(Instant.ofEpochMilli(date));\n  }\n\n  logger.debug('Audit History: Extracting parameters from request.');\n  let since = convertDateOrNow(request.swagger.params.since.value);\n  let until = convertDateOrNow(request.swagger.params.until.value);\n\n  let exclusiveStartKey = paramOrDefault('exclusiveStartKey', base64.decode, undefined);\n\n  let filter = createFilter(query);\n  let auditLogQuery = createAuditLogQuery(since, until, exclusiveStartKey, query.per_page, filter);\n  return auditLogReader.getLogs(auditLogQuery)\n    .then((auditLog) => {\n      logger.debug('Audit History: Constructing navigation links');\n      query.since = since.toString();\n      query.until = until.toString();\n      if (auditLog.LastEvaluatedKey) {\n        query.exclusiveStartKey = base64.encode(auditLog.LastEvaluatedKey);\n        response.header('Link', weblink.link({ next: url.format(redirectUrl) }));\n      }\n      logger.debug('Audit History: sending response');\n      return response.status(200).send(auditLog.Items);\n    }).catch(next);\n}\n\n/**\n * GET /audit/{key}\n */\nfunction getAuditLogByKey(req, res) {\n  notImplemented(res, 'Getting a specific audit log by key');\n}\n\nmodule.exports = {\n  getAuditLogs,\n  getAuditLogByKey\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/controllers/audit/auditController.js\n// module id = 257\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nfunction notImplemented(res, reason) {\n  res.status(501);\n  throw new Error(`Sorry, this action is not yet implemented: ${reason}`);\n}\n\nmodule.exports = notImplemented;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/api-utils/notImplemented.js\n// module id = 258\n// module chunks = 0","'use strict';\n\nconst masterAccountClient = require('./amazon-client/masterAccountClient');\nconst dynamodbExpression = require('./awsDynamo/dynamodbExpression');\nconst LocalDate = require('js-joda').LocalDate;\n\nconst awsResourceNameProvider = require('./awsResourceNameProvider');\nconst qname = awsResourceNameProvider.getTableName;\nconst InfraChangeAudit = qname('InfraChangeAudit');\nconst InfraChangeAuditIndexName = 'Date-ISOTimestamp-index';\n\nconst dynamodbPromise = masterAccountClient.createDynamoClient();\n\nfunction createQuery(date, limit, options, exclusiveStartKey) {\n  let expressions = {\n    KeyConditionExpression: ['=', ['attr', 'Date'], ['val', date]]\n  };\n  if (options.filter) {\n    expressions.FilterExpression = options.filter;\n  }\n  let compiledExpressions = dynamodbExpression.compile(expressions);\n  let t = {\n    TableName: InfraChangeAudit,\n    IndexName: InfraChangeAuditIndexName,\n    Limit: limit,\n    ScanIndexForward: false\n  };\n  if (exclusiveStartKey) {\n    t.ExclusiveStartKey = exclusiveStartKey;\n  }\n  let result = Object.assign(t, compiledExpressions);\n  return result;\n}\n\n// TODO: Double-check usage of this function\n// eslint-disable-next-line no-unused-vars\nfunction key(item) {\n  return {\n    AuditID: item.AuditID,\n    Date: item.Date,\n    ISOTimestamp: item.ISOTimestamp\n  };\n}\n\nfunction getLogs(params) {\n  let minPartitionKey = params.minDate;\n  let maxPartitionKey = params.maxDate;\n\n  function nextPartitionKey(prevKey) {\n    return LocalDate.parse(prevKey).minusDays(1).toString();\n  }\n\n  function query(limit, date, exclusiveStartKey) {\n    if (exclusiveStartKey) {\n      if (Object.keys(exclusiveStartKey).length > 1) {\n        return createQuery(exclusiveStartKey.Date, limit, params, exclusiveStartKey);\n      } else {\n        return createQuery(nextPartitionKey(exclusiveStartKey.Date), limit, params);\n      }\n    } else {\n      return createQuery(date, limit, params);\n    }\n  }\n\n  let documentClient = {\n    queryAsync: queryParams => dynamodbPromise.then(client => client.query(queryParams).promise())\n  };\n\n  function inQueryDomain(partitionKey) {\n    return (minPartitionKey <= partitionKey && partitionKey <= maxPartitionKey);\n  }\n\n  function lastEvaluatedKey(prev, response) {\n    if (response.LastEvaluatedKey) {\n      return response.LastEvaluatedKey;\n    } else if (response.Items.length > 0) {\n      let date = response.Items.map(x => x.Date)[response.Items.length - 1];\n      return { Date: date };\n    } else {\n      return prev;\n    }\n  }\n\n  function hasMore(partitionKey) {\n    let hasMoreQuery = (t) => {\n      let remaining = query(1, t);\n      remaining.Select = 'COUNT';\n      return remaining;\n    };\n    function recur(k, response) {\n      if (!inQueryDomain(k)) {\n        return Promise.resolve(false);\n      }\n      if (response.Count > 0) {\n        return Promise.resolve(true);\n      }\n      let nextKey = nextPartitionKey(k);\n      return documentClient.queryAsync(hasMoreQuery(nextKey)).then(recur.bind(null, nextKey));\n    }\n    return documentClient.queryAsync(hasMoreQuery(partitionKey)).then(recur.bind(null, partitionKey));\n  }\n\n  function loop(partitionKey, acc, response) {\n    acc.Items = acc.Items.concat(response.Items);\n    acc.LastEvaluatedKey = lastEvaluatedKey(acc.LastEvaluatedKey, response);\n    let limit = params.limit - acc.Items.length;\n    let nextKey = nextPartitionKey(partitionKey);\n    if (!{}.hasOwnProperty.call(response, 'LastEvaluatedKey') && (!inQueryDomain(nextKey) || !hasMore(nextKey))) {\n      delete acc.LastEvaluatedKey;\n      return Promise.resolve(acc);\n    }\n    if (limit <= 0) {\n      return Promise.resolve(acc);\n    }\n    return documentClient.queryAsync(query(limit, nextKey, response.LastEvaluatedKey)).then(loop.bind(null, nextKey, acc));\n  }\n\n  let firstPartitionKey = params.exclusiveStartKey ? params.exclusiveStartKey.Date : params.maxDate;\n  return documentClient.queryAsync(query(params.limit, params.maxDate, params.exclusiveStartKey))\n    .then(loop.bind(null, firstPartitionKey, { Items: [] }));\n}\n\nmodule.exports = {\n  getLogs\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/auditLogReader.js\n// module id = 259\n// module chunks = 0","module.exports = require(\"buffer\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"buffer\"\n// module id = 260\n// module chunks = 0","'use strict';\n\nconst _ = require('lodash');\nconst url = require('url');\n\nfunction link(links) {\n  return _.map(links, (href, rel) => [`<${url.format(href)}>`, `rel=\"${rel}\"`].join('; '))\n    .join(', ');\n}\n\nmodule.exports = { link };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/weblink.js\n// module id = 261\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet accounts = require('../../../../modules/data-access/accounts');\nlet { getMetadataForDynamoAudit } = require('../../../api-utils/requestMetadata');\nlet param = require('../../../api-utils/requestParam');\nlet { validate } = require('../../../../commands/validators/awsAccountValidator');\nlet { versionOf } = require('../../../../modules/data-access/dynamoVersion');\nlet { removeAuditMetadata } = require('../../../../modules/data-access/dynamoAudit');\nlet sns = require('../../../../modules/sns/EnvironmentManagerEvents');\n\nfunction convertToApiModel(persistedModel) {\n  let apiModel = removeAuditMetadata(persistedModel);\n  let Version = versionOf(persistedModel);\n  return Object.assign(apiModel, { Version });\n}\n\n/**\n * GET /config/accounts\n */\nfunction getAccountsConfig(req, res, next) {\n  return accounts.scan()\n    .then(data => data.map(convertToApiModel))\n    .then(data => res.json(data))\n    .catch(next);\n}\n\n/**\n * POST /config/accounts\n */\nfunction postAccountsConfig(req, res, next) {\n  const account = req.swagger.params.account.value;\n  let metadata = getMetadataForDynamoAudit(req);\n  let record = account;\n  return validate(account)\n    .then(() => accounts.create({ record, metadata }))\n    .then(() => res.status(201).end())\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: '/config/accounts',\n          Method: 'POST'\n        }\n      }),\n      topic: sns.TOPICS.CONFIGURATION_CHANGE,\n      attributes: {\n        Action: sns.ACTIONS.POST,\n        ID: `${account.AccountNumber}`\n      }\n    }))\n    .catch(next);\n}\n\n/**\n * PUT /config/accounts/{accountNumber}\n */\nfunction putAccountConfigByName(req, res, next) {\n  const AccountNumber = req.swagger.params.accountNumber.value;\n  const account = req.swagger.params.account.value;\n  const expectedVersion = param('expected-version', req);\n\n  let metadata = getMetadataForDynamoAudit(req);\n  let record = Object.assign(account, { AccountNumber });\n\n  return validate(account)\n    .then(() => accounts.replace({ record, metadata }, expectedVersion))\n    .then(() => res.status(200).end())\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: `/config/accounts/${AccountNumber}`,\n          Method: 'PUT'\n        }\n      }),\n      topic: sns.TOPICS.CONFIGURATION_CHANGE,\n      attributes: {\n        Action: sns.ACTIONS.PUT,\n        ID: `${AccountNumber}`\n      }\n    }))\n    .catch(next);\n}\n\n/**\n * DELETE /config/accounts/{accountNumber}\n */\nfunction deleteAccountConfigByName(req, res, next) {\n  const AccountNumber = req.swagger.params.accountNumber.value;\n  const expectedVersion = param('expected-version', req);\n  let metadata = getMetadataForDynamoAudit(req);\n\n  return accounts.delete({ key: { AccountNumber }, metadata }, expectedVersion)\n    .then(() => res.status(200).end())\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: `/config/accounts/${AccountNumber}`,\n          Method: 'DELETE'\n        }\n      }),\n      topic: sns.TOPICS.CONFIGURATION_CHANGE,\n      attributes: {\n        Action: sns.ACTIONS.DELETE,\n        ID: `${AccountNumber}`\n      }\n    }))\n    .catch(next);\n}\n\nmodule.exports = {\n  getAccountsConfig,\n  postAccountsConfig,\n  putAccountConfigByName,\n  deleteAccountConfigByName\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/controllers/config/accounts/accountsController.js\n// module id = 262\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet childAWSclient = require('../../modules/amazon-client/childAccountClient');\nlet logger = require('../../modules/logger');\nlet co = require('co');\n\nfunction validate(account) {\n  return co(function* () {\n    let flags = ['IncludeAMIs'];\n    let required = flags.concat(['AccountName', 'AccountNumber', 'RoleArn']);\n\n    Object.keys(account).forEach((k) => {\n      if (required.indexOf(k) < 0) throw new Error(`'${k}' is not a valid attribute.`);\n    });\n\n    required.forEach((p) => {\n      if (!{}.hasOwnProperty.call(account, p)) throw new Error(`Missing required attribute: ${p}`);\n    });\n\n    flags.forEach((f) => {\n      if (typeof account[f] !== 'boolean') throw new Error(`Attribute ${f} must be boolean`);\n    });\n\n    validateAccountNumber(account.AccountNumber);\n\n    try {\n      yield childAWSclient.assumeRole(account.RoleArn);\n    } catch (error) {\n      logger.error(`Rejected attempt to add account ${account.AccountName} with role ARN ${account.RoleArn}`);\n      throw new Error(`Cannot assume role for ARN: ${account.RoleArn}`);\n    }\n\n    return true;\n  });\n}\n\nfunction validateAccountNumber(accountNumber) {\n  if (!Number.isInteger(accountNumber) || accountNumber > 999999999999) {\n    throw new Error('AccountNumber must be a (max) 12 digit integer');\n  }\n}\n\nmodule.exports = { validate, validateAccountNumber };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/commands/validators/awsAccountValidator.js\n// module id = 263\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nconst KEY_NAME = 'ClusterName';\n\nlet clusters = require('../../../../modules/data-access/clusters');\nlet getMetadataForDynamoAudit = require('../../../api-utils/requestMetadata').getMetadataForDynamoAudit;\nlet param = require('../../../api-utils/requestParam');\nlet versionOf = require('../../../../modules/data-access/dynamoVersion').versionOf;\nlet removeAuditMetadata = require('../../../../modules/data-access/dynamoAudit').removeAuditMetadata;\nconst sns = require('../../../../modules/sns/EnvironmentManagerEvents');\nlet { hasValue, when } = require('../../../../modules/functional');\nlet { ifNotFound, notFoundMessage } = require('../../../api-utils/ifNotFound');\n\nfunction keyOf(value) {\n  let t = {};\n  t[KEY_NAME] = value;\n  return t;\n}\n\nfunction convertToApiModel(persistedModel) {\n  let apiModel = removeAuditMetadata(persistedModel);\n  let Version = versionOf(persistedModel);\n  return Object.assign(apiModel, { Version });\n}\n\n/**\n * GET /config/clusters\n */\nfunction getClustersConfig(req, res, next) {\n  return clusters.scan()\n    .then(data => data.map(convertToApiModel))\n    .then(data => res.json(data)).catch(next);\n}\n\n/**\n * GET /config/clusters/{name}\n */\nfunction getClusterConfigByName(req, res, next) {\n  const key = param('name', req);\n  return clusters.get(keyOf(key))\n    .then(when(hasValue, convertToApiModel))\n    .then(ifNotFound(notFoundMessage('cluster')))\n    .then(send => send(res))\n    .catch(next);\n}\n\n/**\n * POST /config/clusters\n */\nfunction postClustersConfig(req, res, next) {\n  const body = param('body', req);\n  let metadata = getMetadataForDynamoAudit(req);\n  let record = Object.assign({}, body);\n  delete record.Version;\n  return clusters.create({ record, metadata })\n    .then(() => res.status(201).end())\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: '/config/clusters',\n          Method: 'POST'\n        }\n      }),\n      topic: sns.TOPICS.CONFIGURATION_CHANGE,\n      attributes: {\n        Action: sns.ACTIONS.POST,\n        ID: ''\n      }\n    }))\n    .catch(next);\n}\n\n/**\n * PUT /config/clusters/{name}\n */\nfunction putClusterConfigByName(req, res, next) {\n  const key = param('name', req);\n  const expectedVersion = param('expected-version', req);\n  const body = param('body', req);\n\n  let metadata = getMetadataForDynamoAudit(req);\n  let record = Object.assign(keyOf(key), { Value: body });\n  delete record.Version;\n\n  return clusters.replace({ record, metadata }, expectedVersion)\n    .then(() => res.status(200).end())\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: `/config/clusters/${key}`,\n          Method: 'PUT'\n        }\n      }),\n      topic: sns.TOPICS.CONFIGURATION_CHANGE,\n      attributes: {\n        Action: sns.ACTIONS.PUT,\n        ID: key\n      }\n    }))\n    .catch(next);\n}\n\n/**\n * DELETE /config/clusters/{name}\n */\nfunction deleteClusterConfigByName(req, res, next) {\n  const clusterName = param('name', req);\n  const expectedVersion = param('expected-version', req);\n\n  let key = keyOf(clusterName);\n  let metadata = getMetadataForDynamoAudit(req);\n\n  return clusters.delete({ key, metadata }, expectedVersion)\n    .then(() => res.status(200).end())\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: `/config/clusters/${key}`,\n          Method: 'DELETE'\n        }\n      }),\n      topic: sns.TOPICS.CONFIGURATION_CHANGE,\n      attributes: {\n        Action: sns.ACTIONS.DELETE,\n        ID: clusterName\n      }\n    }))\n    .catch(next);\n}\n\nmodule.exports = {\n  getClustersConfig,\n  getClusterConfigByName,\n  postClustersConfig,\n  putClusterConfigByName,\n  deleteClusterConfigByName\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/controllers/config/clusters/clusterController.js\n// module id = 264\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet deploymentMaps = require('../../../../modules/data-access/deploymentMaps');\nlet getMetadataForDynamoAudit = require('../../../api-utils/requestMetadata').getMetadataForDynamoAudit;\nlet param = require('../../../api-utils/requestParam');\nlet versionOf = require('../../../../modules/data-access/dynamoVersion').versionOf;\nlet removeAuditMetadata = require('../../../../modules/data-access/dynamoAudit').removeAuditMetadata;\nconst sns = require('../../../../modules/sns/EnvironmentManagerEvents');\nlet { hasValue, when } = require('../../../../modules/functional');\nlet { ifNotFound, notFoundMessage } = require('../../../api-utils/ifNotFound');\n\nconst KEY_NAME = 'DeploymentMapName';\nfunction keyOf(value) {\n  let t = {};\n  t[KEY_NAME] = value;\n  return t;\n}\n\nfunction convertToApiModel(persistedModel) {\n  let apiModel = removeAuditMetadata(persistedModel);\n  let Version = versionOf(persistedModel);\n  return Object.assign(apiModel, { Version });\n}\n\n/**\n * GET /config/deployment-maps\n */\nfunction getDeploymentMapsConfig(req, res, next) {\n  return deploymentMaps.scan()\n    .then(data => data.map(convertToApiModel))\n    .then(data => res.json(data))\n    .catch(next);\n}\n\n/**\n * GET /config/deployment-maps/{name}\n */\nfunction getDeploymentMapConfigByName(req, res, next) {\n  let key = param('name', req);\n  return deploymentMaps.get(keyOf(key))\n    .then(when(hasValue, convertToApiModel))\n    .then(ifNotFound(notFoundMessage('deployment map')))\n    .then(send => send(res))\n    .catch(next);\n}\n\n/**\n * POST /config/deployment-maps\n */\nfunction postDeploymentMapsConfig(req, res, next) {\n  const body = param('body', req);\n  let metadata = getMetadataForDynamoAudit(req);\n  let record = body;\n  delete record.Version;\n  return deploymentMaps.create({ record, metadata })\n    .then(() => res.status(201).end())\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: '/config/deployment-maps',\n          Method: 'POST'\n        }\n      }),\n      topic: sns.TOPICS.CONFIGURATION_CHANGE,\n      attributes: {\n        Action: sns.ACTIONS.POST,\n        ID: ''\n      }\n    }))\n    .catch(next);\n}\n\n/**\n * PUT /config/deployment-maps/{name}\n */\nfunction putDeploymentMapConfigByName(req, res, next) {\n  const key = param('name', req);\n  const expectedVersion = param('expected-version', req);\n  const body = param('body', req);\n\n  let metadata = getMetadataForDynamoAudit(req);\n  let record = Object.assign(keyOf(key), { Value: body });\n  delete record.Version;\n\n  return deploymentMaps.replace({ record, metadata }, expectedVersion)\n    .then(() => res.status(200).end())\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: `/config/deployment-maps/${key}`,\n          Method: 'PUT'\n        }\n      }),\n      topic: sns.TOPICS.CONFIGURATION_CHANGE,\n      attributes: {\n        Action: sns.ACTIONS.PUT,\n        ID: key\n      }\n    }))\n    .catch(next);\n}\n\n/**\n * DELETE /config/deployment-maps/{name}\n */\nfunction deleteDeploymentMapConfigByName(req, res, next) {\n  const key = keyOf(param('name', req));\n  let metadata = getMetadataForDynamoAudit(req);\n\n  return deploymentMaps.delete({ key, metadata })\n    .then(() => res.status(200).end())\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: `/config/deployment-maps/${key}`,\n          Method: 'DELETE'\n        }\n      }),\n      topic: sns.TOPICS.CONFIGURATION_CHANGE,\n      attributes: {\n        Action: sns.ACTIONS.DELETE,\n        ID: key\n      }\n    }))\n    .catch(next);\n}\n\nmodule.exports = {\n  getDeploymentMapsConfig,\n  getDeploymentMapConfigByName,\n  postDeploymentMapsConfig,\n  putDeploymentMapConfigByName,\n  deleteDeploymentMapConfigByName\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/controllers/config/deployment-maps/deploymentMapController.js\n// module id = 265\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nconst KEY_NAME = 'EnvironmentType';\n\nlet configEnvironmentTypes = require('../../../../modules/data-access/configEnvironmentTypes');\nlet getMetadataForDynamoAudit = require('../../../api-utils/requestMetadata').getMetadataForDynamoAudit;\nlet param = require('../../../api-utils/requestParam');\nlet { versionOf } = require('../../../../modules/data-access/dynamoVersion');\nconst sns = require('../../../../modules/sns/EnvironmentManagerEvents');\nlet { hasValue, when } = require('../../../../modules/functional');\nlet { ifNotFound, notFoundMessage } = require('../../../api-utils/ifNotFound');\n\nfunction keyOf(value) {\n  let t = {};\n  t[KEY_NAME] = value;\n  return t;\n}\n\nfunction convertToApiModel(persistedModel) {\n  let Version = versionOf(persistedModel);\n  return Object.assign(persistedModel, { Version });\n}\n\n/**\n * GET /config/environment-types\n */\nfunction getEnvironmentTypesConfig(req, res, next) {\n  return configEnvironmentTypes.scan()\n    .then(data => data.map(convertToApiModel))\n    .then(data => res.json(data))\n    .catch(next);\n}\n\n/**\n * GET /config/environment-types/{name}\n */\nfunction getEnvironmentTypeConfigByName(req, res, next) {\n  const key = param('name', req);\n  return configEnvironmentTypes.get(keyOf(key))\n    .then(when(hasValue, convertToApiModel))\n    .then(ifNotFound(notFoundMessage('environment type')))\n    .then(send => send(res))\n    .catch(next);\n}\n\n/**\n * POST /config/environment-types\n */\nfunction postEnvironmentTypesConfig(req, res, next) {\n  const body = param('body', req);\n  let metadata = getMetadataForDynamoAudit(req);\n  let record = Object.assign({}, body);\n  delete record.Version;\n  return configEnvironmentTypes.create({ record, metadata })\n    .then(() => res.status(201).end())\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: '/config/environment-types',\n          Method: 'POST'\n        }\n      }),\n      topic: sns.TOPICS.CONFIGURATION_CHANGE,\n      attributes: {\n        Action: sns.ACTIONS.POST,\n        ID: ''\n      }\n    }))\n    .catch(next);\n}\n\n/**\n * PUT /config/environment-types/{name}\n */\nfunction putEnvironmentTypeConfigByName(req, res, next) {\n  const key = param('name', req);\n  const expectedVersion = param('expected-version', req);\n  const body = param('body', req);\n\n  let metadata = getMetadataForDynamoAudit(req);\n  let record = Object.assign(keyOf(key), { Value: body });\n  delete record.Version;\n\n  return configEnvironmentTypes.replace({ record, metadata }, expectedVersion)\n    .then(() => res.status(200).end())\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: `/config/environment-types/${key}`,\n          Method: 'PUT'\n        }\n      }),\n      topic: sns.TOPICS.CONFIGURATION_CHANGE,\n      attributes: {\n        Action: sns.ACTIONS.PUT,\n        ID: key\n      }\n    }))\n    .catch(next);\n}\n\n/**\n * DELETE /config/environment-types/{name}\n */\nfunction deleteEnvironmentTypeConfigByName(req, res, next) {\n  const clusterName = param('name', req);\n\n  let key = keyOf(clusterName);\n  let metadata = getMetadataForDynamoAudit(req);\n\n  return configEnvironmentTypes.delete({ key, metadata })\n    .then(() => res.status(200).end())\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: `/config/environment-types/${clusterName}`,\n          Method: 'DELETE'\n        }\n      }),\n      topic: sns.TOPICS.CONFIGURATION_CHANGE,\n      attributes: {\n        Action: sns.ACTIONS.DELETE,\n        ID: clusterName\n      }\n    }))\n    .catch(next);\n}\n\nmodule.exports = {\n  getEnvironmentTypesConfig,\n  getEnvironmentTypeConfigByName,\n  postEnvironmentTypesConfig,\n  putEnvironmentTypeConfigByName,\n  deleteEnvironmentTypeConfigByName\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/controllers/config/environment-types/environmentTypeController.js\n// module id = 266\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet Promise = require('bluebird');\n\nlet getMetadataForDynamoAudit = require('../../../api-utils/requestMetadata').getMetadataForDynamoAudit;\nlet removeAuditMetadata = require('../../../../modules/data-access/dynamoAudit').removeAuditMetadata;\nlet versionOf = require('../../../../modules/data-access/dynamoVersion').versionOf;\nlet param = require('../../../api-utils/requestParam');\n\nlet configEnvironments = require('../../../../modules/data-access/configEnvironments');\nlet opsEnvironment = require('../../../../modules/data-access/opsEnvironment');\nlet loadBalancerUpstreams = require('../../../../modules/data-access/loadBalancerUpstreams');\nlet loadBalancerSettings = require('../../../../modules/data-access/loadBalancerSettings');\n\nlet EnvironmentType = require('../../../../models/EnvironmentType');\n\nlet consul = require('../../../../modules/service-targets/consul');\nconst sns = require('../../../../modules/sns/EnvironmentManagerEvents');\n\nlet { hasValue, when } = require('../../../../modules/functional');\nlet { ifNotFound, notFoundMessage } = require('../../../api-utils/ifNotFound');\n\nfunction attachMetadata(input) {\n  input.Version = versionOf(input);\n  return EnvironmentType.getByName(input.Value.EnvironmentType)\n    .then((environmentType) => {\n      input.AWSAccountNumber = environmentType.AWSAccountNumber;\n      return input;\n    });\n}\n\n/**\n * GET /config/environments\n */\nfunction getEnvironmentsConfig(req, res, next) {\n  const environmentType = param('environmentType', req);\n  const cluster = param('cluster', req);\n\n  let getResults = () => {\n    let predicates = [\n      ...(cluster ? [['=', ['at', 'Value', 'OwningCluster'], ['val', cluster]]] : []),\n      ...(environmentType ? [['=', ['at', 'Value', 'EnvironmentType'], ['val', environmentType]]] : [])\n    ];\n    if (predicates.length === 0) {\n      return configEnvironments.scan();\n    } else {\n      let filter = predicates.length === 1 ? predicates[0] : ['and', ...predicates];\n      return configEnvironments.scan({ FilterExpression: filter });\n    }\n  };\n\n  return Promise.map(getResults(), attachMetadata)\n    .then(data => res.json(data))\n    .catch(next);\n}\n\n/**\n * GET /config/environments/{name}\n */\nfunction getEnvironmentConfigByName(req, res, next) {\n  let key = {\n    EnvironmentName: param('name', req)\n  };\n  return configEnvironments.get(key)\n    .then(when(hasValue, attachMetadata))\n    .then(when(hasValue, removeAuditMetadata))\n    .then(ifNotFound(notFoundMessage('environment')))\n    .then(send => send(res))\n    .catch(next);\n}\n\n/**\n * POST /config/environments\n */\nfunction postEnvironmentsConfig(req, res, next) {\n  let configEnv = param('body', req);\n  let metadata = getMetadataForDynamoAudit(req);\n  let opsEnv = {\n    EnvironmentName: configEnv.EnvironmentName,\n    Value: {}\n  };\n  return Promise.all([\n    configEnvironments.create({ record: configEnv, metadata }),\n    opsEnvironment.create({ record: opsEnv, metadata })\n  ])\n    .then(() => res.status(201).end())\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: '/config/environments',\n          Method: 'POST'\n        }\n      }),\n      topic: sns.TOPICS.CONFIGURATION_CHANGE,\n      attributes: {\n        Action: sns.ACTIONS.POST,\n        ID: configEnv.EnvironmentName || 'None'\n      }\n    }))\n    .catch(next);\n}\n\n/**\n * PUT /config/environments/{name}\n */\nfunction putEnvironmentConfigByName(req, res, next) {\n  let environmentName = param('name', req);\n  let key = {\n    EnvironmentName: environmentName\n  };\n  let expectedVersion = param('expected-version', req);\n  let body = param('body', req);\n  let metadata = getMetadataForDynamoAudit(req);\n  let record = Object.assign(key, { Value: body });\n\n  return configEnvironments.replace({ record, metadata }, expectedVersion)\n    .then(() => res.status(200).end())\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: `/config/environments/${environmentName}`,\n          Method: 'PUT'\n        }\n      }),\n      topic: sns.TOPICS.CONFIGURATION_CHANGE,\n      attributes: {\n        Action: sns.ACTIONS.PUT,\n        ID: environmentName\n      }\n    }))\n    .catch(next);\n}\n\n/**\n * DELETE /config/environments/{name}\n */\nfunction deleteEnvironmentConfigByName(req, res, next) {\n  const environmentName = param('name', req);\n  let key = {\n    EnvironmentName: environmentName\n  };\n  let metadata = getMetadataForDynamoAudit(req);\n\n  return Promise.all([\n    deleteLBSettingsForEnvironment(environmentName, metadata),\n    deleteLBUpstreamsForEnvironment(environmentName, metadata),\n    deleteConsulKeyValuePairs(environmentName)\n  ])\n    .then(() => opsEnvironment.delete({ key, metadata }))\n    .then(() => configEnvironments.delete({ key, metadata }))\n    .then(() => res.status(200).end())\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: `/config/environments/${environmentName}`,\n          Method: 'DELETE'\n        }\n      }),\n      topic: sns.TOPICS.CONFIGURATION_CHANGE,\n      attributes: {\n        Action: sns.ACTIONS.DELETE,\n        ID: environmentName\n      }\n    }))\n    .catch(next);\n}\n\nfunction deleteConsulKeyValuePairs(environmentName) {\n  return consul.removeTargetState(environmentName, { key: `environments/${environmentName}`, recurse: true });\n}\n\nfunction deleteLBSettingsForEnvironment(environmentName, metadata) {\n  let params = {\n    KeyConditionExpression: ['=', ['at', 'EnvironmentName'], ['val', environmentName]],\n    ProjectionExpression: ['list', ', ', ['at', 'EnvironmentName'], ['at', 'VHostName'], ['at', 'Audit', 'Version']]\n  };\n  return loadBalancerSettings.query(params)\n    .then(items => Promise.map(items, ({ EnvironmentName, VHostName, Audit: { Version: expectedVersion } }) =>\n      loadBalancerSettings.delete({ key: { EnvironmentName, VHostName }, metadata }, expectedVersion)));\n}\n\nfunction deleteLBUpstreamsForEnvironment(environmentName, metadata) {\n  return loadBalancerUpstreams.inEnvironment(environmentName)\n    .then(({ Items }) => Promise.map(Items, ({ Key, Audit: { Version: expectedVersion } }) =>\n      loadBalancerUpstreams.delete({ key: { Key }, metadata }, expectedVersion)));\n}\n\nmodule.exports = {\n  getEnvironmentsConfig,\n  getEnvironmentConfigByName,\n  postEnvironmentsConfig,\n  putEnvironmentConfigByName,\n  deleteEnvironmentConfigByName\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/controllers/config/environments/environmentsConfigController.js\n// module id = 267\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet { getTableName: physicalTableName } = require('../../../../modules/awsResourceNameProvider');\nlet dynamoTable = require('../../../../modules/data-access/dynamoTable');\nlet singleAccountDynamoTable = require('../../../../modules/data-access/singleAccountDynamoTable');\nlet logicalTableName = require('../../../api-utils/logicalTableName');\n\n/**\n * GET /config/export/{resource}\n */\nfunction getResourceExport(req, res, next) {\n  const resourceParam = req.swagger.params.resource.value;\n  return Promise.resolve()\n    .then(() => singleAccountDynamoTable(physicalTableName(logicalTableName(resourceParam)), dynamoTable))\n    .then(table => table.scan())\n    .then(data => res.json(data))\n    .catch(next);\n}\n\nmodule.exports = {\n  getResourceExport\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/controllers/config/export/exportController.js\n// module id = 268\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet logicalTableName = require('../../../api-utils/logicalTableName');\nlet { getTableName } = require('../../../../modules/awsResourceNameProvider');\nconst sns = require('../../../../modules/sns/EnvironmentManagerEvents');\nlet dynamoImport = require('../../../../modules/data-access/dynamoImport');\n\n/**\n * PUT /config/import/{resource}\n */\nfunction putResourceImport(req, res, next) {\n  const resource = req.swagger.params.resource.value;\n  const value = req.swagger.params.data.value;\n  const mode = req.swagger.params.mode.value;\n\n  let params = {\n    items: value,\n    table: getTableName(logicalTableName(resource)),\n    remove: mode === 'replace'\n  };\n\n  return dynamoImport(params)\n    .then(data => res.json(data))\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: `/config/import/${resource}`,\n          Method: 'PUT'\n        }\n      }),\n      topic: sns.TOPICS.CONFIGURATION_CHANGE,\n      attributes: {\n        Action: sns.ACTIONS.PUT,\n        ID: req.swagger.params.resource.value\n      }\n    }))\n    .catch(next);\n}\n\nmodule.exports = {\n  putResourceImport\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/controllers/config/import/importController.js\n// module id = 269\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet fp = require('lodash/fp');\nlet Promise = require('bluebird');\nlet pages = require('../amazon-client/pages');\nlet { createDynamoClient: DocumentClient, createLowLevelDynamoClient: DynamoDB } = require('../amazon-client/masterAccountClient');\nlet { extractKey, keyAttributeNames } = require('./dynamoTableDescription');\n\nfunction byKeyEqualityComparer(tableDescription) {\n  let attrs = keyAttributeNames(tableDescription);\n  return (x, y) => attrs.every(a => x[a] === y[a]);\n}\n\nfunction setDifference(equalsFn, xs, ys) {\n  return xs.filter(x => !ys.some(y => equalsFn(x, y)));\n}\n\nfunction importItems({ items: importedItems, table: TableName, remove = false }) {\n  return Promise.join(\n    DocumentClient(),\n    DynamoDB().then(dynamo => dynamo.describeTable({ TableName }).promise()),\n    (table, description) => {\n      function put(item) {\n        let key = extractKey(description, item);\n        return table.put({ TableName, Item: item }).promise()\n          .then(() => ({ operation: 'put', key, status: 'success' }))\n          .catch(() => ({ operation: 'put', key, status: 'failure' }));\n      }\n\n      function $delete(item) {\n        let key = extractKey(description, item);\n        return table.delete({ TableName, Key: key }).promise()\n          .then(() => ({ operation: 'delete', key, status: 'success' }))\n          .catch(() => ({ operation: 'delete', key, status: 'failure' }));\n      }\n\n      function getExistingItemsNotImported() {\n        let keyAttrs = keyAttributeNames(description);\n        return pages.flatten(rsp => rsp.Items, table.scan({\n          TableName,\n          ProjectionExpression: keyAttrs.map(a => `#${a}`).join(', '),\n          ExpressionAttributeNames: fp.fromPairs(keyAttrs.map(a => [`#${a}`, a]))\n        }))\n          .then(existingItems => setDifference(byKeyEqualityComparer(description), existingItems, importedItems));\n      }\n\n      let operations = [\n        Promise.map(importedItems, put, { concurrency: 10 }),\n        (remove ? Promise.map(getExistingItemsNotImported(), $delete, { concurrency: 10 }) : Promise.resolve([]))\n      ];\n\n      return Promise.all(operations).then(fp.flatten);\n    });\n}\n\n\nmodule.exports = importItems;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/data-access/dynamoImport.js\n// module id = 270\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet Promise = require('bluebird');\nlet { flatten, flow } = require('lodash/fp');\nlet { convertToNewModel, convertToOldModel } = require('../../../../modules/data-access/lbSettingsAdapter');\nlet loadBalancerSettings = require('../../../../modules/data-access/loadBalancerSettings');\nlet { getMetadataForDynamoAudit } = require('../../../api-utils/requestMetadata');\nlet param = require('../../../api-utils/requestParam');\nlet { versionOf } = require('../../../../modules/data-access/dynamoVersion');\nlet { removeAuditMetadata } = require('../../../../modules/data-access/dynamoAudit');\nlet { hasValue, when } = require('../../../../modules/functional');\nlet { ifNotFound, notFoundMessage } = require('../../../api-utils/ifNotFound');\n\nconst sns = require('../../../../modules/sns/EnvironmentManagerEvents');\n\nfunction convertToApiModel(persistedModel) {\n  let apiModel = removeAuditMetadata(persistedModel);\n  let Version = versionOf(persistedModel);\n  return Object.assign(apiModel, { Version });\n}\n\nlet notify = sns.publish.bind(sns);\n\n/**\n * GET /config/lb-settings\n */\nfunction getLBSettingsConfig(req, res, next) {\n  const environmentName = param('environment', req);\n  const frontend = param('frontend', req);\n  const queryAttribute = param('qa', req);\n  const queryValues = param('qv', req);\n\n  function filterExpression(expressions) {\n    let { length } = expressions;\n    if (length === 0) {\n      return {};\n    } else if (length === 1) {\n      let [FilterExpression] = expressions;\n      return { FilterExpression };\n    } else {\n      let FilterExpression = ['and', ...expressions];\n      return { FilterExpression };\n    }\n  }\n\n  function keyConditionExpression(attribute, value) {\n    switch (attribute) {\n      case 'environment':\n        return {\n          KeyConditionExpression: ['=', ['at', 'EnvironmentName'], ['val', value]]\n        };\n      case 'load-balancer-group':\n        return {\n          IndexName: 'LoadBalancerGroup-index',\n          KeyConditionExpression: ['=', ['at', 'LoadBalancerGroup'], ['val', value]]\n        };\n      default:\n        return {};\n    }\n  }\n\n  function get(attribute, value) {\n    let filterExpressions = [\n      (frontend !== undefined)\n        ? ['=', ['at', 'Value', 'FrontEnd'], ['val', frontend !== false]]\n        : undefined\n    ];\n\n    let expressions = Object.assign(\n      keyConditionExpression(attribute, value),\n      filterExpression(filterExpressions.filter(x => x !== undefined))\n    );\n\n    return expressions.KeyConditionExpression\n      ? loadBalancerSettings.query(expressions)\n      : loadBalancerSettings.scan(expressions);\n  }\n\n  return (() => {\n    if (environmentName) {\n      return get('environment', environmentName);\n    } else if (queryAttribute && queryValues) {\n      return Promise.map(queryValues, value => get(queryAttribute, value)).then(flatten);\n    } else {\n      return get();\n    }\n  })()\n    .then(data => res.json(data))\n    .catch(next);\n}\n\n/**\n * GET /config/lb-settings/{environment}/{vHostName}\n */\nfunction getLBSettingConfigByName(req, res, next) {\n  const key = {\n    EnvironmentName: param('environment', req),\n    VHostName: param('vHostName', req)\n  };\n  return loadBalancerSettings.get(key)\n    .then(when(hasValue, flow(convertToOldModel, convertToApiModel)))\n    .then(ifNotFound(notFoundMessage('lb-setting')))\n    .then(send => send(res))\n    .catch(next);\n}\n\n/**\n * POST /config/lb-settings\n */\nfunction postLBSettingsConfig(req, res, next) {\n  return Promise.resolve()\n    .then(() => {\n      const body = param('body', req);\n      let metadata = getMetadataForDynamoAudit(req);\n      let key = {\n        EnvironmentName: body.EnvironmentName,\n        VHostName: body.VHostName\n      };\n      return convertToNewModel(Object.assign(key, body))\n        .then((record) => {\n          delete record.Version;\n          return { record, metadata };\n        })\n        .then(loadBalancerSettings.create)\n        .then(() => res.status(201).end())\n        .then(notify({\n          message: JSON.stringify({\n            Endpoint: {\n              Url: '/config/lb-settings',\n              Method: 'POST'\n            }\n          }),\n          topic: sns.TOPICS.CONFIGURATION_CHANGE,\n          attributes: {\n            Action: sns.ACTIONS.POST,\n            ID: body.VHostName\n          }\n        }));\n    })\n    .catch(next);\n}\n\n/**\n * PUT /config/lb-settings/{environment}/{vHostName}\n */\nfunction putLBSettingConfigByName(req, res, next) {\n  const key = {\n    EnvironmentName: param('environment', req),\n    VHostName: param('vHostName', req)\n  };\n  const Value = param('body', req);\n  const expectedVersion = param('expected-version', req);\n  let metadata = getMetadataForDynamoAudit(req);\n\n  return convertToNewModel(Object.assign(key, { Value }))\n    .then(record => loadBalancerSettings.put({ record, metadata }, expectedVersion))\n    .then(() => res.status(200).end())\n    .then(notify({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: `/config/lb-settings/${key.EnvironmentName}/${key.VHostName}`,\n          Method: 'PUT'\n        }\n      }),\n      topic: sns.TOPICS.CONFIGURATION_CHANGE,\n      attributes: {\n        Action: sns.ACTIONS.POST,\n        ID: param('vHostName', req)\n      }\n    }))\n    .catch(next);\n}\n\n/**\n * DELETE /config/lb-settings/{environment}/{vHostName}\n */\nfunction deleteLBSettingConfigByName(req, res, next) {\n  const key = {\n    EnvironmentName: param('environment', req),\n    VHostName: param('vHostName', req)\n  };\n  const expectedVersion = param('expected-version', req);\n  let metadata = getMetadataForDynamoAudit(req);\n\n  return loadBalancerSettings.delete({ key, metadata }, expectedVersion)\n    .then(() => res.status(200).end())\n    .then(notify({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: `/config/lb-settings/${key.EnvironmentName}/${key.VHostName}`,\n          Method: 'DELETE'\n        }\n      }),\n      topic: sns.TOPICS.CONFIGURATION_CHANGE,\n      attributes: {\n        Action: sns.ACTIONS.DELETE,\n        ID: param('vHostName', req)\n      }\n    }))\n    .catch(next);\n}\n\nmodule.exports = {\n  getLBSettingsConfig,\n  getLBSettingConfigByName,\n  postLBSettingsConfig,\n  putLBSettingConfigByName,\n  deleteLBSettingConfigByName\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/controllers/config/lb-settings/lbSettingsController.js\n// module id = 271\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet { assign, omit } = require('lodash/fp');\nlet environments = require('./configEnvironments');\nlet environmentTypes = require('./configEnvironmentTypes');\n\nfunction getEnvironmentType(environmentName) {\n  let rejectIfNotFound = msg => obj => (obj !== null ? Promise.resolve(obj) : Promise.reject(new Error(msg)));\n  return environments.get({ EnvironmentName: environmentName })\n    .then(rejectIfNotFound(`Environment not found: ${environmentName}`))\n    .then(({ Value: { EnvironmentType } }) => environmentTypes.get({ EnvironmentType })\n      .then(rejectIfNotFound(`Environment Type not found: ${EnvironmentType}`)));\n}\n\nfunction convertToOldModel(model) {\n  return omit(['AccountId', 'LoadBalancerGroup'])(model);\n}\n\nfunction convertToNewModel(model) {\n  return Promise.resolve(model)\n  .then(({ EnvironmentName }) => getEnvironmentType(EnvironmentName))\n  .then(environmentType => assign({\n    AccountId: environmentType.Value.AWSAccountNumber,\n    LoadBalancerGroup: environmentType.EnvironmentType\n  })(model));\n}\n\nmodule.exports = {\n  convertToOldModel,\n  convertToNewModel\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/data-access/lbSettingsAdapter.js\n// module id = 272\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet notificationSettings = require('../../../../modules/data-access/notificationSettings');\nlet getMetadataForDynamoAudit = require('../../../api-utils/requestMetadata').getMetadataForDynamoAudit;\nlet param = require('../../../api-utils/requestParam');\nlet versionOf = require('../../../../modules/data-access/dynamoVersion').versionOf;\nlet removeAuditMetadata = require('../../../../modules/data-access/dynamoAudit').removeAuditMetadata;\nconst sns = require('../../../../modules/sns/EnvironmentManagerEvents');\nlet { hasValue, when } = require('../../../../modules/functional');\nlet { ifNotFound, notFoundMessage } = require('../../../api-utils/ifNotFound');\n\nfunction convertToApiModel(persistedModel) {\n  let apiModel = removeAuditMetadata(persistedModel);\n  let Version = versionOf(persistedModel);\n  return Object.assign(apiModel, { Version });\n}\n\n/**\n * GET /config/notification-settings\n */\nfunction getAllNotificationSettings(req, res, next) {\n  return notificationSettings.scan()\n    .then(data => data.map(convertToApiModel))\n    .then(data => res.json(data)).catch(next);\n}\n\n/**\n * GET /config/notification-settings/{id}\n */\nfunction getNotificationSettingsById(req, res, next) {\n  let key = {\n    NotificationSettingsId: param('id', req)\n  };\n  return notificationSettings.get(key)\n    .then(when(hasValue, convertToApiModel))\n    .then(ifNotFound(notFoundMessage('notification setting')))\n    .then(send => send(res))\n    .catch(next);\n}\n\n/**\n * POST /config/notification-settings\n */\nfunction postNotificationSettings(req, res, next) {\n  let body = param('body', req);\n  let metadata = getMetadataForDynamoAudit(req);\n  let record = Object.assign({}, body);\n  delete record.Version;\n  return notificationSettings.create({ record, metadata })\n    .then(data => res.json(data))\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: '/config/notification-settings',\n          Method: 'POST'\n        }\n      }),\n      topic: sns.TOPICS.CONFIGURATION_CHANGE,\n      attributes: {\n        Action: sns.ACTIONS.POST,\n        ID: ''\n      }\n    }))\n    .catch(next);\n}\n\n/**\n * PUT /config/notification-settings/{id}\n */\nfunction putNotificationSettingsById(req, res, next) {\n  let notificationSettingsId = param('id', req);\n  let key = {\n    NotificationSettingsId: notificationSettingsId\n  };\n  let body = param('body', req);\n  let expectedVersion = param('expected-version', req);\n  let metadata = getMetadataForDynamoAudit(req);\n  let record = Object.assign({}, key, { Value: body });\n  delete record.Version;\n  return notificationSettings.replace({ record, metadata }, expectedVersion)\n    .then(data => res.json(data))\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: `/config/notification-settings/${notificationSettingsId}`,\n          Method: 'PUT'\n        }\n      }),\n      topic: sns.TOPICS.CONFIGURATION_CHANGE,\n      attributes: {\n        Action: sns.ACTIONS.PUT,\n        ID: notificationSettingsId\n      }\n    }))\n    .catch(next);\n}\n\n/**\n * DELETE /config/notification-settings/{id}\n */\nfunction deleteNotificationSettingsById(req, res, next) {\n  let notificationSettingsId = param('id', req);\n  let key = {\n    NotificationSettingsId: notificationSettingsId\n  };\n  let expectedVersion = param('expected-version', req);\n  let metadata = getMetadataForDynamoAudit(req);\n  return notificationSettings.delete({ key, metadata }, expectedVersion)\n    .then(data => res.json(data))\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: `/config/notification-settings/${notificationSettingsId}`,\n          Method: 'DELETE'\n        }\n      }),\n      topic: sns.TOPICS.CONFIGURATION_CHANGE,\n      attributes: {\n        Action: sns.ACTIONS.DELETE,\n        ID: notificationSettingsId\n      }\n    }))\n    .catch(next);\n}\n\nmodule.exports = {\n  getAllNotificationSettings,\n  getNotificationSettingsById,\n  postNotificationSettings,\n  putNotificationSettingsById,\n  deleteNotificationSettingsById\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/controllers/config/notification-settings/notificationSettingsController.js\n// module id = 273\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nconst LOGICAL_TABLE_NAME = 'ConfigNotificationSettings';\nconst TTL = 1200; // seconds\n\nlet physicalTableName = require('../awsResourceNameProvider').getTableName;\nlet cachedSingleAccountDynamoTable = require('./cachedSingleAccountDynamoTable');\n\nmodule.exports = cachedSingleAccountDynamoTable(physicalTableName(LOGICAL_TABLE_NAME), { ttl: TTL });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/data-access/notificationSettings.js\n// module id = 274\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nconst KEY_NAME = 'Name';\n\nlet permissions = require('../../../../modules/data-access/permissions');\nlet getMetadataForDynamoAudit = require('../../../api-utils/requestMetadata').getMetadataForDynamoAudit;\nlet param = require('../../../api-utils/requestParam');\nlet versionOf = require('../../../../modules/data-access/dynamoVersion').versionOf;\nlet removeAuditMetadata = require('../../../../modules/data-access/dynamoAudit').removeAuditMetadata;\nconst sns = require('../../../../modules/sns/EnvironmentManagerEvents');\nlet { hasValue, when } = require('../../../../modules/functional');\nlet { ifNotFound, notFoundMessage } = require('../../../api-utils/ifNotFound');\n\nfunction keyOf(value) {\n  let t = {};\n  t[KEY_NAME] = value;\n  return t;\n}\n\nfunction convertToApiModel(persistedModel) {\n  let apiModel = removeAuditMetadata(persistedModel);\n  let Version = versionOf(persistedModel);\n  return Object.assign(apiModel, { Version });\n}\n\n/**\n * GET /config/permissions\n */\nfunction getPermissionsConfig(req, res, next) {\n  return permissions.scan()\n    .then(data => data.map(convertToApiModel))\n    .then(data => res.json(data)).catch(next);\n}\n\n/**\n * GET /config/permissions/{name}\n */\nfunction getPermissionConfigByName(req, res, next) {\n  const key = param('name', req);\n  return permissions.get(keyOf(key))\n    .then(when(hasValue, convertToApiModel))\n    .then(ifNotFound(notFoundMessage('cluster')))\n    .then(send => send(res))\n    .catch(next);\n}\n\n/**\n * POST /config/permissions\n */\nfunction postPermissionsConfig(req, res, next) {\n  const body = param('body', req);\n  let metadata = getMetadataForDynamoAudit(req);\n  let record = Object.assign({}, body);\n  delete record.Version;\n  return permissions.create({ record, metadata })\n    .then(() => res.status(201).end())\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: '/config/permissions',\n          Method: 'POST'\n        }\n      }),\n      topic: sns.TOPICS.CONFIGURATION_CHANGE,\n      attributes: {\n        Action: sns.ACTIONS.POST,\n        ID: body.Name\n      }\n    }))\n    .catch(next);\n}\n\n/**\n * PUT /config/permissions/{name}\n */\nfunction putPermissionConfigByName(req, res, next) {\n  const key = param('name', req);\n  const expectedVersion = param('expected-version', req);\n  const body = param('body', req);\n\n  let metadata = getMetadataForDynamoAudit(req);\n  let record = Object.assign(keyOf(key), { Permissions: body });\n  delete record.Version;\n\n  return permissions.replace({ record, metadata }, expectedVersion)\n    .then(() => res.status(200).end())\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: `/config/permissions/${key}`,\n          Method: 'PUT'\n        }\n      }),\n      topic: sns.TOPICS.CONFIGURATION_CHANGE,\n      attributes: {\n        Action: sns.ACTIONS.PUT,\n        ID: key\n      }\n    }))\n    .catch(next);\n}\n\n/**\n * DELETE /config/permissions/{name}\n */\nfunction deletePermissionConfigByName(req, res, next) {\n  const name = param('name', req);\n  const expectedVersion = param('expected-version', req);\n\n  let key = keyOf(name);\n  let metadata = getMetadataForDynamoAudit(req);\n\n  return permissions.delete({ key, metadata }, expectedVersion)\n    .then(() => res.status(200).end())\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: `/config/permissions/${key}`,\n          Method: 'DELETE'\n        }\n      }),\n      topic: sns.TOPICS.CONFIGURATION_CHANGE,\n      attributes: {\n        Action: sns.ACTIONS.DELETE,\n        ID: name\n      }\n    }))\n    .catch(next);\n}\n\nmodule.exports = {\n  getPermissionsConfig,\n  getPermissionConfigByName,\n  postPermissionsConfig,\n  putPermissionConfigByName,\n  deletePermissionConfigByName\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/controllers/config/permissions/permissionsController.js\n// module id = 275\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nfunction getServerRoleByName(req, res) {\n  res.json([{}, {}, {}]);\n}\n\nfunction postServerRole(req, res) {\n  res.json({});\n}\n\nfunction putServerRoleByName(req, res) {\n  res.json();\n}\n\nfunction deleteServerRoleByName(req, res) {\n  res.json();\n}\n\nmodule.exports = {\n  getServerRoleByName,\n  postServerRole,\n  putServerRoleByName,\n  deleteServerRoleByName\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/controllers/config/server-roles/serverRoleController.js\n// module id = 276\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet services = require('../../../../modules/data-access/services');\nlet getMetadataForDynamoAudit = require('../../../api-utils/requestMetadata').getMetadataForDynamoAudit;\nlet param = require('../../../api-utils/requestParam');\nlet versionOf = require('../../../../modules/data-access/dynamoVersion').versionOf;\nlet removeAuditMetadata = require('../../../../modules/data-access/dynamoAudit').removeAuditMetadata;\nconst sns = require('../../../../modules/sns/EnvironmentManagerEvents');\n\nlet { hasValue, when } = require('../../../../modules/functional');\nlet { ifNotFound, notFoundMessage } = require('../../../api-utils/ifNotFound');\n\nfunction convertToApiModel(persistedModel) {\n  let apiModel = removeAuditMetadata(persistedModel);\n  let Version = versionOf(persistedModel);\n  return Object.assign(apiModel, { Version });\n}\n\n/**\n * GET /config/services\n */\nfunction getServicesConfig(req, res, next) {\n  const returnDeleted = req.query.returnDeleted === 'true';\n  const cluster = param('cluster', req);\n  return (cluster ? services.ownedBy(cluster, returnDeleted) : services.scan(returnDeleted))\n    .then(data => data.map(convertToApiModel))\n    .then(data => res.json(data))\n    .catch(next);\n}\n\n/**\n * GET /config/services/{name}\n */\nfunction getServiceConfigByName(req, res, next) {\n  let key = { ServiceName: param('name', req) };\n  return services.get(key)\n    .then(when(hasValue, convertToApiModel))\n    .then(ifNotFound(notFoundMessage('service')))\n    .then(send => send(res))\n    .catch(next);\n}\n\n/**\n * GET /config/services/{name}/{cluster}\n */\nfunction getServiceConfigByNameAndCluster(req, res, next) {\n  let key = { ServiceName: param('name', req) };\n  let owningCluster = param('cluster', req);\n\n  let existsAndIsOwnedByCluster = x => hasValue(x) &&\n    (x.OwningCluster.toLowerCase() === owningCluster.toLowerCase());\n\n  return services.get(key)\n    .then(when(existsAndIsOwnedByCluster, convertToApiModel))\n    .then(ifNotFound(notFoundMessage('service')))\n    .then(send => send(res))\n    .catch(next);\n}\n\n/**\n * POST /config/services\n */\nfunction postServicesConfig(req, res, next) {\n  const body = param('body', req);\n  let metadata = getMetadataForDynamoAudit(req);\n  let record = Object.assign({}, body);\n  delete record.Version;\n  return services.create({ record, metadata })\n    .then(() => res.status(201).end())\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: '/config/services',\n          Method: 'POST'\n        }\n      }),\n      topic: sns.TOPICS.CONFIGURATION_CHANGE,\n      attributes: {\n        Action: sns.ACTIONS.POST,\n        ID: `${body.ServiceName}`\n      }\n    }))\n    .catch(next);\n}\n\n/**\n * PUT /config/services/{name}/{cluster}\n */\nfunction putServiceConfigByName(req, res, next) {\n  let serviceName = param('name', req);\n  let owningCluster = param('cluster', req);\n  let key = { ServiceName: serviceName };\n  const expectedVersion = param('expected-version', req);\n  const body = param('body', req);\n  let metadata = getMetadataForDynamoAudit(req);\n  let record = Object.assign(key, { OwningCluster: owningCluster }, { Value: body });\n  delete record.Version;\n\n  return services.replace({ record, metadata }, expectedVersion)\n    .then(() => res.status(200).end())\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: `/config/services/${serviceName}/${owningCluster}`,\n          Method: 'PUT'\n        }\n      }),\n      topic: sns.TOPICS.CONFIGURATION_CHANGE,\n      attributes: {\n        Action: sns.ACTIONS.PUT,\n        ID: `${serviceName}/${owningCluster}`\n      }\n    }))\n    .catch(next);\n}\n\n/**\n * DELETE /config/services/{name}\n */\nfunction deleteServiceConfigByName(req, res, next) {\n  let serviceName = param('name', req);\n  let key = { ServiceName: serviceName };\n  const expectedVersion = param('expected-version', req);\n  let metadata = getMetadataForDynamoAudit(req);\n\n  let updateExpression = ['update',\n    ['set', ['at', 'Deleted'], ['val', 'true']]\n  ];\n  return services.update({ key, metadata, updateExpression }, expectedVersion)\n    .then(() => res.status(200).end())\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: `/config/services/${serviceName}`,\n          Method: 'DELETE'\n        }\n      }),\n      topic: sns.TOPICS.CONFIGURATION_CHANGE,\n      attributes: {\n        Action: sns.ACTIONS.DELETE,\n        ID: serviceName\n      }\n    }))\n    .catch(next);\n}\n\n/**\n * DELETE /config/services/{name}/{cluster} [DEPRECATED]\n */\nfunction deleteServiceConfigByNameAndCluster(req, res, next) {\n  let serviceName = param('name', req);\n  let owningCluster = param('cluster', req);\n  let key = { ServiceName: serviceName };\n  const expectedVersion = param('expected-version', req);\n  let metadata = getMetadataForDynamoAudit(req);\n\n  let updateExpression = ['update',\n    ['set', ['at', 'Deleted'], ['val', 'true']]\n  ];\n  return services.update({ key, metadata, updateExpression }, expectedVersion, { ConditionExpression: ['=', ['at', 'OwningCluster'], ['val', owningCluster]] })\n    .then(() => res.status(200).end())\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: `/config/services/${serviceName}/${owningCluster}`,\n          Method: 'DELETE'\n        }\n      }),\n      topic: sns.TOPICS.CONFIGURATION_CHANGE,\n      attributes: {\n        Action: sns.ACTIONS.DELETE,\n        ID: `${serviceName}/${owningCluster}`\n      }\n    }))\n    .catch(next);\n}\n\nmodule.exports = {\n  getServicesConfig,\n  getServiceConfigByName,\n  getServiceConfigByNameAndCluster,\n  postServicesConfig,\n  putServiceConfigByName,\n  deleteServiceConfigByName,\n  deleteServiceConfigByNameAndCluster\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/controllers/config/services/servicesConfigController.js\n// module id = 277\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet Promise = require('bluebird');\nlet logger = require('../../../../modules/logger');\nlet { assign, flatten, flow, map, omit } = require('lodash/fp');\nlet { versionOf } = require('../../../../modules/data-access/dynamoVersion');\nlet { removeAuditMetadata } = require('../../../../modules/data-access/dynamoAudit');\nlet { convertToNewModel, convertToOldModel } = require('../../../../modules/data-access/lbUpstreamAdapter');\nlet loadBalancerUpstreams = require('../../../../modules/data-access/loadBalancerUpstreams');\nlet services = require('../../../../modules/data-access/services');\nlet { getMetadataForDynamoAudit } = require('../../../api-utils/requestMetadata');\nlet param = require('../../../api-utils/requestParam');\nlet { validate } = require('../../../../commands/validators/lbUpstreamValidator');\nlet { getByName: getAccount } = require('../../../../modules/awsAccounts');\nlet InvalidItemSchemaError = require('../../../../modules/errors/InvalidItemSchemaError.class');\nconst sns = require('../../../../modules/sns/EnvironmentManagerEvents');\n\nfunction rejectIfValidationFailed(validationResult) {\n  if (!validationResult.isValid) {\n    logger.info('Upstream Validation Failure', validationResult.err);\n    return Promise.reject(new InvalidItemSchemaError(validationResult.err));\n  } else {\n    return Promise.resolve();\n  }\n}\n\nfunction convertToApiModel(persistedModel) {\n  let apiModel = removeAuditMetadata(persistedModel);\n  let Version = versionOf(persistedModel);\n  return Object.assign(apiModel, { Version });\n}\n\n/**\n * GET /config/upstreams\n */\nfunction getUpstreamsConfig(req, res, next) {\n  const environment = param('environment', req);\n  const queryAttribute = param('qa', req);\n  const queryValues = param('qv', req);\n\n  function get(attribute, value) {\n    return (() => {\n      switch (attribute) {\n        case 'environment':\n          return loadBalancerUpstreams.inEnvironment(value);\n        case 'load-balancer-group':\n          return loadBalancerUpstreams.inLoadBalancerGroup(value);\n        default:\n          return loadBalancerUpstreams.scan();\n      }\n    })().then(({ Items }) => Items);\n  }\n\n  return (() => {\n    if (environment) {\n      return get('environment', environment);\n    } else if (queryAttribute && queryValues) {\n      return Promise.map(queryValues, value => get(queryAttribute, value)).then(flatten);\n    } else {\n      return get();\n    }\n  })()\n    .then(map(flow(convertToOldModel, convertToApiModel)))\n    .then(data => res.json(data))\n    .catch(next);\n}\n\n/**\n * GET /config/upstreams/{name}\n */\nfunction getUpstreamConfigByName(req, res, next) {\n  let Key = param('name', req);\n  return loadBalancerUpstreams.get({ Key })\n    .then(flow(convertToOldModel, convertToApiModel))\n    .then(data => res.json(data))\n    .catch(next);\n}\n\n/**\n * POST /config/upstreams\n */\nfunction postUpstreamsConfig(req, res, next) {\n  const body = param('body', req);\n  let metadata = getMetadataForDynamoAudit(req);\n  let oldRecord = omit('version')(body);\n  let newRecordP = convertToNewModel(oldRecord);\n  let accountP = newRecordP.then(({ AccountId }) => getAccount(AccountId));\n  let serviceP = services.get({ ServiceName: oldRecord.Value.ServiceName });\n\n  return Promise.join(accountP, newRecordP, serviceP,\n    (account, record, svc) => Promise.resolve()\n      .then(() => validate(oldRecord, svc))\n      .then(rejectIfValidationFailed)\n      .then(() => loadBalancerUpstreams.create({ record, metadata })))\n    .then(() => res.status(200).end())\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: '/config/upstreams',\n          Method: 'POST',\n          Parameters: [\n            {\n              Name: 'body',\n              Type: 'body',\n              Value: body || ''\n            }\n          ]\n        }\n      }),\n      topic: sns.TOPICS.CONFIGURATION_CHANGE,\n      attributes: {\n        Action: sns.ACTIONS.POST,\n        ID: '_'\n      }\n    }))\n    .catch(next);\n}\n\n/**\n * PUT /config/upstreams/{name}\n */\nfunction putUpstreamConfigByName(req, res, next) {\n  let body = param('body', req);\n  let key = { key: param('name', req) };\n  let expectedVersion = param('expected-version', req);\n  let metadata = getMetadataForDynamoAudit(req);\n  let oldRecord = flow(assign(key), omit('version'))({ Value: body });\n  let newRecordP = convertToNewModel(oldRecord);\n  let accountP = newRecordP.then(({ AccountId }) => getAccount(AccountId));\n  let serviceP = services.get({ ServiceName: oldRecord.Value.ServiceName });\n\n  return Promise.join(accountP, newRecordP, serviceP,\n    (account, record, svc) => Promise.resolve()\n      .then(() => validate(oldRecord, svc))\n      .then(rejectIfValidationFailed)\n      .then(() => loadBalancerUpstreams.replace({ record, metadata }, expectedVersion)))\n    .then(() => res.status(200).end())\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: `/config/upstreams/${param('name', req)}`,\n          Method: 'PUT',\n          Parameters: [\n            {\n              Name: 'name',\n              Type: 'path',\n              Value: (param('name', req)) || ''\n            },\n            {\n              Name: 'body',\n              Type: 'body',\n              Value: body || ''\n            }\n          ]\n        }\n      }),\n      topic: sns.TOPICS.CONFIGURATION_CHANGE,\n      attributes: {\n        Action: sns.ACTIONS.PUT,\n        ID: `${JSON.stringify(key)}`\n      }\n    }))\n    .catch(next);\n}\n\n/**\n * DELETE /config/upstreams/{name}\n */\nfunction deleteUpstreamConfigByName(req, res) {\n  let Key = param('name', req);\n  let key = { Key };\n  const expectedVersion = param('expected-version', req);\n  let metadata = getMetadataForDynamoAudit(req);\n\n  return loadBalancerUpstreams.delete({ key, metadata }, expectedVersion)\n    .then(() => res.status(200).end());\n}\n\nmodule.exports = {\n  getUpstreamsConfig,\n  getUpstreamConfigByName,\n  postUpstreamsConfig,\n  putUpstreamConfigByName,\n  deleteUpstreamConfigByName\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/controllers/config/upstreams/upstreamsConfigController.js\n// module id = 278\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet environments = require('./configEnvironments');\nlet environmentTypes = require('./configEnvironmentTypes');\n\nfunction getEnvironmentType(environmentName) {\n  let rejectIfNotFound = msg => obj => (obj !== null ? Promise.resolve(obj) : Promise.reject(new Error(msg)));\n  return environments.get({ EnvironmentName: environmentName })\n    .then(rejectIfNotFound(`Environment not found: ${environmentName}`))\n    .then(({ Value: { EnvironmentType } }) => environmentTypes.get({ EnvironmentType })\n      .then(rejectIfNotFound(`Environment Type not found: ${EnvironmentType}`)));\n}\n\nfunction convertToOldModel(model) {\n  return {\n    Audit: model.Audit,\n    key: model.Key,\n    Value: {\n      EnvironmentName: model.Environment,\n      Hosts: model.Hosts,\n      LoadBalancingMethod: model.LoadBalancingMethod,\n      PersistenceMethod: model.PersistenceMethod,\n      SchemaVersion: model.SchemaVersion,\n      ServiceName: model.Service,\n      SlowStart: model.SlowStart,\n      UpStreamKeepalives: model.UpStreamKeepalives,\n      UpstreamName: model.Upstream,\n      MarkForDelete: model.MarkForDelete,\n      MarkForDeleteTimestamp: model.MarkForDeleteTimestamp,\n      ZoneSize: model.ZoneSize\n    }\n  };\n}\n\nfunction convertToNewModel(model) {\n  return Promise.resolve()\n    .then(() => {\n      if (model.__Deleted) { // eslint-disable-line no-underscore-dangle\n        return {\n          __Deleted: true,\n          Audit: model.Audit,\n          Key: model.key\n        };\n      } else {\n        let environmentName = model.Value.EnvironmentName;\n        return getEnvironmentType(environmentName)\n          .then(environmentType => ({\n            AccountId: environmentType.Value.AWSAccountNumber,\n            Audit: model.Audit,\n            Environment: environmentName,\n            Hosts: model.Value.Hosts,\n            Key: model.key,\n            LoadBalancerGroup: environmentType.EnvironmentType,\n            LoadBalancingMethod: model.Value.LoadBalancingMethod,\n            PersistenceMethod: model.Value.PersistenceMethod,\n            SchemaVersion: model.Value.SchemaVersion,\n            Service: model.Value.ServiceName,\n            SlowStart: model.Value.SlowStart,\n            Upstream: model.Value.UpstreamName,\n            UpStreamKeepalives: model.Value.UpStreamKeepalives,\n            ZoneSize: model.Value.ZoneSize,\n            MarkForDelete: model.Value.MarkForDelete,\n            MarkForDeleteTimestamp: model.Value.MarkForDeleteTimestamp\n          }));\n      }\n    });\n}\n\nmodule.exports = {\n  convertToOldModel,\n  convertToNewModel\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/data-access/lbUpstreamAdapter.js\n// module id = 279\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet _ = require('lodash');\n\nlet valid = {\n  isValid: true\n};\n\nlet invalid = err => ({ isValid: false, err });\n\nfunction validateDnsName(dnsName) {\n  let consulMatch = /^[^\\.]*?-[^\\.]*$/.exec(dnsName);\n  if (consulMatch) return valid;\n\n  if (!_.includes(dnsName, '.')) {\n    return invalid(`\"${dnsName}\" is not a valid as it contains no dots`);\n  }\n\n  let regex = /^([a-zA-Z0-9-]*?)\\.(.*)$/;\n  let matches = regex.exec(dnsName);\n\n  if (!matches) {\n    return invalid(`\"${dnsName}\" is not a valid as it contains illegal characters`);\n  }\n\n  let subDomain = matches[1];\n\n  if (subDomain.startsWith('-') || subDomain.endsWith('-')) {\n    return invalid(`\"${dnsName}\" is not valid as sub domains must not begin or end with a hyphen`);\n  }\n\n  let hyphensCount = (subDomain.match(/-/g) || []).length;\n  if (hyphensCount > 3) return invalid(`\"${dnsName}\" is not valid as sub domains must not contain more than 3 hyphens`);\n\n  return valid;\n}\n\nfunction validatePort(port, service) {\n  let safePort = _.isNil(port) ? null : String(port);\n  let safeBluePort = _.isNil(service.Value.BluePort) ? null : String(service.Value.BluePort);\n  let safeGreenPort = _.isNil(service.Value.GreenPort) ? null : String(service.Value.GreenPort);\n\n  if (safePort && safeBluePort && safeGreenPort) {\n    if (safePort !== safeBluePort && safePort !== safeGreenPort) {\n      let err = `Host port ${safePort} does not match blue or green port of ${service.ServiceName}`;\n      return invalid(err);\n    }\n  }\n\n  return valid;\n}\n\nexports.validate = (upstream, service) => {\n  let hosts = upstream.Value.Hosts;\n\n  if (hosts) {\n    for (let host of hosts) {\n      let dnsCheck = validateDnsName(host.DnsName);\n      if (!dnsCheck.isValid) {\n        return dnsCheck;\n      }\n\n      if (service) {\n        let portCheck = validatePort(host.Port, service);\n        if (!portCheck.isValid) {\n          return portCheck;\n        }\n      }\n    }\n  }\n\n  return valid;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/commands/validators/lbUpstreamValidator.js\n// module id = 280\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet util = require('util');\nlet BaseError = require('./BaseError.class');\n\nmodule.exports = function InvalidItemSchemaError(message, innerError) {\n  this.name = this.constructor.name;\n  this.message = message;\n  this.innerError = innerError;\n\n  Error.captureStackTrace(this, this.constructor);\n};\n\nutil.inherits(module.exports, BaseError);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/errors/InvalidItemSchemaError.class.js\n// module id = 281\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet deploymentsHelper = require('../../../modules/queryHandlersUtil/deployments-helper');\nlet GetNodeDeploymentLog = require('../../../queryHandlers/deployments/GetNodeDeploymentLog');\nlet co = require('co');\nlet sender = require('../../../modules/sender');\nlet Enums = require('../../../Enums');\nlet activeDeploymentsStatusProvider = require('../../../modules/monitoring/activeDeploymentsStatusProvider');\nlet deploymentLogger = require('../../../modules/DeploymentLogger');\nconst sns = require('../../../modules/sns/EnvironmentManagerEvents');\nlet { ifNotFound, notFoundMessage } = require('../../api-utils/ifNotFound');\nconst { toggleServiceStatus } = require('../../../modules/toggleServiceStatus');\nlet DeployService = require('../../../commands/deployments/DeployService');\n\n/**\n * GET /deployments\n */\nfunction getDeployments(req, res, next) {\n  const since = req.swagger.params.since.value;\n  const environment = req.swagger.params.environment.value;\n  const status = req.swagger.params.status.value;\n  const cluster = req.swagger.params.cluster.value;\n\n  deploymentsHelper.scan({\n    since, environment, status, cluster\n  }).then(data => res.json(data)).catch(next);\n}\n\n/**\n * GET /deployments/{key}\n */\nfunction getDeploymentById(req, res, next) {\n  const key = req.swagger.params.id.value;\n\n  return deploymentsHelper.get({ key })\n    .then(ifNotFound(notFoundMessage('deployment')))\n    .then(send => send(res))\n    .catch(next);\n}\n\n/**\n * GET /deployments/{id}/log\n */\nfunction getDeploymentLog(req, res, next) {\n  return co(function* () {\n    const key = req.swagger.params.id.value;\n    const accountName = req.swagger.params.account.value;\n    const instanceId = req.swagger.params.instance.value;\n\n    let deployment = yield deploymentsHelper.get({ key, account: accountName });\n    let environment = deployment.Value.EnvironmentName;\n\n    let query = {\n      accountName,\n      environment,\n      deploymentId: key,\n      instanceId\n    };\n\n    return GetNodeDeploymentLog(query).then((data) => {\n      res.set('Content-Type', 'text/plain').send(data);\n    });\n  }).catch(next);\n}\n\n/**\n * POST /deployments\n */\nfunction postDeployment(req, res, next) {\n  const body = req.swagger.params.body.value;\n  const environmentName = body.environment;\n  const serviceName = body.service;\n  const serviceVersion = body.version;\n  const packagePath = body.packageLocation;\n  const mode = body.mode || 'overwrite';\n  const serviceSlice = body.slice || 'none';\n  const serverRoleName = req.serverRoleName;\n  const isDryRun = req.swagger.params.dry_run.value;\n\n  let command = {\n    name: 'DeployService',\n    environmentName,\n    serviceName,\n    serviceVersion,\n    serviceSlice,\n    mode,\n    packagePath,\n    serverRoleName,\n    isDryRun\n  };\n\n  if (packagePath) {\n    let now = new Date().toUTCString();\n    res.locals.deprecated = true;\n    res.append('Warning', `299 - Package Location property is deprecated for deployments.\"${now}\"`);\n  }\n\n  sender.sendCommand(DeployService, { command, user: req.user }).then((deployment) => {\n    if (deployment.isDryRun) {\n      res.status(200);\n      res.json(deployment);\n    } else {\n      res.status(202);\n      res.location(`/api/${deployment.accountName}/deployments/history/${deployment.id}`);\n      res.json(deployment);\n    }\n  })\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: '/deployments',\n          Method: 'POST'\n        }\n      }),\n      topic: sns.TOPICS.OPERATIONS_CHANGE,\n      attributes: {\n        Environment: environmentName,\n        Action: sns.ACTIONS.POST,\n        ID: serviceName\n      }\n    }))\n    .catch(next);\n}\n\n/**\n * PATCH /deployments/{key}\n */\nfunction patchDeployment(req, res, next) {\n  let key = null;\n  return co(function* () {\n    const body = req.swagger.params.body.value;\n    key = req.swagger.params.id.value;\n    let status = body.Status;\n    let action = body.Action;\n\n    if (status !== undefined && status !== Enums.DEPLOYMENT_STATUS.Cancelled) {\n      let error = `You can only PATCH deployment with { Status: '${Enums.DEPLOYMENT_STATUS.Cancelled}' } to cancel it.`;\n      res.send({ error });\n      res.status(400);\n      return null;\n    }\n\n    if (status === Enums.DEPLOYMENT_STATUS.Cancelled) {\n      let deployment = yield deploymentsHelper.get({ key });\n      if (deployment.Value.Status !== Enums.DEPLOYMENT_STATUS.InProgress) {\n        throw new Error('You can only cancel deployments that are In Progress');\n      }\n\n      let newStatus = {\n        name: Enums.DEPLOYMENT_STATUS.Cancelled,\n        reason: `The deployment was cancelled manually by user: ${req.user.getName()}`\n      };\n      let deploymentStatuses = yield activeDeploymentsStatusProvider.getActiveDeploymentsFullStatus([deployment]);\n      let deploymentStatus = deploymentStatuses[0];\n      yield deploymentLogger.updateStatus(deploymentStatus, newStatus);\n      return switchDeployment(key, false, req.user);\n    } else if (action !== undefined) {\n      let enable;\n      if (action === Enums.ServiceAction.IGNORE) {\n        enable = false;\n      } else if (action === Enums.ServiceAction.INSTALL) {\n        enable = true;\n      } else {\n        throw new Error(`Invalid Action: \"${action}\", only \"Install\" and \"Ignore\" are allowed.`);\n      }\n      return switchDeployment(key, enable, req.user);\n    } else {\n      return null;\n    }\n  })\n    .then(data => res.json(data))\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: `/deployments/${key}`,\n          Method: 'PATCH'\n        }\n      }),\n      topic: sns.TOPICS.OPERATIONS_CHANGE,\n      attributes: {\n        Environment: '',\n        Action: sns.ACTIONS.PATCH,\n        ID: key\n      }\n    })\n    )\n    .catch(next);\n}\n\nfunction switchDeployment(key, enable, user) {\n  return deploymentsHelper.get({ key }).then((deployment) => {\n    // Old deployments don't have 'ServerRoleName' and 'RuntimeServerRoleName' fields.\n    // Unfortunately we are unable to determine these from existing data.\n    if (deployment.Value.ServerRoleName === undefined || deployment.Value.RuntimeServerRoleName === undefined) {\n      throw new Error('This operation is unsupported for Deployments started before 01.2017. If you would like to use this feature,'\n        + 'please redeploy your service before trying again, or contact Platform Dev team.');\n    }\n    let serverRole = deployment.Value.RuntimeServerRoleName;\n    let environment = deployment.Value.EnvironmentName;\n    let slice = deployment.Value.ServiceSlice;\n    let service = deployment.Value.ServiceName;\n\n    return toggleServiceStatus({ environment, service, slice, enable, serverRole, user });\n  });\n}\n\nmodule.exports = {\n  getDeployments,\n  getDeploymentById,\n  getDeploymentLog,\n  postDeployment,\n  patchDeployment\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/controllers/deployments/deploymentsController.js\n// module id = 282\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet co = require('co');\nlet serviceTargets = require('../../modules/service-targets');\nlet Enums = require('../../Enums');\n\nconst SERVICE_INSTALL = Enums.ServiceAction.INSTALL;\nconst SERVICE_IGNORE = Enums.ServiceAction.IGNORE;\n\nfunction* ToggleTargetStatus(command) {\n  let environment = command.environment;\n  let serviceName = command.service;\n  let serverRole = command.serverRole;\n  let slice = command.slice;\n  let enabled = command.enable;\n  let key = `environments/${environment}/roles/${serverRole}/services/${serviceName}/${slice}`;\n  let state = yield serviceTargets.getTargetState(environment, { key });\n  let service = state.value;\n  let previousStatus = service.Action || SERVICE_INSTALL;\n\n  service.Action = enabled ? SERVICE_INSTALL : SERVICE_IGNORE;\n\n  try {\n    yield serviceTargets.setTargetState(environment, { key, value: service });\n    return service;\n  } catch (error) {\n    throw new Error(\n      `There was a problem updating the future installation status for ${serviceName}. Its status is still currently set to ${previousStatus}`);\n  }\n}\n\nmodule.exports = co.wrap(ToggleTargetStatus);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/commands/services/ToggleTargetStatus.js\n// module id = 283\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet co = require('co');\nlet Enums = require('../../Enums');\nlet DeploymentContract = require('../../modules/deployment/DeploymentContract');\nlet sender = require('../../modules/sender');\nlet infrastructureConfigurationProvider = require('../../modules/provisioning/infrastructureConfigurationProvider');\nlet logger = require('../../modules/logger');\nlet namingConventionProvider = require('../../modules/provisioning/namingConventionProvider');\nconst PackagePathProvider = require('../../modules/PackagePathProvider');\nlet deploymentLogger = require('../../modules/DeploymentLogger');\nlet _ = require('lodash');\nlet SupportedSliceNames = _.values(Enums.SliceName);\nlet SupportedDeploymentModes = _.values(Enums.DeploymentMode);\nlet s3PackageLocator = require('../../modules/s3PackageLocator');\nlet EnvironmentHelper = require('../../models/Environment');\nlet OpsEnvironment = require('../../models/OpsEnvironment');\nlet ResourceLockedError = require('../../modules/errors/ResourceLockedError');\nlet GetServicePortConfig = require('../../queryHandlers/GetServicePortConfig');\nlet GetInfrastructureRequirements = require('../../commands/deployments/GetInfrastructureRequirements');\nlet PushDeployment = require('../../commands/deployments/PushDeployment');\nlet PreparePackage = require('../../commands/deployments/PreparePackage');\nlet ProvideInfrastructure = require('../../commands/deployments/ProvideInfrastructure');\n\nlet packagePathProvider = new PackagePathProvider();\n\nmodule.exports = function DeployServiceCommandHandler(command) {\n  return co(function* () {\n    let deployment = yield validateCommandAndCreateDeployment(command);\n    let destination = yield packagePathProvider.getS3Path(deployment);\n    let sourcePackage = getSourcePackageByCommand(command);\n\n    if (command.isDryRun) {\n      return {\n        isDryRun: true,\n        packagePath: command.packagePath\n      };\n    }\n\n    let accountName = deployment.accountName;\n    yield deploymentLogger.started(deployment, accountName);\n    // Run asynchronously, we don't wait for deploy to finish intentionally\n    deploy(deployment, destination, sourcePackage, command);\n\n    return deployment;\n  });\n};\n\nfunction validateCommandAndCreateDeployment(command) {\n  return co(function* () {\n    const { mode, environmentName, serviceSlice, serviceName, serviceVersion } = command;\n\n    if (mode === 'overwrite' && serviceSlice !== undefined && serviceSlice !== 'none') {\n      throw new Error('Slice must be set to \\'none\\' in overwrite mode.');\n    }\n    if (SupportedDeploymentModes.indexOf(mode.toLowerCase()) < 0) {\n      throw new Error(`Unknown mode \\'${mode}\\'. Supported modes are: ${SupportedDeploymentModes.join(', ')}`);\n    }\n    if (mode === 'bg' && SupportedSliceNames.indexOf(serviceSlice) < 0) {\n      throw new Error(`Unknown slice \\'${serviceSlice}\\'. Supported slices are: ${SupportedSliceNames.join(', ')}`);\n    }\n\n    if (!command.packagePath) {\n      let s3Package;\n      try {\n        s3Package = yield s3PackageLocator.findDownloadUrl({\n          environment: environmentName,\n          service: serviceName,\n          version: serviceVersion\n        });\n      } catch (error) {\n        throw new Error(`An attempt to locate the following package in S3 was forbidden: ${serviceName} version ${serviceVersion}`);\n      }\n\n      if (!s3Package) {\n        throw new Error('Deployment package was not found. Please specify a location or upload the package to S3');\n      } else {\n        command.packagePath = s3Package;\n      }\n    }\n\n    const environment = yield EnvironmentHelper.getByName(command.environmentName);\n    const opsEnvironment = yield OpsEnvironment.getByName(command.environmentName);\n    const environmentType = yield environment.getEnvironmentType();\n    command.accountName = environmentType.AWSAccountName;\n    const servicePortConfig = yield GetServicePortConfig(command.serviceName, command.serviceSlice);\n\n    if (opsEnvironment.Value.DeploymentsLocked) {\n      throw new ResourceLockedError(`The environment ${environmentName} is currently locked for deployments. Contact the environment owner.`);\n    }\n\n    let configuration = yield infrastructureConfigurationProvider.get(\n      command.environmentName, command.serviceName, command.serverRoleName\n    );\n\n    let roleName = namingConventionProvider.getRoleName(configuration, command.serviceSlice);\n\n    let deploymentContract = new DeploymentContract({\n      id: command.commandId,\n      environmentTypeName: configuration.environmentTypeName,\n      environmentName: command.environmentName,\n      serviceName: command.serviceName,\n      serviceVersion: command.serviceVersion,\n      serviceSlice: command.serviceSlice || '',\n      servicePortConfig,\n      serverRole: roleName,\n      serverRoleName: command.serverRoleName,\n      clusterName: configuration.cluster.Name,\n      accountName: command.accountName,\n      username: command.username\n    });\n    yield deploymentContract.validate(configuration);\n    return deploymentContract;\n  });\n}\n\nfunction deploy(deployment, destination, sourcePackage, command) {\n  return co(function* () {\n    const accountName = deployment.accountName;\n    const requiredInfra = yield getInfrastructureRequirements(accountName, deployment, command);\n    yield provideInfrastructure(accountName, requiredInfra, command);\n    yield preparePackage(accountName, destination, sourcePackage, command);\n    yield pushDeployment(accountName, requiredInfra, deployment, destination, command);\n\n    deploymentLogger.inProgress(\n      deployment.id,\n      'Waiting for nodes to perform service deployment...'\n    );\n  }).catch((error) => {\n    let deploymentStatus = {\n      deploymentId: deployment.id,\n      environmentName: deployment.environmentName,\n      accountName: deployment.accountName\n    };\n\n    let newStatus = {\n      name: Enums.DEPLOYMENT_STATUS.Failed,\n      reason: sanitiseError(error)\n    };\n\n    return deploymentLogger.updateStatus(deploymentStatus, newStatus);\n  }).catch(error => logger.error(error));\n}\n\nfunction sanitiseError(error) {\n  if (_.isObjectLike(error) && !(error instanceof Error)) {\n    return JSON.stringify(error);\n  }\n  return _.toString(error);\n}\n\nfunction getInfrastructureRequirements(accountName, deployment, parentCommand) {\n  let command = {\n    name: 'GetInfrastructureRequirements',\n    accountName,\n    deployment\n  };\n\n  return sender.sendCommand(GetInfrastructureRequirements, { command, parent: parentCommand });\n}\n\nfunction provideInfrastructure(accountName, requiredInfra, parentCommand) {\n  let command = {\n    name: 'ProvideInfrastructure',\n    accountName,\n    asgsToCreate: requiredInfra.asgsToCreate,\n    launchConfigsToCreate: requiredInfra.launchConfigsToCreate\n  };\n\n  return sender.sendCommand(ProvideInfrastructure, { command, parent: parentCommand });\n}\n\nfunction preparePackage(accountName, destination, source, parentCommand) {\n  let command = {\n    name: 'PreparePackage',\n    accountName,\n    destination,\n    source\n  };\n\n  return sender.sendCommand(PreparePackage, { command, parent: parentCommand });\n}\n\nfunction pushDeployment(accountName, requiredInfra, deployment, s3Path, parentCommand) {\n  let command = {\n    name: 'PushDeployment',\n    accountName,\n    deployment,\n    s3Path,\n    expectedNodeDeployments: requiredInfra.expectedInstances\n  };\n\n  return sender.sendCommand(PushDeployment, { command, parent: parentCommand });\n}\n\nfunction getSourcePackageByCommand(command) {\n  return {\n    url: command.packagePath\n  };\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/commands/deployments/DeployService.js\n// module id = 284\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet deploymentValidators = require('./deploymentValidators');\nlet _ = require('lodash');\n\nclass DeploymentContract {\n\n  constructor(data) {\n    _.assign(this, data);\n  }\n\n  validate(configuration) {\n    // Checking deployment is valid through all validators otherwise return a rejected promise\n    return deploymentValidators.map(validator => validator.validate(this, configuration));\n  }\n\n}\n\n\nmodule.exports = DeploymentContract;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/deployment/DeploymentContract.js\n// module id = 285\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nconst blueGreenDeploymentValidator = require('./validators/blueGreenDeploymentValidator');\nconst uniqueServiceVersionDeploymentValidator = require('./validators/uniqueServiceVersionDeploymentValidator');\n\nlet validators = [\n  blueGreenDeploymentValidator,\n  uniqueServiceVersionDeploymentValidator\n];\n\nmodule.exports = validators;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/deployment/deploymentValidators.js\n// module id = 286\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet _ = require('lodash');\nlet Enums = require('../../../Enums');\nlet DeploymentValidationError = require('../../errors/DeploymentValidationError.class');\nconst SupportedSliceNames = _.values(Enums.SliceName);\n\nmodule.exports = {\n  validate(deployment, configuration) {\n    if (configuration.serverRole.FleetPerSlice !== true) return Promise.resolve();\n    if (SupportedSliceNames.indexOf(deployment.serviceSlice) >= 0) return Promise.resolve();\n\n    return Promise.reject(new DeploymentValidationError(\n      `${'Server role configuration expects two AutoScalingGroups ' +\n      `for '${deployment.serviceName}' blue/green slices ` +\n      'but current deployment slice is '}${\n      deployment.serviceSlice ? `'${deployment.serviceSlice}'.` : 'empty.'}`\n    ));\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/deployment/validators/blueGreenDeploymentValidator.js\n// module id = 287\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet deployments = require('../../data-access/deployments');\nlet DeploymentValidationError = require('../../errors/DeploymentValidationError.class');\n\nfunction validateServiceNotCurrentlyBeingDeployed(deployment) {\n  let expectedStatus = 'In Progress';\n  let query = {\n    FilterExpression: ['and',\n      ['=', ['at', 'Value', 'EnvironmentName'], ['val', deployment.environmentName]],\n      ['=', ['at', 'Value', 'SchemaVersion'], ['val', 2]],\n      ['=', ['at', 'Value', 'ServiceName'], ['val', deployment.serviceName]],\n      ['=', ['at', 'Value', 'Status'], ['val', expectedStatus]]\n    ]\n  };\n\n  return deployments.scanRunning(query).then((results) => {\n    if (results.length) {\n      let { serviceName: service, serverRoleName: role } = deployment;\n      return Promise.reject(new DeploymentValidationError(\n        `The '${service}' service is already being deployed to '${role}' at this time.`\n      ));\n    }\n\n    return Promise.resolve();\n  });\n}\n\nmodule.exports = {\n  validate(deployment) {\n    return Promise.all([\n      validateServiceNotCurrentlyBeingDeployed(deployment)\n    ]);\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/deployment/validators/uniqueServiceVersionDeploymentValidator.js\n// module id = 288\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet S3PathContract = require('./deployment/S3PathContract');\nlet configCache = require('./configurationCache');\n\nmodule.exports = function PackagePathProvider() {\n  this.getS3Path = function (deployment) {\n    return configCache\n      .getEnvironmentTypeByName(deployment.environmentTypeName)\n      .then((environmentType) => {\n        let filePath = `${deployment.environmentName}/${deployment.serviceName}`;\n        let fileName = `${deployment.serviceName}-${deployment.serviceVersion}.zip`;\n\n        return Promise.resolve(new S3PathContract({\n          bucket: environmentType.DeploymentBucket,\n          key: `${filePath}/${fileName}`\n        }));\n      });\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/PackagePathProvider.js\n// module id = 289\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nmodule.exports = function S3PathContract(options) {\n  this.bucket = options.bucket;\n  this.key = options.key;\n  this.getType = () => this.constructor.name;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/deployment/S3PathContract.js\n// module id = 290\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet later = require('later');\n\nconst cronActions = {\n  start: 'on',\n  stop: 'off'\n};\n\nfunction tryParseSchedule(serialisedSchedule) {\n  try {\n    return parseSchedule(serialisedSchedule);\n  } catch (err) {\n    return invalid(err);\n  }\n}\n\nfunction parseSchedule(serialisedSchedule) {\n  let schedule = serialisedSchedule.trim().toLowerCase();\n\n  if (schedule === 'noschedule') { return skip(); }\n\n  if (['on', '247', 'off'].some(x => x === schedule)) {\n    return permanent(schedule);\n  }\n\n  let parseResult = tryParseCronSchedule(schedule);\n\n  if (!parseResult.success) {\n    return invalid(`Could not parse cron schedule - Error: '${parseResult.error}'`);\n  }\n\n  return parseResult;\n}\n\nfunction tryParseCronSchedule(serialisedCronSchedule) {\n  try {\n    return parseCronSchedule(serialisedCronSchedule);\n  } catch (err) {\n    return { success: false, error: err };\n  }\n}\n\nfunction parseCronSchedule(serialisedCronSchedule) {\n  let [serializedSchedule, timezone] = serialisedCronSchedule.split('|');\n  if (timezone) timezone = timezone.trim();\n\n  let schedule = serializedSchedule.split(';').map((item) => {\n    let parts = item.split(':');\n    let state = (cronActions[parts[0].trim()] || parts[0].trim());\n\n    if (state === undefined || state === '' || parts[1] === undefined || parts[1].trim() === '') {\n      throw new Error('Invalid cron action');\n    }\n\n    let recurrence = later.parse.cron(parts[1].trim());\n    return { state, recurrence };\n  });\n\n  return {\n    success: true,\n    schedule,\n    timezone\n  };\n}\n\nfunction permanent(schedule) {\n  let state = schedule === 'off' ? 'off' : 'on';\n  return { success: true, schedule: { permanent: state } };\n}\n\nfunction invalid(err) {\n  return { success: false, error: err };\n}\n\nfunction skip() {\n  return { success: true, schedule: { skip: true } };\n}\n\nmodule.exports = tryParseSchedule;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/scheduling/parseSchedule.js\n// module id = 291\n// module chunks = 0","module.exports = require(\"moment-timezone\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"moment-timezone\"\n// module id = 292\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet util = require('util');\nlet BaseError = require('./BaseError.class');\n\nmodule.exports = function ResourceLockedError(message, innerError) {\n  this.name = this.constructor.name;\n  this.message = message;\n  this.innerError = innerError;\n\n  Error.captureStackTrace(this, this.constructor);\n};\n\nutil.inherits(module.exports, BaseError);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/errors/ResourceLockedError.js\n// module id = 293\n// module chunks = 0","'use strict';\n\nlet Service = require('../models/Service');\nlet _ = require('lodash');\n\nconst DEFAULT_PORT = 0;\n\nconst getPort = (service, colour) => _.get(service, ['Value', `${colour}Port`]);\n\nfunction intOrDefault(maybePort) {\n  let port = Number(maybePort);\n  return Number.isInteger(port) ? port : DEFAULT_PORT;\n}\n\nfunction getServicePortConfig(serviceName) {\n  let portConfig = { blue: DEFAULT_PORT, green: DEFAULT_PORT };\n\n  if (serviceName === undefined || serviceName === '') {\n    return Promise.resolve(portConfig);\n  }\n\n  return Service.getByName(serviceName.trim())\n    .then(service => ({\n      blue: intOrDefault(getPort(service, 'Blue')),\n      green: intOrDefault(getPort(service, 'Green'))\n    }));\n}\n\nmodule.exports = getServicePortConfig;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/queryHandlers/GetServicePortConfig.js\n// module id = 294\n// module chunks = 0","/* Copyright (c) Trainline Limited. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet co = require('co');\nlet DeploymentCommandHandlerLogger = require('./DeploymentCommandHandlerLogger');\nlet DeploymentValidationError = require('../../modules/errors/DeploymentValidationError.class');\nlet launchConfigurationTemplatesProvider = require('../../modules/provisioning/launchConfigurationTemplatesProvider');\nlet configProvider = require('../../modules/provisioning/infrastructureConfigurationProvider');\nlet asgTemplatesProvider = require('../../modules/provisioning/autoScalingTemplatesProvider');\nlet namingConvention = require('../../modules/provisioning/namingConventionProvider');\nlet sender = require('../../modules/sender');\nlet getASG = require('../../queryHandlers/GetAutoScalingGroup');\nlet _ = require('lodash');\nlet ScanAutoScalingGroups = require('../../queryHandlers/ScanAutoScalingGroups');\nlet ScanLaunchConfigurations = require('../../queryHandlers/ScanLaunchConfigurations');\n\nmodule.exports = function GetInfrastructureRequirements(command) {\n  let logger = new DeploymentCommandHandlerLogger(command);\n\n  return co(function* () {\n    let deployment = command.deployment;\n    let environmentName = deployment.environmentName;\n    let serviceName = deployment.serviceName;\n    let accountName = deployment.accountName;\n    let slice = deployment.serviceSlice;\n    let requiredInfra = { asgsToCreate: [], launchConfigsToCreate: [], expectedInstances: 0 };\n\n    logger.info('Reading infrastructure configuration...');\n\n    let configuration = yield configProvider.get(environmentName, serviceName, deployment.serverRoleName);\n    let asgsToCreate = yield getASGsToCreate(logger, configuration, accountName, slice);\n    requiredInfra.expectedInstances = yield getExpectedNumberOfInstances(accountName, configuration, asgsToCreate, slice);\n\n    if (!asgsToCreate.length) return requiredInfra;\n    let launchConfigsToCreate = yield getLaunchConfigsToCreate(logger, configuration, asgsToCreate, accountName);\n\n    // Check launchConfigs are valid\n    launchConfigsToCreate.forEach((template) => {\n      let minVolumeSize = template.image.rootVolumeSize;\n      let osBlockDeviceMapping = _.find(template.devices, d => _.includes(['/dev/sda1', '/dev/xvda'], d.DeviceName));\n      let instanceVolumeSize = osBlockDeviceMapping.Ebs.VolumeSize;\n      if (instanceVolumeSize < minVolumeSize) {\n        throw new DeploymentValidationError(`Cannot create Launch Configuration. The specified OS volume size (${instanceVolumeSize} GB) is not sufficient for image '${template.image.name}' (${minVolumeSize} GB). Please check your deployment map settings.`);\n      }\n    });\n\n    requiredInfra.asgsToCreate = asgsToCreate;\n    requiredInfra.launchConfigsToCreate = launchConfigsToCreate;\n    return requiredInfra;\n  }).catch((error) => {\n    logger.error('An error has occurred while determining the required infrastructure', error);\n    return Promise.reject(error);\n  });\n};\n\nfunction getExpectedNumberOfInstances(accountName, config, slice, asgsToCreate) {\n  return co(function* () {\n    if (asgsToCreate.length) {\n      // ASG does not exist yet, get desired size from server role\n      return config.serverRole.AutoScalingSettings.DesiredCapacity;\n    } else {\n      // ASG exists, read current desired size\n      let autoScalingGroupName = namingConvention.getAutoScalingGroupName(config, slice);\n      return getASG({ accountName, autoScalingGroupName }).then(data => data.DesiredCapacity);\n    }\n  });\n}\n\nfunction getASGsToCreate(logger, configuration, accountName, slice) {\n  return co(function* () {\n    let autoScalingTemplates = yield asgTemplatesProvider.get(configuration, accountName);\n    let autoScalingGroupNames = autoScalingTemplates\n      .map(template => template.autoScalingGroupName)\n      .filter((asgName) => {\n        // Only create ASGs On Demand\n        return slice === 'none' ||                                        // Always create ASG in overwrite mode\n            configuration.serverRole.FleetPerSlice === undefined ||       // Always create ASG if FleetPerSlice not known\n            configuration.serverRole.FleetPerSlice === false ||           // Always create ASG in single ASG mode\n            asgName.endsWith(`-${slice}`);                                // Create ASG if it's the target slice\n      });\n\n    let autoScalingGroupNamesToCreate = yield getASGNamesToCreate(logger, autoScalingGroupNames, accountName);\n    return autoScalingTemplates.filter(template =>\n      autoScalingGroupNamesToCreate.indexOf(template.autoScalingGroupName) >= 0\n    );\n  });\n}\n\nfunction getASGNamesToCreate(logger, autoScalingGroupNames, accountName) {\n  return co(function* () {\n    logger.info(`Following AutoScalingGroups are expected: [${autoScalingGroupNames.join(', ')}]`);\n    let query = {\n      name: 'ScanAutoScalingGroups',\n      accountName,\n      autoScalingGroupNames\n    };\n\n    let autoScalingGroups = yield sender.sendQuery(ScanAutoScalingGroups, { query });\n    let existingASGnames = autoScalingGroups.map(group =>\n      group.AutoScalingGroupName\n    );\n    if (existingASGnames.length) {\n      logger.info(`Following AutoScalingGroups already exist: [${existingASGnames.join(', ')}]`);\n    }\n\n    let missingASGnames = autoScalingGroupNames.filter(name =>\n      existingASGnames.indexOf(name) < 0\n    );\n    if (missingASGnames.length) {\n      logger.info(`Following AutoScalingGroups have to be created: [${missingASGnames.join(', ')}]`);\n    } else {\n      logger.info('No AutoScalingGroup has to be created');\n    }\n\n    return missingASGnames;\n  });\n}\n\nfunction getLaunchConfigsToCreate(logger, configuration, autoScalingTemplates, accountName) {\n  return co(function* () {\n    let launchConfigurationNames = autoScalingTemplates.map(template =>\n      template.launchConfigurationName\n    );\n\n    let launchConfigurationNamesToCreate = yield getLaunchConfigNamesToCreate(\n      logger, launchConfigurationNames, accountName\n    );\n    if (!launchConfigurationNamesToCreate.length) {\n      return [];\n    }\n    let launchConfigurationTemplates = yield launchConfigurationTemplatesProvider.get(\n      configuration, accountName, logger\n    );\n\n    return launchConfigurationTemplates.filter(template =>\n      launchConfigurationNamesToCreate.indexOf(template.launchConfigurationName) >= 0\n    );\n  });\n}\n\nfunction getLaunchConfigNamesToCreate(logger, launchConfigurationNames, accountName) {\n  return co(function* () {\n    logger.info(`Following LaunchConfigurations are expected: [${launchConfigurationNames.join(', ')}]`);\n    let query = {\n      name: 'ScanLaunchConfigurations',\n      accountName,\n      launchConfigurationNames\n    };\n\n    let launchConfigurations = yield sender.sendQuery(ScanLaunchConfigurations, { query });\n    let existingLaunchConfigurationNames = launchConfigurations.map(config =>\n      config.LaunchConfigurationName\n    );\n    if (existingLaunchConfigurationNames.length) {\n      logger.info(`Following LaunchConfigurations already exist: [${existingLaunchConfigurationNames.join(', ')}]`);\n    }\n\n    let missingLaunchConfigurationNames = launchConfigurationNames.filter(name =>\n      existingLaunchConfigurationNames.indexOf(name) < 0\n    );\n    if (missingLaunchConfigurationNames.length) {\n      logger.info(`Following LaunchConfigurations have to be created: [${missingLaunchConfigurationNames.join(', ')}]`);\n    } else {\n      logger.info('No LaunchConfiguration has to be created');\n    }\n\n    return missingLaunchConfigurationNames;\n  });\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/commands/deployments/GetInfrastructureRequirements.js\n// module id = 295\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet assert = require('assert');\nlet co = require('co');\n\nlet namingConventionProvider = require('./namingConventionProvider');\nlet iamInstanceProfileNameProvider = require('./launchConfiguration/iamInstanceProfileNameProvider');\nlet instanceDevicesProvider = require('./launchConfiguration/instanceDevicesProvider');\nlet securityGroupsProvider = require('./launchConfiguration/securityGroupsProvider');\nlet userDataProvider = require('./launchConfiguration/userDataProvider');\nlet keyNameProvider = require('./launchConfiguration/keyNameProvider');\nlet imageProvider = require('./launchConfiguration/imageProvider');\n\nmodule.exports = {\n  get(configuration, accountName, logger) {\n    assert(configuration, 'Expected \\'configuration\\' argument not to be null.');\n    assert(accountName, 'Expected \\'accountName\\' argument not to be null.');\n\n    return co(function* () {\n      let sliceNames = configuration.serverRole.FleetPerSlice ? ['blue', 'green'] : [null];\n\n      let image = yield imageProvider.get(configuration.serverRole.AMI);\n      let keyName = yield keyNameProvider.get(configuration, accountName);\n      let iamInstanceProfile = yield iamInstanceProfileNameProvider.get(configuration, accountName);\n      let securityGroups = yield securityGroupsProvider.getFromConfiguration(configuration, image, accountName, logger);\n      let devices = instanceDevicesProvider.toAWS(configuration.serverRole.Volumes);\n      let detailedMonitoring = isDetailedMonitoringEnabled(configuration);\n      let templates = [];\n\n      for (let index = 0; index < sliceNames.length; index++) {\n        let sliceName = sliceNames[index];\n        let userData = yield userDataProvider.get(configuration, image, sliceName);\n        let launchConfigurationName = namingConventionProvider.getLaunchConfigurationName(\n          configuration, sliceName\n        );\n        let instanceType = configuration.serverRole.InstanceType;\n\n        templates.push({\n          launchConfigurationName,\n          image,\n          instanceType,\n          keyName,\n          detailedMonitoring,\n          iamInstanceProfile,\n          securityGroups,\n          devices,\n          userData\n        });\n      }\n\n      return templates;\n    });\n  }\n};\n\nfunction isDetailedMonitoringEnabled(configuration) {\n  let environmentTypeName = (configuration.environmentTypeName || '').toLowerCase();\n  let detailedMonitoringEnabled = environmentTypeName === 'prod';\n  return detailedMonitoringEnabled;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/provisioning/launchConfigurationTemplatesProvider.js\n// module id = 296\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet assert = require('assert');\nlet ConfigurationError = require('../../errors/ConfigurationError.class');\nlet sender = require('../../sender');\nlet GetInstanceProfile = require('../../../queryHandlers/GetInstanceProfile');\n\nmodule.exports = {\n  get(configuration, accountName) {\n    assert(configuration, 'Expected \"configuration\" argument not to be null');\n    assert(accountName, 'Expected \"accountName\" argument not to be null');\n\n    let customInstanceProfileName = configuration.serverRole.InstanceProfileName;\n    if (customInstanceProfileName) {\n      return getInstanceProfileByName(customInstanceProfileName, accountName)\n        .then(\n          instanceProfile => Promise.resolve(instanceProfile.InstanceProfileName),\n          error => Promise.reject(new ConfigurationError(\n            `An error has occurred verifying \"${customInstanceProfileName}\" instance profile specified in configuration.`,\n            error))\n        );\n    } else {\n      let instanceProfileName = getInstanceProfileNameByConvention(configuration);\n      return getInstanceProfileByName(instanceProfileName, accountName)\n        .then(\n          instanceProfile => Promise.resolve(instanceProfile.InstanceProfileName),\n          error => Promise.reject(new ConfigurationError(\n            `An error has occurred verifying \"${instanceProfileName}\" instance profile defined by convention. ` +\n            'If needed a different one can be specified in configuration.',\n            error))\n        );\n    }\n  }\n};\n\nfunction getInstanceProfileNameByConvention(configuration) {\n  let serverRoleName = configuration.serverRole.ServerRoleName;\n  let clusterName = configuration.cluster.Name;\n  let instanceProfileName = `role${clusterName}${serverRoleName}`;\n\n  return instanceProfileName;\n}\n\nfunction getInstanceProfileByName(instanceProfileName, accountName) {\n  let query = {\n    name: 'GetInstanceProfile',\n    accountName,\n    instanceProfileName\n  };\n\n  return sender.sendQuery(GetInstanceProfile, { query });\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/provisioning/launchConfiguration/iamInstanceProfileNameProvider.js\n// module id = 297\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet assert = require('assert');\nlet namingConventionProvider = require('../namingConventionProvider');\nlet userDataBuilder = require('./UserDataBuilder');\n\nmodule.exports = {\n  get(configuration, image, sliceName) {\n    assert(configuration, 'Expected \\'configuration\\' argument not to be null');\n    assert(image, 'Expected \\'image\\' argument not to be null');\n\n    let userData = image.platform === 'Windows' ?\n      getWindowsUserData(configuration, sliceName) :\n      getLinuxUserData(configuration, sliceName);\n    return userData;\n  }\n};\n\nfunction getLinuxUserData(configuration, sliceName) {\n  let roleName = namingConventionProvider.getRoleName(configuration, sliceName);\n  let parameters = {\n    EnvironmentType: configuration.environmentTypeName,\n    Environment: configuration.environmentName,\n    SecurityZone: configuration.serverRole.SecurityZone,\n    OwningCluster: configuration.cluster.Name,\n    Role: roleName,\n    ContactEmail: configuration.serverRole.ContactEmailTag,\n    ProjectCode: configuration.serverRole.ProjectCodeTag,\n    PuppetRole: configuration.serverRole.PuppetRole\n  };\n\n  return userDataBuilder.buildLinuxUserData(parameters);\n}\n\nfunction getWindowsUserData(configuration, sliceName) {\n  let roleName = namingConventionProvider.getRoleName(configuration, sliceName);\n  let parameters = {\n    EnvironmentType: configuration.environmentTypeName,\n    Environment: configuration.environmentName,\n    SecurityZone: configuration.serverRole.SecurityZone,\n    OwningCluster: configuration.cluster.Name,\n    Role: roleName,\n    ContactEmail: configuration.serverRole.ContactEmailTag,\n    ProjectCode: configuration.serverRole.ProjectCodeTag,\n    RemovalDate: configuration.serverRole.RemovalDateTag,\n    PuppetRole: configuration.serverRole.PuppetRole\n  };\n\n  return userDataBuilder.buildWindowsUserData(parameters);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/provisioning/launchConfiguration/userDataProvider.js\n// module id = 298\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet assert = require('assert');\nlet base64 = require('../../base64');\nlet { createUserData: createLinuxUserData } = require('./userData/linux-user-data');\nlet { createUserData: createWindowsUserData } = require('./userData/windows-user-data');\n\nfunction isNonEmptyString(maybeStr) {\n  return maybeStr !== undefined\n    && maybeStr !== null\n    && typeof maybeStr === 'string'\n    && maybeStr !== '';\n}\n\nfunction mapStr(fn, maybeStr) {\n  return isNonEmptyString(maybeStr)\n    ? fn(maybeStr)\n    : '';\n}\n\nmodule.exports = {\n  buildLinuxUserData(userData) {\n    assert(userData, 'Expected \\'userData\\' argument not to be null');\n    let args = Object.assign({}, userData, { PuppetRole: mapStr(x => `-r ${x}`, userData.PuppetRole) });\n    return Promise.resolve(base64.encode(createLinuxUserData(args)));\n  },\n  buildWindowsUserData(userData) {\n    assert(userData, 'Expected \\'userData\\' argument not to be null');\n    return Promise.resolve(base64.encode(createWindowsUserData(userData)));\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/provisioning/launchConfiguration/UserDataBuilder.js\n// module id = 299\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction createUserData({ ContactEmail, Environment, EnvironmentType, OwningCluster, ProjectCode, PuppetRole, Role, SecurityZone, }) {\n    return `#!/bin/bash -xe\n/etc/puppet/tools/machine_boot -t name=,environmenttype=${EnvironmentType},environment=${Environment},securityzone=${SecurityZone},owningcluster=${OwningCluster},role=${Role},contactemail=${ContactEmail},projectcode=${ProjectCode} ${PuppetRole} > /tmp/machine_boot.log`; // tslint:disable-line max-line-length\n}\nexports.createUserData = createUserData;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/provisioning/launchConfiguration/userData/linux-user-data.ts\n// module id = 300\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction createUserData({ ContactEmail, Environment, EnvironmentType, OwningCluster, ProjectCode, PuppetRole, RemovalDate, Role, SecurityZone, }) {\n    return `<powershell>\nif(test-path \"C:\\TTLApps\\ttl-appbootstrapper\\configure.ps1\"){\n\tPowershell.exe -executionpolicy remotesigned -File C:\\TTLApps\\ttl-appbootstrapper\\configure.ps1\n} else {\n\tPowershell.exe -executionpolicy remotesigned -File C:\\TTLApps\\initial-boot.ps1\n}\n</powershell>\n##Creator:${ContactEmail}\n##Environment:${Environment}\n##Owner:${OwningCluster}\n##Role:${Role}\n##PuppetRole:${PuppetRole}\n##DeploymentMaps:[]\n##OwningCluster:${OwningCluster}\n##EnvironmentType:${EnvironmentType}\n##SecurityZone:${SecurityZone}\n##ContactEmail:${ContactEmail}\n##ProjectCode:${ProjectCode}\n##RemovalDate:${RemovalDate}`;\n}\nexports.createUserData = createUserData;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/provisioning/launchConfiguration/userData/windows-user-data.ts\n// module id = 301\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet assert = require('assert');\nlet sender = require('../../sender');\nlet GetKeyPair = require('../../../queryHandlers/GetKeyPair');\nlet ConfigurationError = require('../../errors/ConfigurationError.class');\n\nmodule.exports = {\n  get(configuration, accountName) {\n    assert(configuration, 'Expected \"configuration\" argument not to be null');\n    assert(accountName, 'Expected \"accountName\" argument not to be null');\n\n    let customKeyName = configuration.serverRole.ClusterKeyName;\n    if (customKeyName) {\n      return getKeyPairByName(customKeyName, accountName)\n        .then(\n          keyPair => Promise.resolve(keyPair.KeyName),\n          error => Promise.reject(new ConfigurationError(\n            `An error has occurred verifying \"${customKeyName}\" key pair specified in configuration.`,\n            error))\n        );\n    } else {\n      let keyName = configuration.cluster.KeyPair;\n      if (keyName === '' || keyName === undefined || keyName === null) {\n        return Promise.reject(\n          new ConfigurationError('Server role EC2 key pair set to cluster EC2 key pair, but this is empty. Please fix your configuration'));\n      }\n\n      return getKeyPairByName(keyName, accountName)\n        .then(\n          keyPair => Promise.resolve(keyPair.KeyName),\n          error => Promise.reject(new ConfigurationError(\n            `An error has occurred verifying \"${keyName}\" key pair defined by convention. ` +\n            'If needed a different one can be specified in configuration.',\n            error))\n        );\n    }\n  }\n};\n\nfunction getKeyPairByName(keyName, accountName) {\n  let query = {\n    name: 'GetKeyPair',\n    accountName,\n    keyName\n  };\n\n  return sender.sendQuery(GetKeyPair, { query });\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/provisioning/launchConfiguration/keyNameProvider.js\n// module id = 302\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet assert = require('assert');\nlet keypairFactory = require('../modules/factories/keypairFactory');\n\nmodule.exports = function GetKeyPairQueryHandler({ accountName, keyName }) {\n  assert(accountName);\n  assert(keyName);\n\n  let parameters = { accountName };\n  return keypairFactory.create(parameters)\n    .then(resource => resource.get({ keyName }));\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/queryHandlers/GetKeyPair.js\n// module id = 303\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nconst amazonClientFactory = require('../amazon-client/childAccountClient');\n\nconst AwsError = require('../errors/AwsError.class');\nconst KeyPairNotFoundError = require('../errors/KeyPairNotFoundError.class');\n\nclass KeyPairResource {\n\n  constructor(client) {\n    this.client = client;\n  }\n\n  get({ keyName }) {\n    let self = this;\n    let request = {\n      KeyNames: [keyName]\n    };\n\n    return self.client.describeKeyPairs(request).promise().then((response) => {\n      if (response.KeyPairs.length) {\n        return response.KeyPairs[0];\n      } else {\n        throw new KeyPairNotFoundError(`Key pair \"${keyName}\" not found.`);\n      }\n    }, (error) => {\n      throw new AwsError(`An error has occurred describing EC2 key pairs: ${error.message}`);\n    });\n  }\n}\n\nmodule.exports = {\n  create: parameters => amazonClientFactory.createEC2Client(parameters.accountName).then(client => new KeyPairResource(client))\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/factories/keypairFactory.js\n// module id = 304\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet util = require('util');\nlet BaseError = require('./BaseError.class');\n\nmodule.exports = function KeyPairNotFoundError(message, innerError) {\n  this.name = this.constructor.name;\n  this.message = message;\n  this.innerError = innerError;\n\n  Error.captureStackTrace(this, this.constructor);\n};\n\nutil.inherits(module.exports, BaseError);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/errors/KeyPairNotFoundError.class.js\n// module id = 305\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet assert = require('assert');\nlet co = require('co');\nlet topicNotificationMappingProvider = require('./autoScaling/topicNotificationMappingProvider');\nlet namingConventionProvider = require('./namingConventionProvider');\nlet subnetsProvider = require('./autoScaling/subnetsProvider');\nlet tagsProvider = require('./autoScaling/tagsProvider');\n\nmodule.exports = {\n  get(configuration, accountName) {\n    assert(configuration, 'Expected \\'configuration\\' argument not to be null.');\n\n    return co(function* () {\n      let sliceNames = configuration.serverRole.FleetPerSlice ? ['blue', 'green'] : [null];\n      let topicNotificationMapping = yield topicNotificationMappingProvider.get(accountName);\n      let subnets = yield subnetsProvider.get(configuration);\n      let templates = [];\n\n      for (let index = 0; index < sliceNames.length; index++) {\n        let sliceName = sliceNames[index];\n\n        let autoScalingGroupName = namingConventionProvider.getAutoScalingGroupName(\n          configuration, sliceName\n        );\n\n        let launchConfigurationName = namingConventionProvider.getLaunchConfigurationName(\n          configuration, sliceName\n        );\n\n        let tags = yield tagsProvider.get(configuration, sliceName);\n\n        templates.push({\n          autoScalingGroupName,\n          launchConfigurationName,\n          size: {\n            min: configuration.serverRole.AutoScalingSettings.MinCapacity,\n            desired: configuration.serverRole.AutoScalingSettings.DesiredCapacity,\n            max: configuration.serverRole.AutoScalingSettings.MaxCapacity\n          },\n          scaling: {\n            terminationDelay: configuration.serverRole.TerminationDelay\n          },\n          subnets,\n          tags,\n          topicNotificationMapping\n        });\n      }\n\n      return templates;\n    });\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/provisioning/autoScalingTemplatesProvider.js\n// module id = 306\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet AutoScalingNotificationType = require('../../../Enums').AutoScalingNotificationType;\nlet sender = require('../../sender');\nlet GetTopic = require('../../../queryHandlers/GetTopic');\n\nconst TopicsToNotify = [\n  'InfraAsgLambdaScale'\n];\n\nmodule.exports = {\n  get(accountName) {\n    let mappings = TopicsToNotify.map(topicName =>\n      getMappingsByTopicName(topicName, accountName)\n    );\n\n    return Promise.all(mappings);\n  }\n};\n\nfunction getMappingsByTopicName(topicName, accountName) {\n  return getTopicByName(topicName, accountName).then((topic) => {\n    let mapping = {\n      topicName,\n      topicArn: topic.TopicArn,\n      notificationTypes: [\n        AutoScalingNotificationType.InstanceLaunch,\n        AutoScalingNotificationType.InstanceLaunchError,\n        AutoScalingNotificationType.InstanceTerminate,\n        AutoScalingNotificationType.InstanceTerminateError\n      ]\n    };\n    return Promise.resolve(mapping);\n  });\n}\n\nfunction getTopicByName(topicName, accountName) {\n  let query = {\n    name: 'GetTopic',\n    accountName,\n    topicName\n  };\n\n  return sender.sendQuery(GetTopic, { query });\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/provisioning/autoScaling/topicNotificationMappingProvider.js\n// module id = 307\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet snsTopicClientFactory = require('../modules/clientFactories/snsTopicClientFactory');\n\nmodule.exports = function GetTopicQueryHandler(query) {\n  return snsTopicClientFactory\n    .create({ accountName: query.accountName })\n    .then(client => client.get({ topicName: query.topicName }));\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/queryHandlers/GetTopic.js\n// module id = 308\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet SNSTopicClient = require('./SNSTopicClient');\n\nmodule.exports = {\n  create(parameters) {\n    return new Promise((resolve) => {\n      let client = new SNSTopicClient(parameters.accountName);\n      resolve(client);\n    });\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/clientFactories/snsTopicClientFactory.js\n// module id = 309\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet co = require('co');\nlet _ = require('lodash');\nlet AwsError = require('../errors/AwsError.class');\nlet TopicNotFoundError = require('../errors/TopicNotFoundError.class');\nlet config = require('../../config');\nlet awsAccounts = require('../awsAccounts');\nlet amazonClientFactory = require('../amazon-client/childAccountClient');\n\nconst AWS_REGION = config.get('EM_AWS_REGION');\n\nmodule.exports = function SNSTopicClient(accountName) {\n  this.get = function (parameters) {\n    return co(function* () {\n      let awsAccount = yield awsAccounts.getByName(accountName);\n      let topicArn = yield getTopicArnByConvention(parameters.topicName, awsAccount);\n      let client = yield amazonClientFactory.createSNSClient(accountName);\n      let topic = yield client.getTopicAttributes({ TopicArn: topicArn }).promise().then(\n        response => Promise.resolve(response.Attributes),\n        error => Promise.reject(error.code === 'NotFound' ?\n          new TopicNotFoundError(`Topic '${parameters.topicName}' not found.`)\n          : new AwsError(error.message))\n      );\n      return topic;\n    });\n  };\n\n  function getTopicArnByConvention(topicName, awsAccount) {\n    let accountNumber = _.padStart(awsAccount.AccountNumber, 12, '0');\n    let topicArn = `arn:aws:sns:${AWS_REGION}:${accountNumber}:${topicName}`;\n    return Promise.resolve(topicArn);\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/clientFactories/SNSTopicClient.js\n// module id = 310\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet util = require('util');\nlet BaseError = require('./BaseError.class');\n\nmodule.exports = function TopicNotFoundError(message, innerError) {\n  this.name = this.constructor.name;\n  this.message = message;\n  this.innerError = innerError;\n\n  Error.captureStackTrace(this, this.constructor);\n};\n\nutil.inherits(module.exports, BaseError);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/errors/TopicNotFoundError.class.js\n// module id = 311\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet assert = require('assert');\nlet namingConventionProvider = require('../namingConventionProvider');\nlet ConfigurationError = require('../../errors/ConfigurationError.class');\n\nmodule.exports = {\n  get(configuration, sliceName) {\n    assert(configuration, 'Expected \\'configuration\\' argument not to be null');\n    let roleName = namingConventionProvider.getRoleName(configuration, sliceName);\n    let legacyTags = {\n      OwningCluster: configuration.cluster.Name,\n      OwningClusterShortName: configuration.cluster.ShortName\n    };\n    let tags = {\n      EnvironmentType: configuration.environmentTypeName,\n      Environment: configuration.environmentName,\n      OwningTeam: configuration.cluster.Name,\n      Role: roleName,\n      SecurityZone: configuration.serverRole.SecurityZone,\n      Schedule: configuration.serverRole.ScheduleTag || '',\n      ContactEmail: configuration.serverRole.ContactEmailTag\n    };\n\n    if (!tags.ContactEmail) {\n      return Promise.reject(new ConfigurationError('Missing \\'ContactEmail\\' tag in configuration.'));\n    }\n\n    return Promise.resolve(Object.assign({}, legacyTags, tags));\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/provisioning/autoScaling/tagsProvider.js\n// module id = 312\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nconst launchConfigurationResourceFactory = require('../modules/resourceFactories/launchConfigurationResourceFactory');\nlet co = require('co');\n\nfunction* handler(query) {\n  // Create an instance of the resource to work with based on the resource\n  // descriptor and AWS account name.\n  let parameters = { accountName: query.accountName };\n  let resource = yield launchConfigurationResourceFactory.create('launchconfig', parameters);\n\n  // Scan resource items\n  return resource.all({ names: query.launchConfigurationNames });\n}\n\nmodule.exports = co.wrap(handler);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/queryHandlers/ScanLaunchConfigurations.js\n// module id = 313\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet co = require('co');\nlet DeploymentCommandHandlerLogger = require('./DeploymentCommandHandlerLogger');\nlet sender = require('../../modules/sender');\nlet consulClient = require('../../modules/consul-client');\nlet serverRoleProvider = require('../../modules/deployment/serverRoleDefinition');\nlet serviceInstallationProvider = require('../../modules/deployment/serviceInstallationDefinition');\nlet serviceDefinitionProvider = require('../../modules/deployment/serviceDefinition');\nlet serviceDeploymentProvider = require('../../modules/deployment/serviceDeploymentDefinition');\nlet deploymentDefinitionProvider = require('../../modules/deployment/deploymentDefinition');\nlet UpdateTargetState = require('../services/UpdateTargetState');\n\nmodule.exports = function PushDeploymentCommandHandler(command) {\n  const logger = new DeploymentCommandHandlerLogger(command);\n  const deployment = command.deployment;\n  const s3Path = command.s3Path;\n  const expectedNodeDeployments = command.expectedNodeDeployments;\n\n  return co(function* () {\n    let consulConfig = yield consulClient.createConfig({ environment: deployment.environmentName });\n    let dataCentre = consulConfig.defaults.dc;\n\n    logger.info(`Updating consul metadata in data centre \"${dataCentre}\"`);\n\n    let serviceDefinition = yield serviceDefinitionProvider.getKeyValue(deployment);\n    let serverRoleDefinition = yield serverRoleProvider.getKeyValue(deployment);\n    let serviceInstallation = yield serviceInstallationProvider.getKeyValue(deployment, s3Path);\n    let deploymentDefinition = yield deploymentDefinitionProvider.getKeyValue(deployment);\n    let serviceDeploymentDefinition = yield serviceDeploymentProvider.getKeyValue(deployment, expectedNodeDeployments);\n\n    yield [\n      updateTargetState(command, serviceDefinition),\n      updateTargetState(command, serverRoleDefinition),\n      updateTargetState(command, serviceInstallation),\n      updateTargetState(command, deploymentDefinition),\n      updateTargetState(command, serviceDeploymentDefinition)\n    ];\n\n    logger.info('Consul metadata has been updated');\n  }).catch((error) => {\n    logger.error('An error has occurred updating consul metadata', error);\n    return Promise.reject(error);\n  });\n};\n\nfunction updateTargetState(command, keyValue, options) {\n  return sender.sendCommand(UpdateTargetState, {\n    command: {\n      name: 'UpdateTargetState',\n      deploymentId: command.deployment.id,\n      environment: command.deployment.environmentName,\n      key: keyValue.key,\n      value: keyValue.value,\n      options\n    },\n    parent: command\n  });\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/commands/deployments/PushDeployment.js\n// module id = 314\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet Enums = require('../../Enums');\n\nfunction getKeyValue(deployment) {\n  let deploymentId = deployment.id;\n  let environmentName = deployment.environmentName;\n  let serviceName = deployment.serviceName;\n  let serviceVersion = deployment.serviceVersion;\n  let serviceSlice = deployment.serviceSlice;\n  let serverRole = deployment.serverRole;\n\n  let key = serviceSlice ?\n    `environments/${environmentName}/roles/${serverRole}/services/${serviceName}/${serviceSlice}` :\n    `environments/${environmentName}/roles/${serverRole}/services/${serviceName}`;\n\n  let serverRoleDefinitionKeyValue = {\n    key,\n    value: {\n      Name: serviceName,\n      Version: serviceVersion,\n      Slice: serviceSlice || 'none',\n      DeploymentId: deploymentId,\n      InstanceIds: [],\n      Action: Enums.ServiceAction.INSTALL\n    }\n  };\n\n  return Promise.resolve(serverRoleDefinitionKeyValue);\n}\n\nmodule.exports = {\n  getKeyValue\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/deployment/serverRoleDefinition.js\n// module id = 315\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nfunction getKeyValue(deployment, s3Path) {\n  let environmentName = deployment.environmentName;\n  let serviceName = deployment.serviceName;\n  let serviceVersion = deployment.serviceVersion;\n\n  let serviceInstallationKeyValue = {\n    key: `environments/${environmentName}/services/${serviceName}/${serviceVersion}/installation`,\n    value: {\n      PackageBucket: s3Path.bucket,\n      PackageKey: s3Path.key,\n      InstallationTimeout: 20 // Todo: Should be read from the service definition\n    }\n  };\n\n  return Promise.resolve(serviceInstallationKeyValue);\n}\n\nmodule.exports = {\n  getKeyValue\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/deployment/serviceInstallationDefinition.js\n// module id = 316\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nfunction getKeyValue(deployment) {\n  let environmentName = deployment.environmentName;\n  let environmentTypeName = deployment.environmentTypeName;\n  let serviceName = deployment.serviceName;\n  let serviceVersion = deployment.serviceVersion;\n  let serviceSlice = deployment.serviceSlice;\n  let clusterName = deployment.clusterName;\n  let serviceId = getServiceId(environmentName, serviceName, serviceSlice);\n  let servicePorts = deployment.servicePortConfig;\n  let serviceDefinitionKeyValue = {\n    key: `environments/${environmentName}/services/${serviceName}/${serviceVersion}/definition`,\n    value: {\n      Service: {\n        Name: serviceId,\n        ID: serviceId,\n        Address: '',\n        Ports: servicePorts,\n        Tags: [\n          `environment_type:${environmentTypeName}`,\n          `environment:${environmentName}`,\n          `owning_cluster:${clusterName}`,\n          `version:${serviceVersion}`\n          // server_role and slice tags are set by Consul deployment agent\n        ]\n      }\n    }\n  };\n\n  return Promise.resolve(serviceDefinitionKeyValue);\n}\n\nfunction getServiceId(environmentName, serviceName, serviceSlice) {\n  return [\n    environmentName,\n    serviceName,\n    serviceSlice !== 'none' ? serviceSlice : null\n  ].filter(segment => !!segment).join('-');\n}\n\nmodule.exports = {\n  getKeyValue\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/deployment/serviceDefinition.js\n// module id = 317\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nfunction getKeyValue(deployment, expectedNodeDeployments) {\n  let environmentName = deployment.environmentName;\n  let serviceName = deployment.serviceName;\n  let serviceVersion = deployment.serviceVersion;\n  let deploymentId = deployment.id;\n\n  let deploymentServiceKeyValue = {\n    key: `deployments/${deploymentId}/service`,\n    value: {\n      Name: serviceName,\n      Version: serviceVersion,\n      ServerRole: deployment.serverRole,\n      Environment: environmentName,\n      Action: 'Install',\n      ExpectedNodeDeployments: expectedNodeDeployments\n    }\n  };\n\n  return Promise.resolve(deploymentServiceKeyValue);\n}\n\nmodule.exports = {\n  getKeyValue\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/deployment/serviceDeploymentDefinition.js\n// module id = 318\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nfunction getKeyValue(deployment) {\n  let deploymentId = deployment.id;\n  let deploymentKeyValue = {\n    key: `deployments/${deploymentId}/overall_status`,\n    value: 'In Progress'\n  };\n\n  return Promise.resolve(deploymentKeyValue);\n}\n\nmodule.exports = {\n  getKeyValue\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/deployment/deploymentDefinition.js\n// module id = 319\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet ajv = require('ajv');\nlet amazonClientFactory = require('../../modules/amazon-client/childAccountClient');\nlet DeploymentCommandHandlerLogger = require('./DeploymentCommandHandlerLogger');\nlet packageMover = require('./packageMover');\n\nconst options = {\n  allErrors: true,\n  format: 'fast'\n};\n\nlet validate = ajv(options).compile(require('./PreparePackageCommand.schema'));\n\nmodule.exports = function PreparePackageCommandHandler(command) {\n  let logger = new DeploymentCommandHandlerLogger(command);\n  let mover = packageMover(logger);\n  return preparePackage(mover, command).catch((error) => {\n    let msg = 'An error has occurred preparing the package';\n    logger.error(msg, error);\n    return Promise.reject(error);\n  });\n};\n\nlet preparePackage = function (mover, command) {\n  if (!validate(command)) {\n    return Promise.reject({ command, errors: validate.errors });\n  }\n\n  let destination = command.destination;\n  let source = command.source;\n  let accountName = command.accountName;\n\n  return amazonClientFactory.createS3Client(accountName)\n    .then(s3 => mover.copyPackage(source.url, destination, s3));\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/commands/deployments/PreparePackage.js\n// module id = 320\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet logger = require('../../modules/logger');\nlet simpleHttp = require('../../modules/simple-http');\nlet s3Url = require('../../modules/amazon-client/s3Url');\n\nfunction PackageMover(deploymentLogger) {\n  this.downloadPackage = function (url) {\n    if (s3Url.parse(url) !== undefined) {\n      deploymentLogger.info(`Downloading package from S3: ${url}`);\n      return Promise.resolve().then(() => {\n        let downloadStream = s3Url.getObject(url);\n        downloadStream.on('error', (e) => {\n          logger.error(e);\n          deploymentLogger.warn(`Download failed: ${e.message}`);\n        });\n        return downloadStream;\n      });\n    } else {\n      deploymentLogger.info(`Downloading package: ${url}`);\n      return simpleHttp.getResponseStream(url)\n        .then((input) => {\n          let headers = input.headers;\n          if (!(/\\/zip$/.test(headers['content-type']))) {\n            return Promise.reject(new Error(`Expected a zip file. ${url}`));\n          } else {\n            return input;\n          }\n        });\n    }\n  };\n\n  this.uploadPackage = function (destination, stream, s3client) {\n    let params = {\n      Bucket: destination.bucket,\n      Key: destination.key,\n      Body: stream\n    };\n\n    let request = s3client.upload(params);\n\n    return request.promise().then(\n      (rsp) => {\n        deploymentLogger.info(`Package uploaded to: ${rsp.Location}`);\n        return Promise.resolve();\n      },\n      (err) => {\n        let message = `Package upload failed: ${err.message}`;\n        deploymentLogger.warn(message);\n        logger.error(err);\n        return Promise.reject(err);\n      });\n  };\n\n  this.copyPackage = function (fromUrl, destination, s3client) {\n    return this.downloadPackage(fromUrl)\n      .then((stream) => {\n        return this.uploadPackage(destination, stream, s3client);\n      });\n  };\n}\n\nmodule.exports = deploymentLogger => new PackageMover(deploymentLogger);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/commands/deployments/packageMover.js\n// module id = 321\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet http = require('http');\nlet https = require('https');\n\nfunction getResponseStream(url) {\n  const isError = response => !(response.statusCode >= 200 && response.statusCode < 300);\n  return new Promise((resolve, reject) => {\n    // select http or https module, depending on reqested url\n    let scheme = url.startsWith('https') ? https : http;\n    const request = scheme.get(url, (response) => {\n      // handle http errors\n      if (isError(response)) {\n        let error = new Error(`HTTP GET ${url} failed with status code ${response.statusCode}: ${response.statusMessage}`);\n        error.statusCode = response.statusCode;\n        error.statusMessage = response.statusMessage;\n        error.url = url;\n        reject(error);\n      }\n      resolve(response);\n    });\n    // handle connection errors of the request\n    request.on('error', err => reject(err));\n  });\n}\n\nmodule.exports = { getResponseStream };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/simple-http.js\n// module id = 322\n// module chunks = 0","'use strict';\n\nmodule.exports = {\n  id: 'http://thetrainline.com/environment-manager/command/PreparePackageCommand-schema#',\n  $schema: 'http://json-schema.org/draft-04/schema#',\n  title: 'PreparePackageCommand',\n  description: 'A command to copy a package from one location in S3 to another',\n  type: 'object',\n  properties: {\n    accountName: {\n      description: 'The name of the account that owns the S3 bucket',\n      type: 'string',\n      minLength: 1,\n      maxLength: 255\n    },\n    destination: { $ref: '#/definitions/s3destination' },\n    source: { $ref: '#/definitions/sourcePackage' }\n  },\n  required: ['accountName', 'destination', 'source'],\n\n  definitions: {\n    sourcePackage: {\n      description: 'Describes a package that can be converted to a CodeDeploy archive',\n      type: 'object',\n      oneOf: [\n        { $ref: '#/definitions/codeDeployRevision' }\n      ]\n    },\n    s3destination: {\n      description: 'Describes an S3 location',\n      type: 'object',\n      properties: {\n        bucket: {\n          description: 'S3 bucket',\n          type: 'string',\n          minLength: 1,\n          maxLength: 255\n        },\n        key: {\n          description: 'S3 key',\n          type: 'string',\n          minLength: 1,\n          maxLength: 1024\n        }\n      },\n      required: ['bucket', 'key']\n    },\n    codeDeployRevision: {\n      description: 'Describes a CodeDeploy revision as a source package',\n      type: 'object',\n      properties: {\n        url: { $ref: '#/definitions/url' }\n      },\n      required: ['url']\n    },\n    semver: {\n      type: 'string',\n      minLength: 1,\n      maxLength: 127,\n      pattern: '^[0-9]+\\.[0-9]+\\.[0-9]+(-.+)?' // TODO: Check redundant escapes in regex (eslint no-useless-escape)\n    },\n    url: {\n      type: 'string',\n      pattern: '^https?://'\n    }\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/commands/deployments/PreparePackageCommand.schema.js\n// module id = 323\n// module chunks = 0","/* Copyright (c) Trainline Limited. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet co = require('co');\nlet DeploymentCommandHandlerLogger = require('./DeploymentCommandHandlerLogger');\nlet sender = require('../../modules/sender');\nlet _ = require('lodash');\nlet CreateLaunchConfiguration = require('./CreateLaunchConfiguration');\nlet CreateAutoScalingGroup = require('./CreateAutoScalingGroup');\n\nmodule.exports = function ProvideInfrastructure(command) {\n  let logger = new DeploymentCommandHandlerLogger(command);\n\n  return co(function* () {\n    let accountName = command.accountName;\n    let asgsToCreate = command.asgsToCreate;\n    let launchConfigsToCreate = command.launchConfigsToCreate;\n\n    logger.info('Creating required infrastructure...');\n    logger.info(`${launchConfigsToCreate.length} launch configs to create`);\n\n    yield launchConfigsToCreate.map(\n      template => provideLaunchConfiguration(template, accountName, command)\n    );\n\n    _.each(launchConfigsToCreate, (template) => {\n      let securityGroupsNames = _.map(template.securityGroups, sg => sg.getName());\n      logger.info(`LaunchConfiguration ${template.launchConfigurationName} Security Groups: ${securityGroupsNames.join(', ')}`);\n    });\n\n    logger.info(`${asgsToCreate.length} ASGs to create`);\n    yield asgsToCreate.map(\n      template => provideAutoScalingGroup(template, accountName, command)\n    );\n  }).catch((error) => {\n    logger.error('An error has occurred providing the expected infrastructure', error);\n    return Promise.reject(error);\n  });\n};\n\nfunction provideLaunchConfiguration(launchConfigurationTemplate, accountName, parentCommand) {\n  let command = {\n    name: 'CreateLaunchConfiguration',\n    accountName,\n    template: launchConfigurationTemplate\n  };\n\n  return sender.sendCommand(CreateLaunchConfiguration, { command, parent: parentCommand }).catch(error => (\n      error.name === 'LaunchConfigurationAlreadyExistsError' ?\n        Promise.resolve() :\n        Promise.reject(error)\n  ));\n}\n\nfunction provideAutoScalingGroup(autoScalingTemplate, accountName, parentCommand) {\n  let command = {\n    name: 'CreateAutoScalingGroup',\n    accountName,\n    template: autoScalingTemplate\n  };\n\n  return sender.sendCommand(CreateAutoScalingGroup, { command, parent: parentCommand }).catch(error => (\n      error.name === 'AutoScalingGroupAlreadyExistsError' ?\n        Promise.resolve() :\n        Promise.reject(error)\n  ));\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/commands/deployments/ProvideInfrastructure.js\n// module id = 324\n// module chunks = 0","'use strict';\n\nlet assert = require('assert');\nlet co = require('co');\nlet DeploymentCommandHandlerLogger = require('./DeploymentCommandHandlerLogger');\nlet _ = require('lodash');\nconst launchConfigurationResourceFactory = require('../../modules/resourceFactories/launchConfigurationResourceFactory');\n\nmodule.exports = function CreateLaunchConfigurationCommandHandler(command) {\n  let logger = new DeploymentCommandHandlerLogger(command);\n\n  assert(command, 'Expected \"command\" argument not to be null.');\n  assert(command.template, 'Expected \"command\" argument to contain \"template\" property not null.');\n  assert(command.accountName, 'Expected \"command\" argument to contain \"accountName\" property not null or empty.');\n\n  return co(function* () {\n    let template = command.template;\n    let accountName = command.accountName;\n    let launchConfigurationName = template.launchConfigurationName;\n\n    logger.info(`Creating [${launchConfigurationName}] LaunchConfiguration...`);\n\n    let launchConfigurationClient = yield launchConfigurationResourceFactory.create(undefined, { accountName });\n\n    let request = getCreateLaunchConfigurationRequest(template);\n    yield launchConfigurationClient.post(request);\n\n    logger.info(`LaunchConfiguration [${launchConfigurationName}] has been created`);\n  });\n};\n\nfunction getCreateLaunchConfigurationRequest(template) {\n  return {\n    LaunchConfigurationName: template.launchConfigurationName,\n    AssociatePublicIpAddress: false,\n    ImageId: template.image.id,\n    InstanceType: template.instanceType,\n    KeyName: template.keyName,\n    InstanceMonitoring: {\n      Enabled: template.detailedMonitoring\n    },\n    IamInstanceProfile: template.iamInstanceProfile,\n    SecurityGroups: _.map(template.securityGroups, 'GroupId'),\n    UserData: template.userData,\n    BlockDeviceMappings: template.devices\n  };\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/commands/deployments/CreateLaunchConfiguration.js\n// module id = 325\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet assert = require('assert');\nlet co = require('co');\nlet DeploymentCommandHandlerLogger = require('./DeploymentCommandHandlerLogger');\nlet autoScalingGroupClientFactory = require('../../modules/resourceFactories/asgResourceFactory');\n\nmodule.exports = function CreateAutoScalingGroupCommandHandler(command) {\n  let logger = new DeploymentCommandHandlerLogger(command);\n\n  assert(command, 'Expected \"command\" argument not to be null.');\n  assert(command.template, 'Expected \"command\" argument to contain \"template\" property not null.');\n  assert(command.accountName, 'Expected \"command\" argument to contain \"accountName\" property not null or empty.');\n\n  return co(function* () {\n    let template = command.template;\n    let accountName = command.accountName;\n    let autoScalingGroupName = template.autoScalingGroupName;\n\n    logger.info(`Creating [${autoScalingGroupName}] AutoScalingGroup...`);\n\n    let autoScalingGroupClient = yield autoScalingGroupClientFactory.create(undefined, {\n      accountName\n    });\n\n    let request = getCreateAutoScalingGroupRequest(template);\n    yield createAutoScalingGroup(logger, autoScalingGroupClient, request);\n\n    logger.info(`AutoScalingGroup [${autoScalingGroupName}] has been created`);\n\n    logger.info(`Configuring [${autoScalingGroupName}] AutoScalingGroup...`);\n    yield attachLifecycleHook(logger, autoScalingGroupClient, template);\n    yield attachNotificationsByTemplate(logger, autoScalingGroupClient, template);\n    logger.info(`AutoScalingGroup [${autoScalingGroupName}] has been configured`);\n  });\n};\n\nfunction attachLifecycleHook(logger, asgClient, template) {\n  if (!template.scaling || !template.scaling.terminationDelay) {\n    return Promise.resolve();\n  }\n\n  let request = {\n    AutoScalingGroupName: template.autoScalingGroupName,\n    LifecycleHookName: '10min-draining',\n    HeartbeatTimeout: template.scaling.terminationDelay * 60,\n    LifecycleTransition: 'autoscaling:EC2_INSTANCE_TERMINATING',\n    DefaultResult: 'CONTINUE'\n  };\n\n  return asgClient.attachLifecycleHook(request);\n}\n\nfunction attachNotificationsByTemplate(logger, autoScalingGroupClient, template) {\n  return co(function* () {\n    let autoScalingGroupName = template.autoScalingGroupName;\n    let requests = getAttachNotificationsRequests(template);\n\n    if (!requests.length) {\n      logger.info(`No [${autoScalingGroupName}] AutoScalingGroup notification has to be attached to any SNS topic`);\n      return;\n    }\n\n    logger.info(`Attaching [${autoScalingGroupName}] AutoScalingGroup notifications to SNS topics...`);\n\n    yield requests.map(request => attachNotifications(autoScalingGroupClient, request));\n\n    logger.info(`All [${autoScalingGroupName}] AutoScalingGroup notifications have been attached to SNS topics`);\n  });\n}\n\n// ----------------------------------------------------------------------------------------------\n// Functions to promisify [autoScalingGroupClient] interface\n\nfunction createAutoScalingGroup(logger, autoScalingGroupClient, request) {\n  return autoScalingGroupClient.post(request);\n}\n\nfunction attachNotifications(autoScalingGroupClient, request) {\n  return autoScalingGroupClient.attachNotifications(request);\n}\n\n// ----------------------------------------------------------------------------------------------\n// Functions to create requests understandable to AWS AutoScaling APIs\n\nfunction getCreateAutoScalingGroupRequest(template) {\n  let request = {\n    AutoScalingGroupName: template.autoScalingGroupName,\n    LaunchConfigurationName: template.launchConfigurationName,\n    MaxSize: template.size.max,\n    MinSize: template.size.min,\n    VPCZoneIdentifier: template.subnets.join(','),\n    DesiredCapacity: template.size.desired,\n    Tags: getAutoScalingGroupTags(template.tags)\n  };\n\n  return request;\n}\n\nfunction getAutoScalingGroupTags(tags) {\n  let autoScalingGroupTags = [];\n  for (let tag in tags) {\n    if ({}.hasOwnProperty.call(tags, tag)) {\n      autoScalingGroupTags.push({\n        Key: tag,\n        Value: tags[tag]\n      });\n    }\n  }\n\n  return autoScalingGroupTags;\n}\n\nfunction getAttachNotificationsRequests(template) {\n  let requests = template.topicNotificationMapping.map((mapping) => {\n    let request = {\n      AutoScalingGroupName: template.autoScalingGroupName,\n      TopicARN: mapping.topicArn,\n      NotificationTypes: mapping.notificationTypes\n    };\n\n    return request;\n  });\n\n  return requests;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/commands/deployments/CreateAutoScalingGroup.js\n// module id = 326\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet config = require('../../../config');\n\nfunction getHealthcheck(req, res) {\n  res.json({ OK: true, Version: config.get('APP_VERSION') });\n}\n\nmodule.exports = {\n  getHealthcheck\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/controllers/diagnostics/diagnosticsController.js\n// module id = 327\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet GetASGState = require('../../../queryHandlers/GetASGState');\nlet ScanServersStatus = require('../../../queryHandlers/ScanServersStatus');\nlet co = require('co');\nlet Environment = require('../../../models/Environment');\nlet OpsEnvironment = require('../../../models/OpsEnvironment');\nlet Promise = require('bluebird');\nlet environmentProtection = require('../../../modules/authorizers/environmentProtection');\nlet opsEnvironment = require('../../../modules/data-access/opsEnvironment');\nlet param = require('../../api-utils/requestParam');\nlet getMetadataForDynamoAudit = require('../../api-utils/requestMetadata').getMetadataForDynamoAudit;\nconst sns = require('../../../modules/sns/EnvironmentManagerEvents');\nlet { when } = require('../../../modules/functional');\nlet { ifNotFound, notFoundMessage } = require('../../api-utils/ifNotFound');\n\nlet environmentNotFound = notFoundMessage('environment');\n\n/**\n * GET /environments\n */\nfunction getEnvironments(req, res, next) {\n  return OpsEnvironment.getAll()\n    .then(list => Promise.map(list, env => env.toAPIOutput()))\n    .then(data => res.json(data))\n    .catch(next);\n}\n\n/**\n * GET /environments/{name}\n */\nfunction getEnvironmentByName(req, res, next) {\n  const environmentName = req.swagger.params.name.value;\n\n  OpsEnvironment.getByName(environmentName)\n    .then(when(env => !env.isNothing(), env => env.toAPIOutput()))\n    .then(ifNotFound(environmentNotFound))\n    .then(send => send(res))\n    .catch(next);\n}\n\n/**\n * GET /environments/{name}/protected\n */\nfunction isEnvironmentProtectedFromAction(req, res) {\n  const environmentName = req.swagger.params.name.value;\n  const action = req.swagger.params.action.value;\n\n  environmentProtection.isActionProtected(environmentName, action)\n    .then(isProtected => res.json({ isProtected }));\n}\n\n/**\n * GET /environments/{name}/deploy-lock\n */\nfunction getDeploymentLock(req, res, next) {\n  let key = {\n    EnvironmentName: param('name', req)\n  };\n  opsEnvironment.get(key)\n    .then(data => ({\n      EnvironmentName: data.EnvironmentName,\n      Value: {\n        DeploymentsLocked: !!data.Value.DeploymentsLocked\n      },\n      Version: data.Audit.Version\n    }))\n    .then(data => res.json(data)).catch(next);\n}\n\n/**\n * PUT /environments/{name}/deploy-lock\n */\nfunction putDeploymentLock(req, res, next) {\n  let environmentName = param('name', req);\n  let key = {\n    EnvironmentName: environmentName\n  };\n  let expectedVersion = param('expected-version', req);\n  let metadata = getMetadataForDynamoAudit(req);\n\n  let input = req.swagger.params.body.value;\n  let isLocked = input.DeploymentsLocked;\n\n  return opsEnvironment.setDeploymentLock({ key, metadata, isLocked }, expectedVersion)\n    .then(data => res.json(data))\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: `/environments/${environmentName}/deploy-lock`,\n          Method: 'PUT'\n        }\n      }),\n      topic: sns.TOPICS.OPERATIONS_CHANGE,\n      attributes: {\n        Environment: environmentName,\n        Action: sns.ACTIONS.PUT,\n        ID: environmentName\n      }\n    }))\n    .catch(next);\n}\n\n/**\n * GET /environments/{name}/maintenance\n */\nfunction getMaintenance(req, res, next) {\n  let key = {\n    EnvironmentName: param('name', req)\n  };\n  opsEnvironment.get(key)\n    .then(data => ({\n      EnvironmentName: data.EnvironmentName,\n      Value: {\n        InMaintenance: !!data.Value.EnvironmentInMaintenance\n      },\n      Version: data.Audit.Version\n    }))\n    .then(data => res.json(data)).catch(next);\n}\n\n/**\n * PUT /environments/{name}/maintenance\n */\nfunction putMaintenance(req, res, next) {\n  let environmentName = param('name', req);\n  let key = {\n    EnvironmentName: environmentName\n  };\n  let expectedVersion = param('expected-version', req);\n  let metadata = getMetadataForDynamoAudit(req);\n\n  let input = req.swagger.params.body.value;\n  let isInMaintenance = input.InMaintenance;\n\n  return opsEnvironment.setMaintenance({ key, metadata, isInMaintenance }, expectedVersion)\n    .then(data => res.json(data))\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: `/environments/${environmentName}/maintenance`,\n          Method: 'PUT'\n        }\n      }),\n      topic: sns.TOPICS.OPERATIONS_CHANGE,\n      attributes: {\n        Environment: environmentName,\n        Action: sns.ACTIONS.PUT,\n        ID: environmentName\n      }\n    }))\n    .catch(next);\n}\n\n/**\n * GET /environments/{name}/servers\n */\nfunction getEnvironmentServers(req, res, next) {\n  const environmentName = req.swagger.params.name.value;\n\n  ScanServersStatus({ environmentName, filter: {} }).then(data => res.json(data)).catch(next);\n}\n\n/**\n * GET /environments/{name}/servers/{asgName}\n */\nfunction getEnvironmentServerByName(req, res, next) {\n  const environmentName = req.swagger.params.name.value;\n  const asgName = req.swagger.params.asgName.value;\n\n  GetASGState({ environmentName, asgName }).then(data => res.json(data)).catch(next);\n}\n\n/**\n * GET /environments/{name}/accountName\n */\nfunction getEnvironmentAccountName(req, res, next) {\n  const environmentName = req.swagger.params.name.value;\n\n  return co(function* () { // eslint-disable-line func-names\n    const accountName = yield (yield Environment.getByName(environmentName)).getAccountName();\n    res.send(accountName);\n  }).catch(next);\n}\n\n/**\n * GET /environments/{name}/schedule\n */\nfunction getEnvironmentSchedule(req, res, next) {\n  let key = {\n    EnvironmentName: param('name', req)\n  };\n  opsEnvironment.get(key)\n    .then(data => ({\n      EnvironmentName: data.EnvironmentName,\n      Value: {\n        ManualScheduleUp: data.Value.ManualScheduleUp,\n        ScheduleAutomatically: data.Value.ScheduleAutomatically,\n        DefaultSchedule: data.Value.DefaultSchedule\n      },\n      Version: data.Audit.Version\n    }))\n    .then(data => res.json(data)).catch(next);\n}\n\n/**\n * PUT /environments/{name}/schedule\n */\nfunction putEnvironmentSchedule(req, res, next) {\n  let environmentName = param('name', req);\n  let key = {\n    EnvironmentName: environmentName\n  };\n  let expectedVersion = param('expected-version', req);\n  let metadata = getMetadataForDynamoAudit(req);\n\n  let schedule = req.swagger.params.body.value;\n\n  return opsEnvironment.setSchedule({ key, metadata, schedule }, expectedVersion)\n    .then(data => res.json(data))\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: `/environments/${environmentName}/schedule`,\n          Method: 'PUT'\n        }\n      }),\n      topic: sns.TOPICS.OPERATIONS_CHANGE,\n      attributes: {\n        Environment: environmentName,\n        Action: sns.ACTIONS.PUT,\n        ID: environmentName\n      }\n    }))\n    .catch(next);\n}\n\n\n/**\n * GET /environments/{name}/schedule-status\n */\nfunction getEnvironmentScheduleStatus(req, res, next) {\n  const environmentName = req.swagger.params.name.value;\n  const at = req.swagger.params.at.value;\n\n  return OpsEnvironment.getByName(environmentName)\n    .then(env => ({ Status: env.getScheduleStatus(at) }))\n    .then(data => res.json(data))\n    .catch(next);\n}\n\nmodule.exports = {\n  getEnvironments,\n  getEnvironmentByName,\n  getEnvironmentAccountName,\n  getEnvironmentServers,\n  getEnvironmentServerByName,\n  getEnvironmentScheduleStatus,\n  putEnvironmentSchedule,\n  getEnvironmentSchedule,\n  isEnvironmentProtectedFromAction,\n  getMaintenance,\n  putMaintenance,\n  getDeploymentLock,\n  putDeploymentLock\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/controllers/environments/environmentsController.js\n// module id = 328\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet getASGState = require('../modules/environment-state/getASGState');\n\nmodule.exports = function GetServerState(query) {\n  return getASGState(query.environmentName, query.asgName);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/queryHandlers/GetASGState.js\n// module id = 329\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet {\n  getAllServices,\n  getService,\n  getServiceHealth,\n  getAllNodes,\n  getNode,\n  getNodeHealth\n} = require('./consulCatalog');\n\nmodule.exports = {\n  getAllServices,\n  getService,\n  getServiceHealth,\n  getAllNodes,\n  getNode,\n  getNodeHealth\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/service-discovery/consul/index.js\n// module id = 330\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet retry = require('retry');\nlet HttpRequestError = require('../../errors/HttpRequestError.class');\nlet consulClient = require('../../consul-client');\nlet logger = require('../../logger');\nlet _ = require('lodash');\nlet assert = require('assert');\n\nfunction getAllServices(environment) {\n  let getServiceList = clientInstance => clientInstance.catalog.service.list();\n  let filterByDeploymentId = list => _.pickBy(list, s => s.some(tag => tag.indexOf('deployment_id:') === 0));\n\n  let promiseFactoryMethod = () =>\n    createConsulClient(environment)\n      .then(getServiceList)\n      .then(filterByDeploymentId)\n      .then(formatServices);\n\n  return executeAction(promiseFactoryMethod);\n}\n\nfunction getService(environment, serviceQuery) {\n  let nodeKey = `${environment}-${serviceQuery}`;\n  return executeConsul(environment, clientInstance => clientInstance.catalog.service.nodes(nodeKey))\n    .then((service) => {\n      if (!service.length) return service;\n      let firstService = service[0];\n      firstService.ServiceTags = unravelTags(firstService.ServiceTags);\n      return firstService;\n    });\n}\n\nfunction getServiceHealth(environment, serviceQuery) {\n  let nodeKey = `${environment}-${serviceQuery}`;\n  return executeConsul(environment, clientInstance => clientInstance.health.service(nodeKey));\n}\n\nfunction getAllNodes(environment) {\n  return executeConsul(environment, clientInstance => clientInstance.catalog.node.list());\n}\n\nfunction getNode(environment, nodeName) {\n  assert(nodeName, 'nodeName is required');\n  return executeConsul(environment, clientInstance => clientInstance.catalog.node.services(nodeName))\n    .then((nodes) => {\n      if (!nodes || !nodes.Services) {\n        return nodes;\n      } else {\n        // Filter out services that were not installed via environment manager\n        nodes.Services = _.filter(nodes.Services,\n          service => service.Tags && service.Tags.find(tag => tag.startsWith('deployment_id')));\n        return nodes;\n      }\n    });\n}\n\nfunction getNodeHealth(environment, nodeName) {\n  assert(nodeName, 'nodeName is required');\n  return executeConsul(environment, clientInstance => clientInstance.health.node(nodeName));\n}\n\nfunction executeConsul(environment, fn) {\n  assert(environment);\n  let promiseFactoryMethod = () => createConsulClient(environment).then(fn);\n  return executeAction(promiseFactoryMethod);\n}\n\nfunction formatServices(services) {\n  return _.mapValues(services, unravelTags);\n}\n\nfunction unravelTags(service) {\n  return service.reduce((val, tag) => {\n    let tagComponents = tag.split(':');\n    val[tagComponents[0]] = tagComponents[1];\n    return val;\n  }, {});\n}\n\nfunction executeAction(promiseFactoryMethod) {\n  let operation = retry.operation({\n    retries: 3,\n    minTimeout: 1000\n  });\n\n  let errorHandler = (reject, error) => {\n    logger.error(error.toString(true));\n    if ((error instanceof HttpRequestError) && operation.retry(error)) reject(error);\n    if (operation.mainError() !== null) {\n      reject(operation.mainError());\n    } else {\n      reject(error.toString(true));\n    }\n  };\n\n  return new Promise((resolve, reject) => {\n    operation.attempt(() => {\n      promiseFactoryMethod().then(resolve).catch(error => errorHandler(reject, error));\n    });\n  });\n}\n\nfunction createConsulClient(environment) {\n  assert(environment);\n  return consulClient.create({ environment, promisify: true });\n}\n\nmodule.exports = {\n  createConsulClient,\n  getAllServices,\n  getService,\n  getServiceHealth,\n  getAllNodes,\n  getNodeHealth,\n  getNode\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/service-discovery/consul/consulCatalog.js\n// module id = 331\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet _ = require('lodash');\nlet Enums = require('../../Enums');\nlet DIFF_STATE = Enums.DIFF_STATE;\nlet DEPLOYMENT_STATUS = Enums.DEPLOYMENT_STATUS;\n\nfunction formatConsulService(service, healthchecks, deploymentId, deploymentStatus, deploymentCause, logUrl) {\n  let instanceServiceHealthChecks = getInstanceServiceHealthChecks(healthchecks, service.ID);\n  return {\n    Name: getSimpleServiceName(service.Service),\n    Version: service.Tags.version,\n    Slice: service.Tags.slice,\n    Cluster: service.Tags.owning_cluster,\n    ServerRole: service.Tags.server_role,\n    DeploymentId: deploymentId,\n    DeploymentStatus: deploymentStatus,\n    DeploymentCause: deploymentCause,\n    LogLink: logUrl,\n    OverallHealth: getInstanceServiceOverallHealth(instanceServiceHealthChecks),\n    HealthChecks: instanceServiceHealthChecks,\n    DiffWithTargetState: null,\n    Issues: { Warnings: [], Errors: [] }\n  };\n}\n\nfunction formatMissingService(targetService, deploymentStatus, logURL) {\n  let missingService = {\n    Name: targetService.Name,\n    Version: targetService.Version,\n    Slice: targetService.Slice,\n    DeploymentId: targetService.DeploymentId,\n    DeploymentStatus: deploymentStatus,\n    Action: targetService.Action,\n    HealthChecks: [],\n    LogLink: logURL,\n    OverallHealth: Enums.HEALTH_STATUS.Missing,\n    DiffWithTargetState: (targetService.Action === Enums.ServiceAction.INSTALL ? DIFF_STATE.Missing : DIFF_STATE.Ignored),\n    Issues: { Warnings: [], Errors: [] }\n  };\n  if (targetService.Action === Enums.ServiceAction.INSTALL) {\n    missingService.Issues.Warnings.push('Service that is in target state is missing');\n  }\n  return missingService;\n}\n\nfunction mapConsulTags(tags) {\n  return _.reduce(tags, (result, tag) => {\n    let firstColon = tag.indexOf(':');\n    let key = tag.substr(0, firstColon);\n    result[key] = tag.substr(firstColon + 1);\n    return result;\n  }, {});\n}\n\nfunction getOverallHealth(checks) {\n  let check = _.find(checks, { CheckID: 'serfHealth' });\n  if (check === undefined) {\n    return Enums.HEALTH_STATUS.NoData;\n  } else if (check.Status === 'passing') {\n    return Enums.HEALTH_STATUS.Healthy;\n  } else {\n    return Enums.HEALTH_STATUS.Error;\n  }\n}\n\nfunction getInstanceServiceOverallHealth(checks) {\n  if (_.every(checks, { Status: 'passing' })) {\n    return Enums.HEALTH_STATUS.Healthy;\n  } else {\n    return Enums.HEALTH_STATUS.Error;\n  }\n}\n\nfunction getInstanceServiceHealthChecks(checks, serviceId) {\n  let filteredChecks = _.filter(checks, { ServiceID: serviceId });\n  return _.map(filteredChecks, check => ({\n    CheckId: check.CheckID,\n    Name: check.Name,\n    Notes: check.Notes,\n    Status: check.Status\n  }));\n}\n\nfunction getInstanceDeploymentStatus(services) {\n  let expectedServices = _.filter(services, service => service.DiffWithTargetState !== DIFF_STATE.Unexpected);\n\n  if (_.some(expectedServices, service =>\n      // If any service deployment is unsuccessful, instance deployment status is also unsuccessful\n    service.DeploymentStatus === DEPLOYMENT_STATUS.Failed)) {\n    return DEPLOYMENT_STATUS.Failed;\n  } else if (_.every(services, { DeploymentStatus: DEPLOYMENT_STATUS.Success })) {\n    return DEPLOYMENT_STATUS.Success;\n  } else {\n    // This should happen if there's no \"Failed\" and at least one \"In Progress\" deployment\n    return DEPLOYMENT_STATUS.InProgress;\n  }\n}\n\nfunction getRunningServicesCount(services) {\n  return _.filter(services, s => s.DiffWithTargetState !== DIFF_STATE.Missing).length;\n}\n\nfunction hasMissingOrUnexpectedServices(services) {\n  return _.filter(services, s => s.DiffWithTargetState === DIFF_STATE.Missing || s.DiffWithTargetState === DIFF_STATE.Unexpected).length > 0;\n}\n\nfunction getSimpleServiceName(name) {\n  return name.split('-')[1] || name;\n}\n\nfunction getServiceAndSlice(obj) {\n  return obj.Name + (obj.Slice !== 'none' ? `-${obj.Slice}` : '');\n}\n\nfunction getLogUrl(deploymentId, accountName, instanceId) {\n  return deploymentId ?\n    `/api/v1/deployments/${deploymentId}/log?account=${accountName}&instance=${instanceId}` :\n    null;\n}\n\nmodule.exports = {\n  mapConsulTags,\n  getOverallHealth,\n  getInstanceServiceOverallHealth,\n  getInstanceServiceHealthChecks,\n  getInstanceDeploymentStatus,\n  getSimpleServiceName,\n  getServiceAndSlice,\n  getLogUrl,\n  formatConsulService,\n  formatMissingService,\n  getRunningServicesCount,\n  hasMissingOrUnexpectedServices\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/environment-state/serviceStateUtils.js\n// module id = 332\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet _ = require('lodash');\nlet co = require('co');\n\nlet Enums = require('../../Enums');\nlet DIFF_STATE = Enums.DIFF_STATE;\nlet logger = require('../logger');\nlet serviceTargets = require('../service-targets');\n\nconst HEALTH_GOOD = Enums.HEALTH_STATUS.Healthy;\nconst HEALTH_BAD = Enums.HEALTH_STATUS.Error;\nconst SERVICE_INSTALL = Enums.ServiceAction.INSTALL;\n\n/**\n * Generate service health info (with checks list and pass / fail)\n */\nfunction getServiceChecksInfo(serviceObjects) {\n  // Get all health checks for all instances of this service\n  let serviceChecks = _.flatMap(serviceObjects, 'HealthChecks');\n  let checksGrouped = _.groupBy(serviceChecks, 'Name');\n  return _.map(checksGrouped, checks =>\n    // If some instances checks failed for a given check, mark as failed\n    // also, don't count in instance into working\n     ({\n       Name: checks[0].Name,\n       Status: _.some(checks, { Status: 'critical' }) ? HEALTH_BAD : HEALTH_GOOD\n     }));\n}\n\nfunction getServiceOverallHealth(healthChecks) {\n  return _.some(healthChecks, { Status: HEALTH_BAD }) ? HEALTH_BAD : HEALTH_GOOD;\n}\n\nfunction checkServiceProperties(svcA, svcB, prop) {\n  if (svcA[prop] !== svcB[prop]) {\n    // TODO: What behaviour/feature do we expect if a service does not match the expected target?\n    logger.warn(`${svcB.Name} ${svcB.Version} ${prop} mismatch:`);\n    logger.warn(` Found: ${svcA[prop]} and ${svcB[prop]}`);\n  }\n}\n\nfunction getServiceAndSlice(obj) {\n  return obj.Name + (obj.Slice !== 'none' ? `-${obj.Slice}` : '');\n}\n\nfunction* getServicesState(environmentName, runtimeServerRoleName, instances) {\n  let targetServiceStates = yield serviceTargets.getAllServiceTargets(environmentName, runtimeServerRoleName);\n  let allServiceObjects = _.flatMap(instances, instance => instance.Services);\n  allServiceObjects = _.compact(allServiceObjects);\n\n  // Find all objects representing particular service for all nodes\n  let instanceServicesGrouped = _.groupBy(allServiceObjects, obj => getServiceAndSlice(obj));\n\n  let servicesList = _.map(instanceServicesGrouped, (serviceObjects) => {\n    let service = _.find(targetServiceStates, targetService => getServiceAndSlice(targetService) === getServiceAndSlice(serviceObjects[0]));\n\n    // That is a service that is not in a target state, but on at least one of instances\n    if (service === undefined) {\n      // Create fake \"target state\" object to generate metadata\n      service = {\n        Name: serviceObjects[0].Name,\n        Version: serviceObjects[0].Version,\n        Slice: serviceObjects[0].Slice,\n        DiffWithTargetState: DIFF_STATE.Unexpected\n      };\n    } else {\n      service.DiffWithTargetState = null;\n\n      // Check instance serviceObjects for inconsistencies with target state\n      _.each(serviceObjects, (obj) => {\n        checkServiceProperties(obj, service, 'Version');\n        checkServiceProperties(obj, service, 'DeploymentId');\n      });\n\n      if (service.Action === 'Ignore') {\n        service.DiffWithTargetState = DIFF_STATE.Ignored;\n      } else {\n        service.DiffWithTargetState = null;\n      }\n    }\n\n    let serviceInstances = _.filter(instances, instance => _.some(instance.Services, { Name: service.Name, Slice: service.Slice }));\n    let presentOnInstancesCount = 0;\n    let serviceObjectsOnInstances = [];\n\n    // Healthy nodes are these where service is present AND service's status is healthy\n    let healthyNodes = _.filter(serviceInstances, (instance) => {\n      let serviceOnInstance = _.find(instance.Services, { Name: service.Name, Slice: service.Slice });\n\n      if (serviceOnInstance !== undefined) {\n        serviceObjectsOnInstances.push(serviceOnInstance);\n        // If at least one instance has state \"Missing\", overall service state will also be \"Missing\"\n        if (serviceOnInstance.DiffWithTargetState === DIFF_STATE.Missing) {\n          service.DiffWithTargetState = DIFF_STATE.Missing;\n        } else {\n          presentOnInstancesCount += 1;\n        }\n        return serviceOnInstance.OverallHealth === 'Healthy';\n      }\n      return false;\n    });\n\n    let serviceHealthChecks = getServiceChecksInfo(serviceObjects);\n    let serviceAction = service.Action || SERVICE_INSTALL;\n\n    let missingOrUnexpectedInstances = _.filter(serviceObjectsOnInstances,\n      s => s.DiffWithTargetState === DIFF_STATE.Missing || s.DiffWithTargetState === DIFF_STATE.Unexpected).length > 0;\n\n    return {\n      Name: service.Name,\n      Version: service.Version,\n      Slice: service.Slice,\n      DiffWithTargetState: service.DiffWithTargetState,\n      DeploymentId: service.DeploymentId,\n      InstancesNames: _.map(serviceInstances, 'Name'),\n      InstancesCount: {\n        Healthy: healthyNodes.length,\n        Present: presentOnInstancesCount,\n        Total: serviceInstances.length\n      },\n      MissingOrUnexpectedInstances: missingOrUnexpectedInstances,\n      OverallHealth: getServiceOverallHealth(serviceHealthChecks, serviceInstances),\n      HealthChecks: serviceHealthChecks,\n      Action: serviceAction\n    };\n  });\n\n  // Look for services that weren't deployed to any of the instances on ASG, but are in target state.\n  _.each(targetServiceStates, (targetService) => {\n    if (_.find(servicesList, { Name: targetService.Name, Slice: targetService.Slice }) === undefined) {\n      let missingService = {\n        Name: targetService.Name,\n        Version: targetService.Version,\n        Slice: targetService.Slice,\n        DiffWithTargetState: (targetService.Action === Enums.ServiceAction.INSTALL ? DIFF_STATE.Missing : DIFF_STATE.Ignored),\n        DeploymentId: targetService.DeploymentId,\n        InstancesNames: [],\n        InstancesCount: {\n          Healthy: 0,\n          Present: 0,\n          Total: 0\n        },\n        HealthChecks: [],\n        OverallHealth: Enums.HEALTH_STATUS.Missing,\n        Action: targetService.Action\n      };\n      servicesList.push(missingService);\n    }\n  });\n\n  return servicesList;\n}\n\nmodule.exports = co.wrap(getServicesState);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/environment-state/getServicesState.js\n// module id = 333\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet _ = require('lodash');\nlet co = require('co');\nconst ec2InstanceResourceFactory = require('../../modules/resourceFactories/ec2InstanceResourceFactory');\n\nfunction* getAWSInstances(accountName, instancesIds) {\n  let resource = yield ec2InstanceResourceFactory.create(undefined, { accountName });\n\n  let filter = {\n    'instance-id': instancesIds\n  };\n\n  let instances = yield resource.all({ filter });\n  return _.map(instances, (instance) => {\n    let ret = {\n      PrivateIpAddress: instance.PrivateIpAddress,\n      InstanceId: instance.InstanceId,\n      InstanceType: instance.InstanceType,\n      AvailabilityZone: instance.Placement.AvailabilityZone,\n      State: _.capitalize(instance.State.Name),\n      ImageId: instance.ImageId,\n      LaunchTime: instance.LaunchTime\n    };\n    instance.Tags.forEach((tag) => {\n      ret[tag.Key] = tag.Value;\n    });\n    return ret;\n  });\n}\n\nmodule.exports = co.wrap(getAWSInstances);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/environment-state/getAWSInstances.js\n// module id = 334\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet _ = require('lodash');\nlet co = require('co');\nlet moment = require('moment');\nlet logger = require('../modules/logger');\nlet sender = require('../modules/sender');\nlet AutoScalingGroup = require('../models/AutoScalingGroup');\nlet Instance = require('../models/Instance');\nlet ScanCrossAccountImages = require('./ScanCrossAccountImages');\nlet GetNode = require('./services/GetNode');\n\nmodule.exports = co.wrap(ScanServersStatusQueryHandler);\n\nfunction* ScanServersStatusQueryHandler(query) {\n  const environmentName = query.environmentName;\n\n  let allStartTime = moment.utc();\n\n  return Promise.all([\n    AutoScalingGroup.getAllByEnvironment(environmentName),\n    Instance.getAllByEnvironment(environmentName),\n    getAllImages()\n  ]).then((results) => {\n    let asgs = results[0];\n    let allInstances = results[1];\n    let allImages = results[2];\n\n    if (query.filter.cluster) {\n      asgs = _.filter(asgs, asg => asg.getTag('OwningCluster') === query.filter.cluster);\n    }\n\n    return Promise.all(asgs.map((asg) => {\n      let instances = asg.Instances.map((asgInstance) => {\n        let instance = _.find(allInstances, { InstanceId: asgInstance.InstanceId });\n\n        if (instance && instance.State.Name !== 'terminated') {\n          let image = getImage(allImages, instance.ImageId);\n          return {\n            instanceId: instance.InstanceId,\n            name: instance.getTag('Name', ''),\n            ami: image,\n            status: asgInstance.HealthStatus\n          };\n        } else {\n          return null;\n        }\n      }).filter(instance => !!instance);\n\n      let instanceCount = instances.length;\n      let status = getStatus(instances, asg.DesiredCapacity);\n      let ami = getAmi(instances);\n\n      return getServicesInstalledOnInstances(environmentName, instances)\n        .then(services => ({\n          Name: asg.AutoScalingGroupName,\n          Role: asg.getRuntimeServerRoleName(),\n          Status: status,\n          Cluster: asg.getTag('OwningCluster', ''),\n          Schedule: asg.getTag('Schedule', ''),\n          IsBeingDeleted: asg.Status === 'Delete in progress',\n          Size: {\n            Current: instanceCount,\n            Desired: asg.DesiredCapacity\n          },\n          Services: services.map(getServiceView(environmentName)),\n          Ami: ami\n        }));\n    })).then((asgResults) => {\n      let filteredAsgs = asgResults.filter(byStatus(query.filter.status));\n      let result = {\n        EnvironmentName: environmentName,\n        Value: filteredAsgs\n      };\n\n      let duration = moment.duration(moment.utc().diff(allStartTime)).asMilliseconds();\n      logger.debug(`server-status-query: Whole query took: ${duration}ms`);\n\n      return result;\n    });\n  });\n}\n\nfunction getServicesInstalledOnInstances(environment, instances) {\n  // eslint-disable-next-line arrow-body-style\n  return Promise.all(instances.map((instance) => {\n    return getConsulServicesForNode(environment, instance.name).then((consulServices) => {\n      let services = sanitizeConsulServices(consulServices);\n      return services;\n    });\n  })).then((services) => {\n    let uniqueServices = _.uniqWith(_.flatten(services), _.isEqual);\n    return uniqueServices;\n  });\n}\n\nfunction getConsulServicesForNode(environment, nodeName) {\n  if (!nodeName) return Promise.resolve({});\n  return sender.sendQuery(GetNode, {\n    query: {\n      name: 'GetNode',\n      environment,\n      nodeName\n    }\n  }).then((consulNode) => {\n    if (!consulNode) return [];\n    return consulNode.Services;\n  }, () => {\n    return [];\n  });\n}\n\nfunction getServiceView(env) {\n  return (service) => {\n    let regExp = new RegExp(`^${env}-`);\n    let nameWithoutPrefix = service.name.replace(regExp, '');\n    let name = nameWithoutPrefix.replace(/(-green|-blue)$/, '');\n\n    return {\n      Name: service.name,\n      FriendlyName: name,\n      Version: service.version,\n      Slice: service.slice\n    };\n  };\n}\n\nfunction getAmi(instances) {\n  if (_.some(instances, i => !i.ami)) return null;\n\n  let amis = instances.map(i => i.ami);\n  let amiNames = _.uniq(amis.map(ami => ami.name));\n\n  if (amiNames.length !== 1) return undefined;\n  let ami = amis[0];\n\n  return {\n    Name: ami.name,\n    Age: ami.DaysBehindLatest,\n    IsLatestStable: ami.isLatestStable\n  };\n}\n\n\nfunction getStatus(instances, desiredCapacity) {\n  if (_.some(instances, instance => instance.status !== 'Healthy')) {\n    return {\n      Status: 'Error',\n      Reason: 'Not all instances are healthy'\n    };\n  }\n\n  if (instances.length < desiredCapacity) {\n    return {\n      Status: 'Warning',\n      Reason: 'The number of instances is lower than desired'\n    };\n  }\n\n  return {\n    Status: 'Healthy'\n  };\n}\n\nfunction sanitizeConsulServices(consulServices) {\n  let keys = _.keys(consulServices);\n\n  return keys.map((key) => {\n    let obj = {\n      name: consulServices[key].Service\n    };\n\n    consulServices[key].Tags.forEach((tag) => {\n      let parts = tag.split(':');\n      obj[parts[0]] = parts[1];\n    });\n\n    return obj;\n  });\n}\n\nfunction getImage(images, imageId) {\n  let foundImages = images.filter(image => image.ImageId === imageId);\n  if (foundImages.length === 0) return null;\n\n  let image = foundImages[0];\n\n  return {\n    name: image.Name,\n    created: image.CreationDate,\n    DaysBehindLatest: image.DaysBehindLatest,\n    isLatestStable: image.IsLatestStable\n  };\n}\n\nfunction byStatus(status) {\n  return function (resource) {\n    if (!status) return true;\n    return resource.Status.toLowerCase() === status.toLowerCase();\n  };\n}\n\nfunction getAllImages() {\n  let startTime = moment.utc();\n\n  return sender.sendQuery(ScanCrossAccountImages, {\n    query: {\n      name: 'ScanCrossAccountImages'\n    }\n  }).then((result) => {\n    let duration = moment.duration(moment.utc().diff(startTime)).asMilliseconds();\n    logger.debug(`server-status-query: AllImagesQuery took ${duration}ms`);\n    return result;\n  });\n}\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/queryHandlers/ScanServersStatus.js\n// module id = 335\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet serviceDiscovery = require('../../modules/service-discovery');\n\nmodule.exports = function GetNode(query) {\n  return serviceDiscovery.getNode(query.environment, query.nodeName);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/queryHandlers/services/GetNode.js\n// module id = 336\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet sender = require('../../../modules/sender');\nlet ScanImages = require('../../../queryHandlers/ScanImages');\nlet ScanCrossAccountImages = require('../../../queryHandlers/ScanCrossAccountImages');\nlet _ = require('lodash');\n\nfunction getImages(req, res, next) {\n  const accountName = req.swagger.params.account.value;\n  const stable = req.swagger.params.stable.value;\n\n  let resultsP;\n  if (accountName === undefined) {\n    let query = {\n      name: 'ScanCrossAccountImages',\n      filter: {}\n    };\n    resultsP = sender.sendQuery(ScanCrossAccountImages, { query });\n  } else {\n    let query = {\n      name: 'ScanImages',\n      accountName,\n      filter: {}\n    };\n    resultsP = sender.sendQuery(ScanImages, { query });\n  }\n\n  return resultsP.then((data) => {\n    if (stable !== undefined) {\n      res.json(_.filter(data, { IsStable: stable }));\n    } else {\n      res.json(data);\n    }\n  }).catch(next);\n}\n\nmodule.exports = {\n  getImages\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/controllers/images/imagesController.js\n// module id = 337\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet co = require('co');\nconst ec2ImageResourceFactory = require('../modules/resourceFactories/ec2ImageResourceFactory');\nlet imageSummary = require('../modules/machineImage/imageSummary');\nlet assert = require('assert');\n\n/**\n * Get all the EC2 images ordered by AMI Type (lexicographical, ascending) then by\n * AMI version (semver, descending).\n */\nfunction* handler(query) {\n  assert(query.accountName);\n  let parameters = { accountName: query.accountName };\n  let resource = yield ec2ImageResourceFactory.create(undefined, parameters);\n\n  let images = yield resource.all({ filter: query.filter });\n  return imageSummary.rank(images.map(imageSummary.summaryOf).sort(imageSummary.compare));\n}\n\nmodule.exports = co.wrap(handler);\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/queryHandlers/ScanImages.js\n// module id = 338\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet _ = require('lodash');\nlet co = require('co');\nlet ScanInstances = require('../../../queryHandlers/ScanInstances');\nlet ScanCrossAccountInstances = require('../../../queryHandlers/ScanCrossAccountInstances');\nlet EnterAutoScalingGroupInstancesToStandby = require('../../../commands/asg/EnterAutoScalingGroupInstancesToStandby');\nlet ExitAutoScalingGroupInstancesFromStandby = require('../../../commands/asg/ExitAutoScalingGroupInstancesFromStandby');\nlet asgips = require('../../../modules/data-access/asgips');\nlet Instance = require('../../../models/Instance');\nlet serviceTargets = require('../../../modules/service-targets');\nlet logger = require('../../../modules/logger');\nlet getInstanceState = require('../../../modules/environment-state/getInstanceState');\nlet Environment = require('../../../models/Environment');\nlet Enums = require('../../../Enums');\nlet ScanInstancesScheduleStatus = require('../../../queryHandlers/ScanInstancesScheduleStatus');\nlet fp = require('lodash/fp');\nlet merge = require('../../../modules/merge');\nconst sns = require('../../../modules/sns/EnvironmentManagerEvents');\n\n/* The tags that should be added to each instance as properties.\n * If the instance already has a property with one of these names\n * its value will be replaced with an array containing the value of\n * the tag and the original value of the property. It will not be\n * overwritten.\n * */\nconst FLATTEN_TAGS = [\n  'aws:autoscaling:groupName',\n  'ContactEmail',\n  'Environment',\n  'EnvironmentType',\n  'Name',\n  'OwningCluster',\n  'OwningClusterShortName',\n  'Role',\n  'Schedule',\n  'SecurityZone'\n];\n\n/**\n * GET /instances\n */\nfunction getInstances(req, res, next) {\n  let accountName = req.swagger.params.account.value;\n  const cluster = req.swagger.params.cluster.value;\n  const environmentName = req.swagger.params.environment.value;\n  const maintenance = req.swagger.params.maintenance.value;\n  const ipAddress = req.swagger.params.ip_address.value;\n  const instanceId = req.swagger.params.instance_id.value;\n  const since = req.swagger.params.since.value;\n  const includeDeploymentsStatus = req.swagger.params.include_deployments_status.value;\n\n  co(function* () {\n    let filter = {};\n\n    if (cluster !== undefined) {\n      filter['tag:OwningCluster'] = cluster;\n    }\n    if (environmentName !== undefined) {\n      filter['tag:Environment'] = environmentName;\n      if (accountName === undefined) {\n        accountName = yield Environment.getAccountNameForEnvironment(environmentName);\n      }\n    }\n    if (maintenance === true) {\n      filter['tag:Maintenance'] = 'true';\n    }\n    if (ipAddress !== undefined) {\n      filter['private-ip-address'] = ipAddress;\n    }\n    if (instanceId !== undefined) {\n      filter['instance-id'] = instanceId;\n    }\n\n    if (_.isEmpty(filter)) {\n      filter = null;\n    }\n\n    let handler = accountName !== undefined ? ScanInstances : ScanCrossAccountInstances;\n    let list = yield handler({ accountName, filter });\n\n    // Note: be wary of performance - this filters instances AFTER fetching all from AWS\n    if (since !== undefined) {\n      let sinceDate = new Date(since);\n      list = _.filter(list, (instance) => {\n        if (instance.CreationTime === undefined) {\n          return true;\n        }\n        return sinceDate.getTime() < new Date(instance.CreationTime).getTime();\n      });\n    }\n\n    if (includeDeploymentsStatus === true) {\n      if (list.length > Enums.DEPLOYMENT_INSTANCES_LIST_MAXIMUM_LENGTH) {\n        throw new Error(`Too many results: ${list.length}. Please refine your search query, ie. choose later since date, or limit query to one environment`);\n      }\n\n      list = yield _.map(list, (instance) => {\n        let instanceEnvironment = instance.getTag('Environment', null);\n        let instanceName = instance.getTag('Name', null);\n        let instanceRoleTag = instance.getTag('Role', null);\n\n        if ([instanceEnvironment, instanceName, instanceRoleTag].some(x => x === null || x === '')) {\n          // This instance won't be returned\n          logger.warn(`One of the tags [Environment, Name, Role] is not set. The EC2 instance will be skipped. ${instance.InstanceId}.`);\n          return false;\n        }\n\n        let tagsToFlatten = fp.flow(\n          fp.map(name => [name, instance.getTag(name, null)]),\n          fp.filter(([, value]) => value !== null && value !== undefined),\n          fp.fromPairs\n        )(FLATTEN_TAGS);\n\n        // If instances were fetched by cross scan, instance.AccountName is available, otherwise, for simple scan use accountName\n        return getInstanceState(\n          instance.AccountName || accountName,\n          instanceEnvironment, instanceName, instance.InstanceId, instanceRoleTag, instance.LaunchTime, null)\n          .then((state) => {\n            return merge(instance, state, tagsToFlatten);\n          }, (error) => {\n            logger.error(error);\n            return false;\n          });\n      });\n\n      // Remove instances without Environment tag\n      list = _.compact(list);\n      list = _.sortBy(list, instance => new Date(instance.LaunchTime)).reverse();\n      res.json(list);\n    } else {\n      res.json(list);\n    }\n  }).catch(next);\n}\n\n/**\n * GET /instances/{id}\n */\nfunction getInstanceById(req, res, next) {\n  const id = req.swagger.params.id.value;\n  Instance.getById(id).then(instance => res.json(instance)).catch(next);\n}\n\n/**\n * PUT /instances/{id}/maintenance\n */\nfunction putInstanceMaintenance(req, res, next) {\n  const id = req.swagger.params.id.value;\n  const body = req.swagger.params.body.value;\n  const enable = body.enable;\n  let name = null;\n\n  co(function* () {\n    let instance = yield Instance.getById(id);\n    const instanceIds = [id];\n    const accountName = instance.AccountName;\n    const autoScalingGroupName = instance.getAutoScalingGroupName();\n    const environmentName = instance.getTag('Environment');\n    name = environmentName;\n\n    /**\n     * Update ASG IPS table\n     */\n    let entry = yield asgips.get(accountName, { AsgName: 'MAINTENANCE_MODE' });\n    let ips = JSON.parse(entry.IPs);\n    if (enable === true) {\n      ips.push(instance.PrivateIpAddress);\n      ips = _.uniq(ips);\n    } else {\n      _.pull(ips, instance.PrivateIpAddress);\n    }\n    yield asgips.put(accountName, { AsgName: 'MAINTENANCE_MODE', IPs: JSON.stringify(ips) });\n\n    /**\n     * Put instance to standby on AWS\n     */\n    let handler = enable ? EnterAutoScalingGroupInstancesToStandby : ExitAutoScalingGroupInstancesFromStandby;\n    try {\n      yield handler({ accountName, autoScalingGroupName, instanceIds });\n    } catch (err) {\n      if (err.message.indexOf('is not in Standby') !== -1 || err.message.indexOf('cannot be exited from standby as its LifecycleState is InService') !== -1) {\n        logger.warn(`ASG ${autoScalingGroupName} instance ${id} is already in desired state for ASG Standby: ${enable}`);\n      } else {\n        throw err;\n      }\n    }\n\n    yield instance.persistTag({ key: 'Maintenance', value: enable.toString() });\n\n    /**\n     * Now switch Maintenance mode (previously done in separate end point)\n     */\n    serviceTargets.setInstanceMaintenanceMode(accountName, instance.PrivateIpAddress, environmentName, enable);\n\n    res.send({ ok: true });\n  })\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: `/instances/${id}/maintenance`,\n          Method: 'PUT'\n        }\n      }),\n      topic: sns.TOPICS.OPERATIONS_CHANGE,\n      attributes: {\n        Action: sns.ACTIONS.PUT,\n        ID: 'id',\n        Environment: name\n      }\n    }))\n    .catch(next);\n}\n\n/**\n * GET /instances/{id}/connect\n */\nfunction connectToInstance(req, res, next) {\n  const id = req.swagger.params.id.value;\n  Instance.getById(id).then((instance) => {\n    res.status(200);\n    res.set({\n      'content-type': 'application/rdp',\n      'content-disposition': `attachment; filename*=UTF-8''${id}.rdp`\n    });\n    res.send(`full address:s:${instance.PrivateIpAddress}`);\n  }).catch(next);\n}\n\n/**\n * GET /instances/schedule-actions\n */\nfunction getScheduleActions(req, res, next) {\n  const accountName = req.swagger.params.account.value;\n  const dateTime = req.swagger.params.date.value;\n\n  let query = {\n    name: 'ScanInstancesScheduleStatus',\n    accountName,\n    dateTime\n  };\n\n  ScanInstancesScheduleStatus(query)\n    .then(actions => res.json(actions))\n    .catch(next);\n}\n\nmodule.exports = {\n  getInstances,\n  getInstanceById,\n  putInstanceMaintenance,\n  connectToInstance,\n  getScheduleActions\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/controllers/instances/instancesController.js\n// module id = 339\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet scanCrossAccount = require('../modules/queryHandlersUtil/scanCrossAccountFn');\nlet ScanInstances = require('./ScanInstances');\n\nmodule.exports = function ScanCrossAccountInstances(query) {\n  return scanCrossAccount(({ AccountNumber }) => { ScanInstances(Object.assign({}, query, { accountName: AccountNumber })); });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/queryHandlers/ScanCrossAccountInstances.js\n// module id = 340\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet assert = require('assert');\nlet co = require('co');\nlet sender = require('../../modules/sender');\nlet autoScalingGroupSizePredictor = require('../../modules/autoScalingGroupSizePredictor');\nlet AutoScalingGroup = require('../../models/AutoScalingGroup');\nlet SetAutoScalingGroupSize = require('./SetAutoScalingGroupSize');\nconst asgResourceFactory = require('../../modules/resourceFactories/asgResourceFactory');\n\nmodule.exports = function EnterAutoScalingGroupInstancesToStandbyCommandHandler(command) {\n  assert(command, 'Expected \"command\" argument not to be null.');\n  assert(command.accountName, 'Expected \"command\" argument to contain \"accountName\" property not null or empty.');\n  assert(command.autoScalingGroupName, 'Expected \"command\" argument to contain \"autoScalingGroupName\" property not null or empty.');\n  assert(command.instanceIds, 'Expected \"command\" argument to contain \"instanceIds\" property not null or empty.');\n\n  return co(function* () {\n    // Send a query to obtain the AutoScalingGroup information.\n    let autoScalingGroup = yield AutoScalingGroup.getByName(command.accountName, command.autoScalingGroupName);\n\n    // Create a resource to work with AutoScalingGroups in the target AWS account.\n    let parameters = { accountName: command.accountName };\n    let asgResource = yield asgResourceFactory.create(undefined, parameters);\n\n    // Predict AutoScalingGroup size after entering instances to standby\n    let expectedSize = yield autoScalingGroupSizePredictor.predictSizeAfterEnteringInstancesToStandby(\n      autoScalingGroup,\n      command.instanceIds);\n\n    // Before entering instances to Standby the AutoScalingGroup minimum size has to be\n    // reduced because the action of \"entering instances to standby\" will automatically\n    // reduce the desired capacity and this cannot be less than the minimum size.\n    yield setAutoScalingGroupSize({ min: expectedSize }, command);\n\n    // Through the resource instance previously created the AutoScalingGroup instances\n    // are entered to standby\n    yield asgResource.enterInstancesToStandby({ name: command.autoScalingGroupName, instanceIds: command.instanceIds });\n\n    // After entering instances to Standby the AutoScalingGroup maximum size should be\n    // reduced as well as the minimum size. This because the AutoScalingGroup minimum,\n    // maximum and desired size are equal by convention.\n    yield setAutoScalingGroupSize({ max: expectedSize }, command);\n\n    return {\n      InstancesEnteredToStandby: command.instanceIds\n    };\n  });\n};\n\nfunction setAutoScalingGroupSize(size, parentCommand) {\n  let command = {\n    name: 'SetAutoScalingGroupSize',\n    accountName: parentCommand.accountName,\n    autoScalingGroupName: parentCommand.autoScalingGroupName,\n    autoScalingGroupMinSize: size.min,\n    autoScalingGroupMaxSize: size.max\n  };\n\n  return sender.sendCommand(SetAutoScalingGroupSize, { command, parent: parentCommand });\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/commands/asg/EnterAutoScalingGroupInstancesToStandby.js\n// module id = 341\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet assert = require('assert');\nconst asgResourceFactory = require('../../modules/resourceFactories/asgResourceFactory');\nlet co = require('co');\nlet sender = require('../../modules/sender');\nlet autoScalingGroupSizePredictor = require('../../modules/autoScalingGroupSizePredictor');\nlet AutoScalingGroup = require('../../models/AutoScalingGroup');\nlet SetAutoScalingGroupSize = require('./SetAutoScalingGroupSize');\n\nmodule.exports = function ExitAutoScalingGroupInstancesFromStandby(command) {\n  assert(command.accountName !== undefined && command.accountName !== null);\n  assert(command.autoScalingGroupName !== undefined && command.autoScalingGroupName !== null);\n  assert(command.instanceIds !== undefined && command.instanceIds !== null);\n\n  return co(function* () {\n    let parameters;\n    let childCommand;\n\n    let autoScalingGroup = yield AutoScalingGroup.getByName(command.accountName, command.autoScalingGroupName);\n\n    // Predict AutoScalingGroup size after exiting instances from standby\n    let expectedSize = yield autoScalingGroupSizePredictor.predictSizeAfterExitingInstancesFromStandby(autoScalingGroup, command.instanceIds);\n\n    // Create a resource to work with AutoScalingGroups in the target AWS account.\n    parameters = { accountName: command.accountName };\n    let asgResource = yield asgResourceFactory.create(undefined, parameters);\n\n    // Before exiting instances from Standby the AutoScalingGroup maximum size has to be\n    // increased because the action of \"exiting instances from standby\" will automatically\n    // increase the desired capacity and this cannot be greater than the maximum size.\n    childCommand = {\n      name: 'SetAutoScalingGroupSize',\n      accountName: command.accountName,\n      autoScalingGroupName: command.autoScalingGroupName,\n      autoScalingGroupMaxSize: expectedSize\n    };\n    yield sender.sendCommand(SetAutoScalingGroupSize, { command: childCommand, parent: command });\n\n    // Through the resource instance previously created the AutoScalingGroup instances\n    // are exited from standby\n    parameters = {\n      name: command.autoScalingGroupName,\n      instanceIds: command.instanceIds\n    };\n    yield asgResource.exitInstancesFromStandby(parameters);\n\n    // After exiting instances from Standby the AutoScalingGroup minimum size should be\n    // increased as well as the maximum size. This because the AutoScalingGroup minimum,\n    // maximum and desired size are equal by convention.\n    childCommand = {\n      name: 'SetAutoScalingGroupSize',\n      accountName: command.accountName,\n      autoScalingGroupName: command.autoScalingGroupName,\n      autoScalingGroupMinSize: expectedSize\n    };\n    yield sender.sendCommand(SetAutoScalingGroupSize, { command: childCommand, parent: command });\n\n    return { InstancesExitedFromStandby: command.instanceIds };\n  });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/commands/asg/ExitAutoScalingGroupInstancesFromStandby.js\n// module id = 342\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\n/* eslint-disable */\n\nlet co = require('co');\nlet _ = require('lodash');\nlet sender = require('../modules/sender');\nlet scheduling = require('../modules/scheduling');\nlet opsEnvironment = require('../modules/data-access/opsEnvironment');\nlet ScanInstances = require('./ScanInstances');\nlet ScanAutoScalingGroups = require('./ScanAutoScalingGroups');\n\nmodule.exports = function ScanInstancesScheduleStatusQueryHandler(query) {\n  return co(function* () { // eslint-disable-line func-names\n    let instances = yield getInstances(query);\n    let dateTime = query.dateTime ? query.dateTime : new Date();\n    return [...scheduledActionsForInstances(instances, dateTime), ...scheduledActionsForASGs(instances, dateTime)];\n  });\n};\n\nfunction getInstances(query) {\n  return Promise.all([getAllInstances(query), getAllEnvironments(query), getAllASGs(query)]).then((data) => {\n    let allInstances = data[0];\n    let environments = buildEnvironmentIndex(data[1]);\n    let asgs = buildASGIndex(data[2]);\n    let instances = [];\n    allInstances.forEach((instance) => {\n      let environmentName = getInstanceTagValue(instance, 'environment');\n      if (environmentName) {\n        instance.Environment = findInIndex(environments, environmentName.toLowerCase());\n      }\n      let asgName = getInstanceTagValue(instance, 'aws:autoscaling:groupName');\n      instance.AutoScalingGroup = findInIndex(asgs, asgName);\n      instances.push(instance);\n    });\n    return instances;\n  });\n}\n\nfunction getAutoScalingGroups(instances){\n  var autoScalingGroups = {};\n  for (var instance in instances) {\n    var currentInstance = instances[instance];\n    if (typeof currentInstance.AutoScalingGroup !== 'undefined') {\n      autoScalingGroups[currentInstance.AutoScalingGroup.AutoScalingGroupName] = currentInstance.AutoScalingGroup;\n    }\n  }\n  return autoScalingGroups;\n}\n\nfunction getStandAloneInstances(instances){\n  var standAloneInstances = [];\n  for (var instance in instances) {\n    var currentInstance = instances[instance];\n    if (typeof currentInstance.AutoScalingGroup === 'undefined') {\n      standAloneInstances.push(currentInstance);\n    }\n  }\n  return standAloneInstances;\n}\n\nfunction scheduledActionsForASGs(instances, dateTime){\n  let actions = [];\n  let autoScalingGroups = getAutoScalingGroups(instances);\n  for(var autoScalingGroupName in autoScalingGroups) {\n    let autoScalingGroup = autoScalingGroups[autoScalingGroupName];\n    let scalingActions = scheduling.actionsForAutoScalingGroup(autoScalingGroup, instances, dateTime);\n    if (scalingActions && scalingActions.length && scalingActions.length > 0)\n      actions = [...actions, ...scalingActions];\n  }\n  return actions;\n}\n\nfunction scheduledActionsForInstances(instances, dateTime) {\n  return getStandAloneInstances(instances).map((instance) => {\n    let action = scheduling.actionForInstance(instance, dateTime);\n    return action;\n  });\n}\n\nfunction buildEnvironmentIndex(environmentData) {\n  let environments = {};\n\n  environmentData.forEach((env) => {\n    let environment = env.Value;\n    environment.Name = env.EnvironmentName.toLowerCase();\n    environments[environment.Name] = environment;\n  });\n\n  return environments;\n}\n\nfunction buildASGIndex(asgData) {\n  let asgs = {};\n\n  asgData.forEach((asg) => {\n    asgs[asg.AutoScalingGroupName] = asg;\n  });\n\n  return asgs;\n}\n\nfunction findInIndex(map, name) {\n  return name ? map[name] : undefined;\n}\n\nfunction getInstanceTagValue(instance, tagName) {\n  let tag = _.first(instance.Tags.filter(t => t.Key.toLowerCase() === tagName.toLowerCase()));\n  return tag ? tag.Value : undefined;\n}\n\nfunction getAllInstances(query) {\n  return sender.sendQuery(ScanInstances, {\n    query: {\n      name: 'ScanInstances',\n      accountName: query.accountName,\n      queryId: query.queryId,\n      username: query.username,\n      timestamp: query.timestamp\n    }\n  });\n}\n\nfunction getAllEnvironments() {\n  return opsEnvironment.scan();\n}\n\nfunction getAllASGs(query) {\n  return sender.sendQuery(ScanAutoScalingGroups, {\n    query: {\n      name: 'ScanAutoScalingGroups',\n      accountName: query.accountName,\n      queryId: query.queryId,\n      username: query.username,\n      timestamp: query.timestamp\n    }\n  });\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/queryHandlers/ScanInstancesScheduleStatus.js\n// module id = 343\n// module chunks = 0","'use strict';\n\n/**\n * Merge the values of each property of the arguments into the corresponding property of the output.\n * The value of each property of the returned object is the array of values of the same property of each argument object.\n * @param {*} objects\n */\n\nfunction merge(...objects) {\n  let result = objects\n    .filter(x => x !== undefined && x !== null)\n    .reduce((acc, nxt) => {\n      if (typeof nxt !== 'object') {\n        throw new Error('Each argument must be an object');\n      }\n      Object.keys(nxt).forEach((key) => {\n        if (acc[key] === undefined) {\n          acc[key] = [nxt[key]];\n        } else {\n          acc[key].unshift(nxt[key]);\n        }\n      });\n      return acc;\n    }, {});\n  Object.keys(result).forEach((key) => {\n    let value = result[key];\n    if (value.length === 1) {\n      result[key] = value[0];\n    }\n  });\n  return result;\n}\n\nmodule.exports = merge;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/merge.js\n// module id = 344\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet sender = require('../../../modules/sender');\nlet ScanNginxUpstreams = require('../../../queryHandlers/ScanNginxUpstreams');\n\n/**\n * GET /load-balancer/{name}\n */\nfunction getLoadBalancer(req, res, next) {\n  const fqdn = req.swagger.params.id.value;\n\n  let query = {\n    name: 'ScanNginxUpstreams',\n    instanceDomainName: fqdn\n  };\n\n  return sender.sendQuery(ScanNginxUpstreams, { query }).then(data => res.json(data)).catch(next);\n}\n\nmodule.exports = {\n  getLoadBalancer\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/controllers/load-balancer/loadBalancerController.js\n// module id = 345\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet co = require('co');\nconst nginxUpstreamsResourceFactory = require('../modules/resourceFactories/nginxUpstreamsResourceFactory');\n\nfunction* handler(query) {\n  // Create an instance of the Nginx resource\n  let resource = yield nginxUpstreamsResourceFactory.create(undefined, {});\n\n  // Scan resource items\n  const params = { instanceDomainName: query.instanceDomainName };\n\n  return resource.all(params);\n}\n\nmodule.exports = co.wrap(handler);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/queryHandlers/ScanNginxUpstreams.js\n// module id = 346\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet url = require('url');\nlet request = require('request');\nlet utils = require('../utilities');\nlet logger = require('../logger');\n\nlet HttpRequestError = require('../errors/HttpRequestError.class');\nlet ResourceNotFoundError = require('../errors/ResourceNotFoundError.class');\n\nfunction NginxUpstreamsResource() {\n  function httpErrorToError(error) {\n    switch (error.code) {\n      case 'ENOTFOUND':\n        return new ResourceNotFoundError(`Hostname \"${error.hostname}\" not found.`);\n      default:\n        return new HttpRequestError(`Remote host: ${error.code}`);\n    }\n  }\n\n  function httpResponseToError(response) {\n    return new HttpRequestError(`Remote host: ${response.statusCode}`);\n  }\n\n  function invalidJsonToError(value) {\n    return new HttpRequestError(`Remote host: Invalid JSON: ${value} - 200`);\n  }\n\n  function isNotNginxUpstreamPeerBackup(nginxUpstreamPeer) {\n    return !nginxUpstreamPeer.backup;\n  }\n\n  function asUpstreamItem(nginxUpstreamPeer) {\n    let upstreamItem = {\n      Server: nginxUpstreamPeer.server,\n      State: nginxUpstreamPeer.state,\n      HealthChecks: nginxUpstreamPeer.health_checks\n    };\n\n    return upstreamItem;\n  }\n\n  this.all = function (parameters) {\n    let uri = url.format({\n      protocol: 'http',\n      hostname: parameters.instanceDomainName,\n      pathname: '/status/upstreams'\n    });\n\n    return new Promise((resolve, reject) => {\n      request(uri, (error, response, body) => {\n        // Error connecting to the host\n        if (error) return reject(httpErrorToError(error));\n\n        // Error response from the host\n        if (response.statusCode !== 200) {\n          logger.error(`Unexpected Nginx Upstream response: ${response.body}`,\n            { body: response.body, statusCode: response.statusCode });\n          return reject(httpResponseToError(response));\n        }\n\n        // Unexpected non JSON body\n        let nginxUpstreams = utils.safeParseJSON(body);\n        if (!nginxUpstreams) return reject(invalidJsonToError(body));\n\n        let upstreams = [];\n\n        for (let upstreamName in nginxUpstreams) {\n          if ({}.hasOwnProperty.call(nginxUpstreams, upstreamName)) {\n            let nginxUpstream = nginxUpstreams[upstreamName];\n            if (!nginxUpstream || !nginxUpstream.peers) return invalidJsonToError(body);\n\n            let upstream = {\n              Name: upstreamName,\n              Hosts: nginxUpstream.peers.filter(isNotNginxUpstreamPeerBackup).map(asUpstreamItem)\n            };\n\n            upstreams.push(upstream);\n          }\n        }\n\n        return resolve(upstreams);\n      });\n    });\n  };\n}\n\nmodule.exports = {\n  canCreate: resourceDescriptor => resourceDescriptor.type.toLowerCase() === 'nginx/upstreams',\n  create: () => Promise.resolve(new NginxUpstreamsResource())\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/resourceFactories/nginxUpstreamsResourceFactory.js\n// module id = 347\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\n/* Defines an Express route handler that accepts a request for a package upload URL for a combination of service, version and (optionally) environment.\n * Responds with a pre-signed S3 PUT URL valid for a fixed time period.\n */\n\n/* eslint-disable import/no-extraneous-dependencies */\nlet environmentExistsRule = require('../../../modules/validate/rule/environmentExists');\nlet log = require('../../../modules/logger'); // eslint-disable import/no-extraneous-dependencies\nlet makeValidationFunction = require('../../../modules/validate');\nlet masterAccountClient = require('../../../modules/amazon-client/masterAccountClient'); // eslint-disable-line import/no-extraneous-dependencies\nlet s3PackageLocator = require('../../../modules/s3PackageLocator');\nlet serviceExistsRule = require('../../../modules/validate/rule/serviceExists');\nlet dynamicResponseCreator = require('./dynamicResponseCreator');\n/* eslint-enable import/no-extraneous-dependencies */\n\nlet config = require('../../../config');\nlet _ = require('lodash/fp');\n\nconst EM_PACKAGE_UPLOAD_TIMEOUT = config.get('EM_PACKAGES_UPLOAD_TIMEOUT') || 600;\n\nlet param = p => _.get(['swagger', 'params', p, 'value']);\n\nfunction s3location(req) {\n  let params = ['service', 'version', 'environment'];\n  let extractParameterNameValuePair = name => [name, param(name)(req)];\n  return _.flow(\n  _.map(extractParameterNameValuePair),\n  _.fromPairs,\n  s3PackageLocator.s3PutLocation)(params);\n}\n\nfunction respondWithPreSignedUrl(request) {\n  let params = _.assign(s3location(request))({\n    Expires: EM_PACKAGE_UPLOAD_TIMEOUT,\n    ContentType: 'application/zip'\n  });\n  return masterAccountClient.createS3Client().then(s3 =>\n    new Promise((resolve) => {\n      s3.getSignedUrl('putObject', params, (err, url) => {\n        if (err) {\n          log.error(`Creation of pre-signed package upload URL failed: ${err.message}\\n${err.stack}`);\n          resolve(response => response.status(500).send());\n        } else {\n          resolve(dynamicResponseCreator(200, url));\n        }\n      });\n    }));\n}\n\nfunction packageDoesNotExist(req) {\n  let params = s3location(req);\n\n  return masterAccountClient.createS3Client()\n  .then(client => client.headObject(params).promise())\n  .then(\n    rsp => ({ title: 'The package already exists.', detail: `${rsp.LastModified}`, status: '409' }),\n    err => (err.statusCode === 404 ? undefined : Promise.reject(err))\n  );\n}\n\nfunction serviceExists(req) {\n  let service = param('service')(req);\n  return serviceExistsRule(service).then(e => Object.assign(e, { status: '422' }));\n}\n\nfunction environmentExists(req) {\n  let environment = param('environment')(req);\n  return environmentExistsRule(environment).then(e => Object.assign(e, { status: '422' }));\n}\n\nfunction respondWithErrors(errors) {\n  // Error format:  http://jsonapi.org/format/#errors\n  let statuses = _.flow(_.map(_.get('status')), _.uniq)(errors);\n  let status = (statuses.length === 1) ? statuses[0] : '422';\n  return response => response.status(status).json({ errors });\n}\n\nfunction validate(validationRules) {\n  let validationOptions = {\n    rules: validationRules,\n    validContinuation: respondWithPreSignedUrl,\n    invalidContinuation: respondWithErrors\n  };\n  return makeValidationFunction(validationOptions);\n}\n\nfunction getPackageUploadUrlByServiceVersion(request, response, next) {\n  validate([packageDoesNotExist, serviceExists])(request).then(send => send(response)).catch(next);\n}\n\nfunction getPackageUploadUrlByServiceVersionEnvironment(request, response, next) {\n  validate([packageDoesNotExist, serviceExists, environmentExists])(request).then(send => send(response)).catch(next);\n}\n\nmodule.exports = {\n  getPackageUploadUrlByServiceVersion,\n  getPackageUploadUrlByServiceVersionEnvironment\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/controllers/package-upload-url/packageUploadUrlController.js\n// module id = 348\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\n/* eslint-disable import/no-extraneous-dependencies */\nlet environmentDatabase = require('../../environmentDatabase');\nlet log = require('../../logger'); // eslint-disable import/no-extraneous-dependencies\n/* eslint-enable import/no-extraneous-dependencies */\n\n/* Returns an error in the format specified at http://jsonapi.org/format/#errors\n * if the service does not exist.\n */\nfunction environmentExists(environment) {\n  return environmentDatabase.getEnvironmentByName(environment).then(\n    () => [],\n    (err) => {\n      log.warn(err);\n      return {\n        title: 'Environment Not Found',\n        detail: `environment name: ${environment}`\n      };\n    });\n}\n\nmodule.exports = environmentExists;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/validate/rule/environmentExists.js\n// module id = 349\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\n/**\n * @typedef {Object} Otions\n * @property {Rule[]} rules - an array of validation functions\n * @property {Function} validContinuation - continuation for the valid case\n * @property {Function} invalidContinuation - continuation for the invalid case\n */\n\n /**\n * @typedef {Function} Rule\n * @param {Any} item - the item to be validated.\n * @returns {Array<Any>} errors - validation errors.\n */\n\nlet _ = require('lodash/fp');\n\n/**\n * Create a validation function.\n * @param {Options} - the validation rules and continuations.\n * @returns {Function} - a function that takes the item to validate as its argument and returns the result of the valid or invalid continuation as appropriate.\n */\nfunction createValidationFunction(options) {\n  let rules = options.rules;\n  let validContinuation = options.validContinuation;\n  let invalidContinuation = options.invalidContinuation;\n  return (argument) => {\n    let errorsPromise = Promise.all(rules.map(rule => Promise.resolve().then(() => rule(argument)))).then(_.flow(_.filter(x => x !== undefined), _.flatten));\n    return errorsPromise.then(errors => (errors.length === 0 ? validContinuation(argument) : invalidContinuation(errors)));\n  };\n}\n\nmodule.exports = createValidationFunction;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/validate/index.js\n// module id = 350\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet log = require('../../logger');\nlet servicesDb = require('../../data-access/services');\n\n/* Returns an error in the format specified at http://jsonapi.org/format/#errors\n * if the service does not exist.\n */\nfunction serviceExists(service) {\n  let serviceNotFound = () => ({\n    title: 'Service Not Found',\n    detail: `service name: ${service}`\n  });\n  return servicesDb.get({ ServiceName: service })\n    .then((rsp => (rsp ? [] : serviceNotFound())),\n    (err) => {\n      log.warn(err);\n      return serviceNotFound();\n    });\n}\n\nmodule.exports = serviceExists;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/validate/rule/serviceExists.js\n// module id = 351\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet serviceDiscovery = require('../../../modules/service-discovery');\nlet getSlices = require('../../../queryHandlers/slices/GetSlicesByService');\nlet ScanInstances = require('../../../queryHandlers/ScanInstances');\nlet toggleSlices = require('../../../commands/slices/ToggleSlicesByService');\nlet serviceHealth = require('../../../modules/environment-state/getServiceHealth');\nlet overallServiceHealth = require('../../../modules/environment-state/getOverallServiceHealth');\nlet metadata = require('../../../commands/utils/metadata');\nlet Environment = require('../../../models/Environment');\nlet sns = require('../../../modules/sns/EnvironmentManagerEvents');\n\nfunction isEmptyResponse(data) {\n  return Array.isArray(data) && data.length === 0;\n}\n\nlet co = require('co');\nlet _ = require('lodash');\n\n/**\n * GET /services\n */\nfunction getServices(req, res, next) {\n  const environment = req.swagger.params.environment.value;\n\n  return serviceDiscovery.getAllServices(environment).then(data => res.json(data)).catch(next);\n}\n\n/**\n * GET /services/{service}/asgs\n */\nfunction getASGsByService(req, res, next) {\n  const environment = req.swagger.params.environment.value;\n  const serviceName = req.swagger.params.service.value;\n  const sliceName = req.swagger.params.slice.value;\n\n  return co(function* () {\n    let slice = sliceName.toLowerCase() !== 'none' ? `-${sliceName}` : '';\n    let service = serviceName + slice;\n\n    let nodes = _.castArray(yield serviceDiscovery.getService(environment, service));\n    let accountName = yield Environment.getAccountNameForEnvironment(environment);\n\n    let asgs = yield nodes.map((node) => {\n      return co(function* () {\n        let filter = {}; filter['tag:Name'] = node.Node;\n        let instance = _.first(yield ScanInstances({ accountName, filter }));\n        return instance ? instance.getTag('aws:autoscaling:groupName') : null;\n      });\n    });\n\n    return _.chain(asgs).compact().uniq().map((asg) => {\n      return { AutoScalingGroupName: asg };\n    }).value();\n  }).then(data => res.json(data)).catch(next);\n}\n\n/**\n * GET /services/{service}\n */\nfunction getServiceById(req, res, next) {\n  const environment = req.swagger.params.environment.value;\n  const serviceName = req.swagger.params.service.value;\n\n  return serviceDiscovery.getService(environment, serviceName)\n    .then(data => (isEmptyResponse(data) ? res.status(404).send(JSON.stringify({ error: 'Service not found.' })) : res.json(data)))\n    .catch(next);\n}\n\n/**\n * GET /services/{service}/health\n */\nfunction getOverallServiceHealth(req, res, next) {\n  const environmentName = req.swagger.params.environment.value;\n  const serviceName = req.swagger.params.service.value;\n\n  return overallServiceHealth({ environmentName, serviceName }).then(data => res.json(data)).catch(next);\n}\n\n/**\n * GET /services/{service}/health/{slice}\n */\nfunction getServiceHealth(req, res, next) {\n  const environmentName = req.swagger.params.environment.value;\n  const serviceName = req.swagger.params.service.value;\n  const slice = req.swagger.params.slice.value;\n\n  return serviceHealth({ environmentName, serviceName, slice }).then(data => res.json(data)).catch(next);\n}\n\n/**\n * GET /services/{service}/slices\n */\nfunction getServiceSlices(req, res, next) {\n  const environmentName = req.swagger.params.environment.value;\n  const serviceName = req.swagger.params.service.value;\n  const active = req.swagger.params.active.value;\n\n  return getSlices({ environmentName, serviceName, active }).then(data => res.json(data)).catch(next);\n}\n/**\n * PUT /services/{service}/toggle\n */\nfunction putServiceSlicesToggle(req, res, next) {\n  const environmentName = req.swagger.params.environment.value;\n  const activeSlice = req.swagger.params.active.value;\n  const serviceName = req.swagger.params.service.value;\n  const user = req.user;\n\n  return toggleSlices(metadata.addMetadata({ environmentName, serviceName, activeSlice, user }))\n    .then(data => res.json(data))\n    .then(() => sns.publish({\n      message: JSON.stringify(\n        {\n          Endpoint: {\n            Url: `/services/${serviceName}/toggle`,\n            Method: 'PUT',\n            Parameters: [\n              {\n                Name: 'service',\n                Type: 'path',\n                Value: serviceName || ''\n              },\n              {\n                Name: 'environment',\n                Type: 'query',\n                Value: environmentName || ''\n              },\n              {\n                Name: 'active',\n                Type: 'query',\n                Value: activeSlice || ''\n              }\n            ]\n          }\n        }),\n      topic: sns.TOPICS.OPERATIONS_CHANGE,\n      attributes: {\n        Action: sns.ACTIONS.PUT,\n        ID: serviceName,\n        Environment: environmentName,\n        ActiveSlice: activeSlice\n      }\n    }))\n    .catch(next);\n}\n\nmodule.exports = {\n  getServices,\n  getServiceById,\n  getServiceHealth,\n  getOverallServiceHealth,\n  getServiceSlices,\n  getASGsByService,\n  putServiceSlicesToggle\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/controllers/services/servicesController.js\n// module id = 352\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet assert = require('assert');\nlet getSlices = require('../../modules/queryHandlersUtil/getSlices');\nlet loadBalancerUpstreams = require('../../modules/data-access/loadBalancerUpstreams');\n\nmodule.exports = function GetSlicesByService(query) {\n  assert.equal(typeof query.environmentName, 'string');\n  assert.equal(typeof query.serviceName, 'string');\n\n  return loadBalancerUpstreams.inEnvironmentWithService(query.environmentName, query.serviceName)\n    .then(upstreams => getSlices.handleQuery(query, upstreams));\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/queryHandlers/slices/GetSlicesByService.js\n// module id = 353\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet assert = require('assert');\nlet toggleSlices = require('../utils/toggleSlices');\nlet UpstreamProvider = toggleSlices.UpstreamProvider;\nlet ToggleUpstreamByServiceVerifier = toggleSlices.ToggleUpstreamByServiceVerifier;\nlet UpstreamToggler = toggleSlices.UpstreamToggler;\nlet orchestrate = toggleSlices.orchestrate;\nlet sender = require('../../modules/sender');\nlet Environment = require('../../models/Environment');\n\nmodule.exports = function ToggleSlicesByService(command) {\n  assert.equal(typeof command.environmentName, 'string');\n  assert.equal(typeof command.serviceName, 'string');\n\n  return Environment.getAccountNameForEnvironment(command.environmentName).then((account) => {\n    command.accountName = account;\n\n    let resourceName = `Upstream for \"${command.serviceName}\" service in \"${command.environmentName}\" environment`;\n    let provider = new UpstreamProvider(sender, command, resourceName);\n    let verifier = new ToggleUpstreamByServiceVerifier(sender, command);\n    let toggler = new UpstreamToggler(sender, command);\n\n    return orchestrate(provider, verifier, toggler);\n  });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/commands/slices/ToggleSlicesByService.js\n// module id = 354\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet util = require('util');\nlet BaseError = require('./BaseError.class');\n\nmodule.exports = function InconsistentSlicesStatusError(message, innerError) {\n  this.name = this.constructor.name;\n  this.message = message;\n  this.innerError = innerError;\n\n  Error.captureStackTrace(this, this.constructor);\n};\n\nutil.inherits(module.exports, BaseError);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/errors/InconsistentSlicesStatusError.class.js\n// module id = 355\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet Promise = require('bluebird');\nlet {\n  assign,\n  flatMap,\n  flatten,\n  isUndefined,\n  map,\n  matches,\n  omitBy,\n  pickBy,\n  reduce,\n  toPairs\n} = require('lodash/fp');\nlet GetServerRoles = require('../../queryHandlers/services/GetServerRoles');\nlet AutoScalingGroup = require('../../models/AutoScalingGroup');\nlet serviceDiscovery = require('../service-discovery');\nlet { createEC2Client } = require('../amazon-client/childAccountClient');\nlet { fullyQualifiedServiceNamesFor } = require('./serverRoleFilters');\nlet {\n  compare,\n  currentState,\n  desiredCountOf,\n  desiredState,\n  desiredTopologyOf,\n  instancesOf,\n  instancesRequestFor,\n  summariseComparison } = require('./healthReporter');\nlet { getAccountNameForEnvironment } = require('../../models/Environment');\n\nfunction getAutoScalingGroups(environmentQualifiedRoleNames) {\n  return Promise.map(environmentQualifiedRoleNames,\n    ({ environment, role }) => AutoScalingGroup.getAllByServerRoleName(environment, role))\n    .then(flatten);\n}\n\nfunction getHealth(fullyQualifiedServiceNames) {\n  return Promise.map(fullyQualifiedServiceNames, (fullyQualifiedServiceName) => {\n    let [environment, service, slice] = fullyQualifiedServiceName.split('-');\n    let sliceQualifiedServiceName = `${service}${slice ? `-${slice}` : ''}`;\n    return serviceDiscovery.getServiceHealth(environment, sliceQualifiedServiceName);\n  }).then(flatten);\n}\n\nfunction getInstances(instanceRequests) {\n  let query = instances => ({\n    Filters: [\n      {\n        Name: 'tag:Name',\n        Values: instances\n      }\n    ]\n  });\n  return Promise.map(toPairs(instanceRequests), ([account, instances]) => {\n    let filters = query(instances);\n    return createEC2Client(account)\n      .then(ec2 => ec2.describeInstances(filters).promise());\n  }).then(flatten);\n}\n\nfunction getDesiredState(filters) {\n  let rolesP = GetServerRoles(filters);\n  let desiredTopologyP = rolesP\n    .then(desiredTopologyOf)\n    .then(pickBy(matches(omitBy(isUndefined)({\n      environment: filters.environmentName,\n      service: filters.serviceName,\n      slice: filters.slice\n    }))));\n  let desiredCountsP = rolesP\n    .then(({ EnvironmentName, Value }) => map(({ Role }) => ({ environment: EnvironmentName, role: Role }))(Value))\n    .then(getAutoScalingGroups)\n    .then(desiredCountOf);\n\n  return Promise.join(desiredTopologyP, desiredCountsP, desiredState);\n}\n\nfunction getCurrentState(filters) {\n  let fullyQualifiedServiceNames = fullyQualifiedServiceNamesFor(filters);\n  let serviceHealthP = getHealth(fullyQualifiedServiceNames);\n  let instancesP = serviceHealthP\n    .then(serviceHealth => instancesRequestFor(getAccountNameForEnvironment, serviceHealth))\n    .then(getInstances)\n    .then(flatMap(instancesOf))\n    .then(reduce(assign, {}));\n\n  return Promise.join(serviceHealthP, instancesP, currentState);\n}\n\nfunction getServiceHealth(filters) {\n  let currentStateP = getCurrentState(filters);\n  let desiredStateP = getDesiredState(filters);\n\n  function compareWithSummary(d, c) {\n    let comparison = compare(d, c);\n    return map(service => assign(summariseComparison(service))(service))(comparison);\n  }\n\n  return Promise.join(desiredStateP, currentStateP, compareWithSummary);\n}\n\nmodule.exports = getServiceHealth;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/environment-state/getServiceHealth.js\n// module id = 356\n// module chunks = 0","'use strict';\n\nlet Promise = require('bluebird');\n\nlet {\n  assign,\n  defaultTo,\n  every,\n  filter,\n  find,\n  flatMap,\n  flow,\n  fromPairs,\n  get,\n  groupBy,\n  omitBy,\n  map,\n  mapValues,\n  max,\n  reduce,\n  size,\n  sumBy,\n  toPairs,\n  uniq\n} = require('lodash/fp');\nlet { valueOfTag } = require('../consulDataStructures');\nlet serviceName = require('../serviceName');\n\nlet valueOfAwsTag = key => flow(get('Tags'), find(tag => tag.Key === key), get('Value'));\n\nfunction desiredTopologyOf(getServerRolesResult) {\n  let environment = getServerRolesResult.EnvironmentName;\n  let fullyQualifiedServiceNameOf = serviceName.format.bind(null, environment);\n  return flow(\n    get('Value'),\n    flatMap(({ Role, Services }) => map(({ Name, Slice }) => ([\n      fullyQualifiedServiceNameOf(Name, Slice),\n      { environment, role: Role, service: Name, slice: Slice }\n    ]))(Services)),\n    groupBy(([fullyQualifiedServiceName]) => fullyQualifiedServiceName),\n    mapValues(reduce((acc, [, { environment: env, role, service, slice }]) => ({\n      environment: env,\n      roles: [...acc.roles, role],\n      service,\n      slice\n    }), { roles: [] }))\n  )(getServerRolesResult);\n}\n\nfunction instancesOf(describeInstancesResult) {\n  let autoScalingGroupOf = valueOfAwsTag('aws:autoscaling:groupName');\n  let nameOf = valueOfAwsTag('Name');\n  let roleOf = valueOfAwsTag('Role');\n  return flow(\n    get('Reservations'),\n    flatMap(get('Instances')),\n    map(instance => [nameOf(instance), { role: roleOf(instance), autoScalingGroup: autoScalingGroupOf(instance) }]),\n    fromPairs\n  )(describeInstancesResult);\n}\n\nfunction instancesRequestFor(getAwsAccountForEnvironment, serviceHealthResults) {\n  let environmentOf = valueOfTag('environment');\n  let getEnvironments = flow(\n    flatMap(({ Service }) => environmentOf(Service)),\n    uniq);\n\n  let getEnvAccountMapper = environments => Promise.map(environments, e => getAwsAccountForEnvironment(e).then(a => [e, a]))\n    .then(flow(fromPairs, envAccountMap => env => envAccountMap[env]));\n\n  let groupByAccount = (accountFor, health) => flow(\n    flatMap(({ Service, Node: { Node } }) =>\n      environmentOf(Service).map(env => [accountFor(env), Node])),\n    groupBy(([key]) => key),\n    mapValues(flow(map(([, value]) => value), uniq))\n  )(health);\n\n  return Promise.resolve(serviceHealthResults)\n    .then(getEnvironments)\n    .then(getEnvAccountMapper)\n    .then(accountFor => groupByAccount(accountFor, serviceHealthResults));\n}\n\nfunction desiredState(desiredTopology, desiredCounts) {\n  let sizeOf = (environment, role) => flow(\n    get([environment, role, 'desiredCount']),\n    defaultTo(0));\n  let environmentOf = fullyQualifiedServiceName => fullyQualifiedServiceName.split('-')[0];\n\n  let rolesWithSize = environmentName => flow(\n    get('roles'),\n    map(role => [role, { desiredCount: sizeOf(environmentName, role)(desiredCounts) }]),\n    fromPairs\n  );\n\n  return flow(\n    toPairs,\n    map(([fullyQualifiedServiceName, value]) => [\n      fullyQualifiedServiceName,\n      assign(value)({ roles: rolesWithSize(environmentOf(fullyQualifiedServiceName))(value) })\n    ]),\n    fromPairs\n  )(desiredTopology);\n}\n\nfunction desiredCountOf(autoScalingGroups) {\n  let environmentOf = valueOfAwsTag('Environment');\n  let roleOf = valueOfAwsTag('Role');\n  return flow(\n    map(autoScalingGroup => ({\n      environment: environmentOf(autoScalingGroup),\n      role: roleOf(autoScalingGroup),\n      desiredCount: get('DesiredCapacity')(autoScalingGroup)\n    })),\n    groupBy(get('environment')),\n    mapValues(flow(\n      groupBy(get('role')),\n      mapValues(flow(\n        sumBy(get('desiredCount')),\n        desiredCount => ({ desiredCount })\n      ))\n    ))\n  )(autoScalingGroups);\n}\n\nfunction currentState(health, instances) {\n  let summarizeHealthChecks = every(({ Status }) => Status === 'passing');\n  let summarizeServiceHealthByRole = (acc, node) => {\n    let add = (left, right) => ({\n      'failing-checks': [...(left['failing-checks'] || []), ...filter(check => check.Status !== 'passing')(right['failing-checks'])],\n      'healthyCount': (left.healthyCount || 0) + right.healthyCount,\n      'unhealthyCount': (left.unhealthyCount || 0) + right.unhealthyCount\n    });\n    let myhealth = {\n      'failing-checks': node.Checks,\n      'healthyCount': node.Healthy ? 1 : 0,\n      'unhealthyCount': node.Healthy ? 0 : 1\n    };\n    if (node.Role) {\n      if (!acc.roles) {\n        acc.roles = {};\n      }\n      acc.roles[node.Role] = add(acc.roles[node.Role] || {}, myhealth);\n    } else {\n      if (!acc.instances) {\n        acc.instances = {};\n      }\n      acc.instances[node.Node] = add(acc.instances[node.Node] || {}, myhealth);\n    }\n    return acc;\n  };\n\n  return flow(\n    map(({ Node: { Node }, Service: { Service }, Checks }) => ({\n      AutoScalingGroup: get([Node, 'autoScalingGroup'])(instances),\n      Checks,\n      Healthy: summarizeHealthChecks(Checks),\n      Node,\n      Role: get([Node, 'role'])(instances),\n      Service\n    })),\n    groupBy(({ Service }) => Service),\n    mapValues(serviceNodes => reduce(summarizeServiceHealthByRole, {})(serviceNodes))\n  )(health);\n}\n\nfunction compare(desired, current) {\n  let flat = flow(\n    toPairs,\n    flatMap(([key, value]) => {\n      let withContext = v => flow(\n        assign({\n          environment: value.environment,\n          service: value.service,\n          slice: value.slice\n        }),\n        assign(v)\n      );\n      let roles = map(([k, v]) => [key, withContext(v)({ role: k })])(toPairs(value.roles));\n      let instances = map(([k, v]) => [key, withContext(v)({ instance: k })])(toPairs(value.instances));\n      return [...roles, ...instances];\n    })\n  );\n\n  let aggregate = query => (left, right) => flow(\n    toPairs,\n    map(([key, fn]) => [key, fn(left[key], right[key])]),\n    fromPairs\n  )(query);\n  let sum = (x, y) => (x || 0) + (y || 0);\n  let cat = (x, y) => [...(x || []), ...(y || [])];\n\n  let states = [...flat(desired), ...flat(current)];\n\n  return flow(\n    groupBy(([key]) => key),\n    mapValues(flow(\n      map(([, value]) => value),\n      values => ({\n        environment: flow(map(get('environment')), max)(values),\n        orphanedInstances: flow(\n          filter(({ instance }) => instance !== undefined),\n          groupBy(({ instance }) => instance),\n          mapValues(reduce(aggregate({ 'failing-checks': cat, 'healthyCount': sum, 'unhealthyCount': sum }), {})),\n          toPairs,\n          map(([k, v]) => assign(v)({ name: k }))\n        )(values),\n        roles: flow(\n          filter(({ role }) => role !== undefined),\n          groupBy(({ role }) => role),\n          mapValues(reduce(aggregate({ 'failing-checks': cat, 'healthyCount': sum, 'desiredCount': sum, 'unhealthyCount': sum }), {})),\n          toPairs,\n          map(([k, v]) => assign(v)({ name: k }))\n        )(values),\n        service: flow(map(get('service')), max)(values),\n        slice: flow(map(get('slice')), max)(values)\n      }),\n      omitBy(x => x === undefined))),\n    toPairs,\n    map(([k, v]) => assign({ name: k })(v))\n  )(states);\n}\n\nfunction summariseComparison(service) {\n  let desiredTotals = flow(\n    get('roles'),\n    reduce(([desiredN, healthyN], { desiredCount, healthyCount }) => [\n      desiredN + desiredCount,\n      healthyN + (desiredCount > 0 ? healthyCount : 0)\n    ], [0, 0])\n  );\n\n  let overCapacity = flow(\n    get('roles'),\n    filter(role => role.desiredCount === 0),\n    reduce((n, { healthyCount, unhealthyCount }) => n + healthyCount + unhealthyCount, 0)\n  );\n\n  let orphaned = flow(\n    get('orphanedInstances'),\n    size\n  );\n\n  let [desiredN, desiredHealthyN] = desiredTotals(service);\n\n  return {\n    desiredCount: desiredN,\n    desiredAndHealthyCount: desiredHealthyN,\n    undesiredCount: overCapacity(service) + orphaned(service)\n  };\n}\n\nmodule.exports = {\n  compare,\n  currentState,\n  desiredState,\n  desiredTopologyOf,\n  desiredCountOf,\n  instancesOf,\n  instancesRequestFor,\n  summariseComparison\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/environment-state/healthReporter.js\n// module id = 357\n// module chunks = 0","'use strict';\n\nlet { defaultTo, flow, get, groupBy, map, mapValues } = require('lodash/fp');\n\nfunction tagsOf(item) {\n  function parseTag(str) {\n    let sepIdx = str.indexOf(':');\n    return [str.slice(0, sepIdx), str.slice(sepIdx + 1)];\n  }\n  return flow(\n    get('Tags'),\n    map(parseTag),\n    groupBy(([key]) => key),\n    mapValues(flow(\n      map(([, value]) => value))))(item);\n}\n\nlet valueOfTag = key => flow(tagsOf, get(key), defaultTo([]));\n\nmodule.exports = {\n  tagsOf,\n  valueOfTag\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/consulDataStructures.js\n// module id = 358\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet _ = require('lodash');\nlet Enums = require('../../Enums');\nlet HEALTH_STATUS = Enums.HEALTH_STATUS;\nlet co = require('co');\nlet GetServerRoles = require('../../queryHandlers/services/GetServerRoles');\nlet getASGState = require('./getASGState');\nlet AutoScalingGroup = require('../../models/AutoScalingGroup');\n\nfunction* getOverallServiceHealth({ environmentName, serviceName }) {\n  let serviceRoles = (yield GetServerRoles({ environmentName })).Value;\n  _.each(serviceRoles, (role) => {\n    role.Services = _.filter(role.Services, { Name: serviceName });\n  });\n\n  // Remove from the list roles that don't contain requested service\n  serviceRoles = _.filter(serviceRoles, role => _.isEmpty(role.Services) === false);\n\n  let list = [];\n  for (let role of serviceRoles) {\n    let autoScalingGroups = yield AutoScalingGroup.getAllByServerRoleName(environmentName, role.Role);\n    let state;\n\n    for (let asg of autoScalingGroups) {\n      try {\n        state = yield getASGState(environmentName, asg.AutoScalingGroupName);\n      } catch (error) {\n        // If AutoScalingGroup is not found (old consul data), don't include it in the results\n        if (error.name === 'AutoScalingGroupNotFoundError') {\n          state = `not found ${asg.AutoScalingGroupName}`;\n          // continue;\n        } else {\n          throw error;\n        }\n      }\n      let instances = _.filter(state.Instances, instance => _.some(instance.Services, { Name: serviceName }));\n      let services = _.filter(state.Services, { Name: serviceName });\n\n      // Filter services on instances info to return only queried service\n      _.each(instances, (instance) => {\n        instance.Services = _.filter(instance.Services, { Name: serviceName });\n      });\n      list.push({\n        AutoScalingGroupName: asg.AutoScalingGroupName,\n        Services: services,\n        Instances: instances\n      });\n    }\n  }\n\n  function aggregateHealth(statusList) {\n    if (_.every(statusList, { OverallHealth: HEALTH_STATUS.Healthy })) {\n      return HEALTH_STATUS.Healthy;\n    } else if (_.some(statusList, { OverallHealth: HEALTH_STATUS.Missing })) {\n      return HEALTH_STATUS.Missing;\n    } else if (_.some(statusList, { OverallHealth: HEALTH_STATUS.Error })) {\n      return HEALTH_STATUS.Error;\n    } else if (_.some(statusList, { OverallHealth: HEALTH_STATUS.Warning })) {\n      return HEALTH_STATUS.Warning;\n    } else {\n      return HEALTH_STATUS.Unknown;\n    }\n  }\n\n  _.each(list, (asg) => {\n    asg.OverallHealth = aggregateHealth(asg.Services);\n  });\n\n  return {\n    OverallHealth: aggregateHealth(list),\n    AutoScalingGroups: list\n  };\n}\n\nmodule.exports = co.wrap(getOverallServiceHealth);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/environment-state/getOverallServiceHealth.js\n// module id = 359\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet GetServerRoles = require('../../../queryHandlers/services/GetServerRoles');\nlet deleteTargetState = require('../../../modules/environment-state/deleteTargetState');\nconst { toggleServiceStatus } = require('../../../modules/toggleServiceStatus');\nconst sns = require('../../../modules/sns/EnvironmentManagerEvents');\n\n/**\n * GET /target-state/{environment}\n */\nfunction getTargetState(req, res, next) {\n  const environmentName = req.swagger.params.environment.value;\n\n  GetServerRoles({ environmentName }).then(data => res.json(data)).catch(next);\n}\n\n/**\n * DELETE /target-state/{environment}\n */\nfunction deleteTargetStateByEnvironment(req, res, next) {\n  const environmentName = req.swagger.params.environment.value;\n\n  deleteTargetState.byEnvironment({ environmentName })\n    .then(data => res.json(data))\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: `/target-state/${environmentName}`,\n          Method: 'DELETE'\n        }\n      }),\n      topic: sns.TOPICS.OPERATIONS_CHANGE,\n      attributes: {\n        Action: sns.ACTIONS.DELETE,\n        ID: environmentName,\n        Environment: environmentName\n      }\n    }))\n    .catch(next);\n}\n\n/**\n * DELETE /target-state/{environment}/{service}\n */\nfunction deleteTargetStateByService(req, res, next) {\n  const environmentName = req.swagger.params.environment.value;\n  const serviceName = req.swagger.params.service.value;\n\n  deleteTargetState.byService({ environmentName, serviceName })\n    .then(data => res.json(data))\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: `/target-state/${environmentName}/${serviceName}`,\n          Method: 'DELETE'\n        }\n      }),\n      topic: sns.TOPICS.OPERATIONS_CHANGE,\n      attributes: {\n        Action: sns.ACTIONS.DELETE,\n        ID: `${environmentName}/${serviceName}`,\n        Environment: environmentName\n      }\n    }))\n    .catch(next);\n}\n\n/**\n * DELETE /target-state/{environment}/{service}/{version}\n */\nfunction deleteTargetStateByServiceVersion(req, res, next) {\n  const environmentName = req.swagger.params.environment.value;\n  const serviceName = req.swagger.params.service.value;\n  const serviceVersion = req.swagger.params.version.value;\n\n  deleteTargetState.byServiceVersion({ environmentName, serviceName, serviceVersion })\n    .then(data => res.json(data))\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: `/target-state/${environmentName}/${serviceName}/${serviceVersion}`,\n          Method: 'DELETE'\n        }\n      }),\n      topic: sns.TOPICS.OPERATIONS_CHANGE,\n      attributes: {\n        Action: sns.ACTIONS.DELETE,\n        Environment: environmentName,\n        ID: `${environmentName}/${serviceName}/${serviceVersion}`\n      }\n    }))\n    .catch(next);\n}\n\n/**\n * PUT /target-state/{environment}/{service}/toggle-status\n */\nfunction toggleServiceStatusHandler(req, res, next) {\n  const environment = req.swagger.params.environment.value;\n  const service = req.swagger.params.service.value;\n  const body = req.swagger.params.body.value;\n  const enable = body.Enable;\n  const slice = body.Slice;\n  const serverRole = body.ServerRole;\n  const user = req.user;\n\n  toggleServiceStatus({ environment, service, slice, enable, serverRole, user })\n    .then((data) => { res.json(data); })\n    .catch(next);\n}\n\nmodule.exports = {\n  getTargetState,\n  deleteTargetStateByEnvironment,\n  deleteTargetStateByService,\n  deleteTargetStateByServiceVersion,\n  toggleServiceStatusHandler\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/controllers/target-state/targetStateController.js\n// module id = 360\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet co = require('co');\nlet assert = require('assert');\nlet serviceTargets = require('../service-targets');\n\nfunction scanAndDelete({ environmentName, keyPrefix, condition }) {\n  return co(function* () {\n    let keyValuePairs = yield serviceTargets.getTargetState(environmentName, { key: keyPrefix, recurse: true });\n    let erasedKeys = yield keyValuePairs.filter(keyValuePair =>\n      condition(keyValuePair.key, keyValuePair.value)\n    ).map((keyValuePair) => {\n      return serviceTargets.removeTargetState(environmentName, { key: keyValuePair.key }).then(() => keyValuePair.key);\n    });\n\n    return erasedKeys;\n  });\n}\n\nfunction byEnvironment({ environmentName }) {\n  assert(environmentName);\n  return co(function* () {\n    let erasedServicesKeys = yield scanAndDelete({\n      environmentName,\n      keyPrefix: `environments/${environmentName}/services/`,\n      condition: () => true\n    });\n\n    let erasedRolesKeys = yield scanAndDelete({\n      environmentName,\n      keyPrefix: `environments/${environmentName}/roles/`,\n      condition: () => true\n    });\n\n    return erasedServicesKeys.concat(erasedRolesKeys);\n  });\n}\n\nfunction byService({ environmentName, serviceName }) {\n  assert(environmentName);\n  assert(serviceName);\n  return co(function* () {\n    let erasedServicesKeys = yield scanAndDelete({\n      environmentName,\n      keyPrefix: `environments/${environmentName}/services/${serviceName}/`,\n      condition: () => true\n    });\n\n    let erasedRolesKeys = yield scanAndDelete({\n      environmentName,\n      keyPrefix: `environments/${environmentName}/roles/`,\n      condition: key =>\n        key.match(`environments\\/.*\\/roles\\/.*\\/services\\/${serviceName}\\/`)\n    });\n\n    return erasedServicesKeys.concat(erasedRolesKeys);\n  });\n}\n\nfunction byServiceVersion({ environmentName, serviceName, serviceVersion }) {\n  assert(environmentName);\n  assert(serviceName);\n  assert(serviceVersion);\n  return co(function* () {\n    let erasedServicesKeys = yield scanAndDelete({\n      environmentName,\n      keyPrefix: `environments/${environmentName}/services/${serviceName}/${serviceVersion}/`,\n      condition: () => true\n    });\n\n    let erasedRolesKeys = yield scanAndDelete({\n      environmentName,\n      keyPrefix: `environments/${environmentName}/roles/`,\n      condition: (key, value) => {\n        return value ? value.Name === serviceName && value.Version === serviceVersion : false;\n      }\n    });\n\n    return erasedServicesKeys.concat(erasedRolesKeys);\n  });\n}\n\nmodule.exports = {\n  byEnvironment,\n  byService,\n  byServiceVersion\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/environment-state/deleteTargetState.js\n// module id = 361\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet userService = require('../../../modules/user-service');\nlet tokenConfiguration = require('../../../modules/authentications/tokenAuthenticationConfiguration');\nlet cookieConfiguration = require('../../../modules/authentications/cookieAuthenticationConfiguration');\n\n/**\n * POST /token\n */\nfunction postAuthorization(req, res, next) {\n  let body = req.swagger.params.body.value;\n  let credentials = {\n    username: body.username,\n    password: body.password,\n    scope: 'api'\n  };\n\n  let duration = tokenConfiguration.getTokenDuration();\n\n  userService.authenticateUser(credentials, duration)\n    .then(value => res.send(value)).catch(next);\n}\n\n/**\n * DELETE /token\n */\nfunction signOut(req, res, next) {\n  let token = getToken(req);\n\n  if (!token) {\n    res.status(400).end();\n  } else {\n    userService.signOut(token)\n      .then(() => res.status(200).end()).catch(next);\n  }\n}\n\nfunction getToken(req) {\n  let cookie = req.cookies[cookieConfiguration.getCookieName()];\n  if (cookie) return cookie;\n\n  let authorization = req.headers.authorization;\n  if (!authorization) return null;\n\n  let match = /bearer\\s+(.*)/i.exec(authorization);\n  if (!match) return null;\n\n  return match[1];\n}\n\nmodule.exports = {\n  postAuthorization,\n  signOut\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/controllers/token/tokenController.js\n// module id = 362\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet assert = require('assert');\nlet config = require('../../config');\n\nfunction loadConfiguration() {\n  let localConfig = config.getUserValue('local');\n\n  assert(localConfig.authentication, 'missing \\'authentication\\' field in configuration');\n  assert(localConfig.authentication.tokenDuration, 'missing \\'authentication.tokenDuration\\' field in configuration');\n\n  return {\n    tokenDuration: localConfig.authentication.tokenDuration\n  };\n}\n\nmodule.exports = {\n  getTokenDuration: () => {\n    let configuration = loadConfiguration();\n    return configuration.tokenDuration;\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/authentications/tokenAuthenticationConfiguration.js\n// module id = 363\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet getSlices = require('../../../queryHandlers/slices/GetSlicesByUpstream');\nlet toggleSlices = require('../../../commands/slices/ToggleSlicesByUpstream');\nlet metadata = require('../../../commands/utils/metadata');\nconst sns = require('../../../modules/sns/EnvironmentManagerEvents');\n\n/**\n * GET /upstreams/{name}/slices\n */\nfunction getUpstreamSlices(req, res, next) {\n  const upstreamName = req.swagger.params.name.value;\n  const environmentName = req.swagger.params.environment.value;\n  const active = req.swagger.params.active.value;\n\n  return getSlices({ environmentName, upstreamName, active }).then(data => res.json(data)).catch(next);\n}\n\n/**\n * PUT /upstreams/{name}/slices/toggle\n */\nfunction putUpstreamSlicesToggle(req, res, next) {\n  const upstreamName = req.swagger.params.name.value;\n  const activeSlice = req.swagger.params.active.value;\n  const environmentName = req.swagger.params.environment.value;\n  const user = req.user;\n\n  const command = metadata.addMetadata({ environmentName, upstreamName, activeSlice, user });\n  return toggleSlices(command)\n    .then(data => res.json(data))\n    .then(() => sns.publish({\n      message: JSON.stringify({\n        Endpoint: {\n          Url: `/upstreams/${upstreamName}/slices/toggle`,\n          Method: 'PUT',\n          Parameters: [\n            {\n              Name: 'upstream',\n              Type: 'path',\n              Value: upstreamName || ''\n            },\n            {\n              Name: 'environment',\n              Type: 'query',\n              Value: environmentName || ''\n            },\n            {\n              Name: 'active',\n              Type: 'query',\n              Value: activeSlice || ''\n            }\n          ]\n        }\n      }),\n      topic: sns.TOPICS.OPERATIONS_CHANGE,\n      attributes: {\n        Action: sns.ACTIONS.PUT,\n        ID: upstreamName,\n        Environment: environmentName,\n        ActiveSlice: activeSlice\n      }\n    }))\n    .catch(next);\n}\n\nmodule.exports = {\n  getUpstreamSlices,\n  putUpstreamSlicesToggle\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/controllers/upstreams/upstreamsController.js\n// module id = 364\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet assert = require('assert');\nlet getSlices = require('../../modules/queryHandlersUtil/getSlices');\nlet loadBalancerUpstreams = require('../../modules/data-access/loadBalancerUpstreams');\n\nmodule.exports = function GetSlicesByUpstream(query) {\n  assert.equal(typeof query.environmentName, 'string');\n  assert.equal(typeof query.upstreamName, 'string');\n\n  return loadBalancerUpstreams.inEnvironmentWithUpstream(query.environmentName, query.upstreamName)\n    .then(upstreams => getSlices.handleQuery(query, upstreams));\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/queryHandlers/slices/GetSlicesByUpstream.js\n// module id = 365\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet assert = require('assert');\nlet {\n  orchestrate,\n  ToggleUpstreamByNameVerifier,\n  UpstreamProvider,\n  UpstreamToggler\n } = require('../utils/toggleSlices');\nlet sender = require('../../modules/sender');\nlet Environment = require('../../models/Environment');\n\nmodule.exports = function ToggleSlicesByUpstream(command) {\n  assert.equal(typeof command.environmentName, 'string');\n  assert.equal(typeof command.upstreamName, 'string');\n\n  return Environment.getAccountNameForEnvironment(command.environmentName).then((account) => {\n    command.accountName = account;\n\n    let resourceName = `Upstream named \"${command.upstreamName}\" in \"${command.environmentName}\" environment`;\n    let provider = UpstreamProvider(sender, command, resourceName);\n    let verifier = ToggleUpstreamByNameVerifier(resourceName);\n    let toggler = UpstreamToggler(sender, command);\n\n    return orchestrate(provider, verifier, toggler);\n  });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/commands/slices/ToggleSlicesByUpstream.js\n// module id = 366\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet co = require('co');\nlet ms = require('ms');\nlet userService = require('../../../modules/user-service');\nlet utils = require('../../../modules/utilities');\nlet cookieConfiguration = require('../../../modules/authentications/cookieAuthenticationConfiguration');\n\n/**\n * POST /login\n */\nfunction login(req, res, next) {\n  return co(function* () {\n    let body = req.swagger.params.body.value;\n    let duration = cookieConfiguration.getCookieDuration();\n\n    let credentials = {\n      username: body.username,\n      password: body.password,\n      scope: 'ui'\n    };\n\n    let token = yield userService.authenticateUser(credentials, duration);\n    let cookieName = cookieConfiguration.getCookieName();\n    let cookieValue = token;\n    let cookieOptions = { expires: utils.offsetMilliseconds(new Date(), ms(duration)) };\n\n    res.cookie(cookieName, cookieValue, cookieOptions);\n    res.send(token);\n  }).catch(next);\n}\n\n/**\n * POST /logout\n */\nfunction logout(req, res, next) {\n  let cookieName = cookieConfiguration.getCookieName();\n  let token = req.cookies[cookieName];\n\n  return userService.signOut(token).then(() => {\n    res.clearCookie(cookieName);\n    res.json({ ok: true });\n  }).catch(next);\n}\n\nmodule.exports = {\n  login,\n  logout\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/controllers/user/userController.js\n// module id = 367\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nconst os = require('os');\nlet config = require('../../../config');\nlet _ = require('lodash');\n\nconst APP_VERSION = config.get('APP_VERSION');\nconst IS_REMOTE_DEBUG = config.get('IS_REMOTE_DEBUG');\nconst links = config.getUserValue('local').content.links;\nconst FEATURE_DISABLE_SERVICE = true;\n\nfunction getIP() {\n  try {\n    return _.chain(os.networkInterfaces())\n      .values()\n      .flatten()\n      .find({ family: 'IPv4', internal: false })\n      .value()\n      .address;\n  } catch (error) {\n    return '127.0.0.1';\n  }\n}\n\n/**\n * This is JSONP with initial state of an app, if user is not logged in, no need to send any information.\n * User will see a login form.\n */\nmodule.exports = function getInitialData(request, response) {\n  let str = '';\n  str += `window.version = '${APP_VERSION}'; `;\n  str += `window.FEATURE_DISABLE_SERVICE = ${FEATURE_DISABLE_SERVICE}; `;\n\n  if (request.user !== undefined) {\n    let userJson = JSON.stringify(request.user.toJson());\n    str += `window.links = ${JSON.stringify(links)}; `;\n    str += `window.user = new User(${userJson}); `;\n  }\n\n  if (IS_REMOTE_DEBUG) {\n    const DEBUG_PORT = config.get('DEBUG_PORT');\n    const IP = getIP();\n    str += `window.remoteDebugger='${IP}:${DEBUG_PORT}'; `;\n  }\n\n  response.send(str);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api/em-internal/controllers/initial-data.js\n// module id = 368\n// module chunks = 0","module.exports = require(\"os\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"os\"\n// module id = 369\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet config = require('../../config');\nconst Ssl = require('./HttpsServerFactory');\nconst NoSsl = require('./HttpServerFactory');\nlet implementation;\n\nif (config.get('IS_PRODUCTION') && !config.get('USE_HTTP')) {\n  implementation = new Ssl();\n} else {\n  implementation = new NoSsl();\n}\n\nmodule.exports = implementation;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/http-server-factory/index.js\n// module id = 370\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet https = require('https');\nconst SslComponentsRepository = require('../sslComponentsRepository');\n\nmodule.exports = function HttpsServerFactory() {\n  let sslComponentsRepository = new SslComponentsRepository();\n\n  this.create = function (application, parameters) {\n    return sslComponentsRepository.get().then(\n      sslComponents => new Promise((resolve) => {\n        let port = parameters.port;\n        let server = createServerByApplicationAndSslComponents(\n          application, sslComponents\n        );\n\n        server.listen(port, () => resolve(server));\n      })\n    );\n  };\n\n  function createServerByApplicationAndSslComponents(application, sslComponents) {\n    let options = {\n      key: sslComponents.privateKey,\n      cert: sslComponents.certificate\n    };\n\n    let server = https.createServer(options, application);\n    return server;\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/http-server-factory/HttpsServerFactory.js\n// module id = 371\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet http = require('http');\n\nfunction HttpServerFactory() {\n  this.create = function (application, parameters) {\n    return new Promise((resolve) => {\n      let port = parameters.port;\n      let server = http.createServer(application);\n      server.listen(port, () => resolve(server));\n    });\n  };\n}\n\nmodule.exports = HttpServerFactory;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/http-server-factory/HttpServerFactory.js\n// module id = 372\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n/**\n * Express Middleware to log requests and errors\n */\n\n'use strict';\n\nconst fp = require('lodash/fp');\nconst miniStack = require('../miniStack');\n\nlet redactSecrets = fp.cloneDeepWith((value, key) => (/password/i.test(key) ? '********' : undefined));\n\nlet swaggerParams = fp.flow(\n  fp.get(['swagger', 'params']),\n  fp.mapValues(({ value }) => value),\n  redactSecrets\n);\n\nlet getUser = fp.compose(\n  f => (fp.isFunction(f) ? f() : null),\n  fp.get(['user', 'getName'])\n);\n\nlet tryParse = (str) => {\n  try {\n    return JSON.parse(str);\n  } catch (e) {\n    return undefined;\n  }\n};\n\nlet mini = miniStack.build();\n\nlet loggerMiddleware = logger => (req, res, next) => {\n  let log = () => {\n    let deprecated = fp.compose(fp.defaultTo(false), fp.get(['locals', 'deprecated']))(res);\n    let message = deprecated ? 'HTTP request deprecated' : 'HTTP request';\n    let statusCode = fp.get(['statusCode'])(res);\n    let level = (() => {\n      if (statusCode >= 500) {\n        return 'error';\n      } else if (statusCode >= 400 || deprecated) {\n        return 'warn';\n      } else {\n        return 'debug';\n      }\n    })();\n    let responseFields = (() => {\n      if (statusCode < 400) {\n        return ['statusCode'];\n      } else {\n        return ['statusCode', 'body'];\n      }\n    })();\n    let entry = {\n      eventtype: 'http',\n      req: {\n        headers: {\n          'user-agent': fp.get(['headers', 'user-agent'])(req)\n        },\n        id: fp.get('id')(req),\n        ip: fp.get('ip')(req),\n        method: fp.get('method')(req),\n        originalUrl: fp.get('originalUrl')(req),\n        params: req.originalUrl === '/api/token' ? redactSecrets(req.body) : swaggerParams(req)\n      },\n      res: fp.pick(responseFields)(res),\n      user: req.originalUrl === '/api/token' ? fp.get(['body', 'username'])(req) : getUser(req)\n    };\n    logger.log(level, message, entry);\n  };\n  let send = res.send;\n  res.send = (content) => {\n    if (content) {\n      let s = content.toString();\n      res.body = tryParse(s) || s;\n    }\n    log();\n    send.call(res, content);\n  };\n  next();\n};\n\nlet errorLoggerMiddleware = logger => (err, req, res, next) => {\n  let log = () => {\n    let message = 'HTTP error';\n    let entry = {\n      error: {\n        message: fp.get(['message'])(err),\n        stack: fp.compose(fp.truncate({ length: 1400 }), mini, fp.get(['stack']))(err)\n      },\n      eventtype: 'http error',\n      req: {\n        id: fp.get('id')(req),\n        method: fp.get('method')(req),\n        ip: fp.get('ip')(req),\n        originalUrl: fp.get('originalUrl')(req),\n        params: swaggerParams(req)\n      },\n      user: getUser(req)\n    };\n    logger.error(message, entry);\n  };\n  res.once('close', log);\n  res.once('finish', log);\n  next(err);\n};\n\nmodule.exports = {\n  loggerMiddleware,\n  errorLoggerMiddleware\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/express-middleware/loggingMiddleware.js\n// module id = 373\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n/**\n * Express middleware that adds deprecated=true to a request and sets the Warning HTTP header\n * on the response if it is a request to a deprecated route.\n */\n\n'use strict';\n\nfunction create(fn) {\n  return function deprecateMiddleware(req, res, next) {\n    try {\n      let warning = fn(req);\n      if (warning) {\n        let now = new Date().toUTCString();\n        res.locals.deprecated = true;\n        res.append('Warning', `299 - Deprecated: ${warning} \"${now}\"`);\n      }\n      next();\n    } catch (error) {\n      next(error);\n    }\n  };\n}\n\nmodule.exports = create;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/express-middleware/deprecateMiddleware.js\n// module id = 374\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet express = require('express');\nlet router = express.Router();\nlet assert = require('assert');\nlet remoteCacheFlush = require('./remoteCacheFlush');\nlet cookieAuthentication = require('./authentications/cookieAuthentication');\nlet logger = require('./logger');\n\nrouter.post('/:environment', (req, res) => {\n  assert(req.body.hosts);\n\n  const hosts = req.body.hosts;\n  const environment = req.params.environment;\n\n  cookieAuthentication.middleware(req, res, () => 0)\n    .then(() => {\n      logger.info(`Request to reset cache in ${environment} by user ${req.user.getName()}`);\n      return remoteCacheFlush.flush(environment, hosts)\n        .then(results => res.status(200).json(results));\n    })\n    .catch(e => res.status(400).send('[cachereset::error]:', e.message));\n});\n\nmodule.exports = {\n  router\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/cacheRouter.js\n// module id = 375\n// module chunks = 0","'use strict';\n\nlet consulClient = require('./consul-client');\nlet _ = require('lodash');\nlet request = require('request').defaults({ strictSSL: false });\nlet logger = require('./logger');\nlet configEnvironments = require('./data-access/configEnvironments');\nlet config = require('../config');\n\nfunction flush(environment, hosts) {\n  let consulClientInstance;\n  let token;\n\n  return consulClient.create({ environment, promisify: true })\n    .then(storeInstance)\n    .then(() => {\n      return getToken(environment)\n        .then((tokenValue) => {\n          token = tokenValue;\n        });\n    })\n    .then(getServicesInEnvironment)\n    .then(convertServiceObjectToListOfServices)\n    .then(getNodesForServices)\n    .then(createAddresses(hosts))\n    .then((addresses) => { return sendRequestToAddresses(token, addresses); })\n    .then((results) => {\n      return consulClientInstance.kv.set(`environments/${environment}/cacheTimestamp`, Date.now().toString())\n        .then(() => {\n          results.unshift({ status: 'success', message: 'Consul Cache Updated' });\n          return results;\n        });\n    })\n    .catch((e) => {\n      logger.error('Cache Reset Error: ', e);\n      return { error: e.message };\n    });\n\n  function storeInstance(instance) {\n    consulClientInstance = instance;\n  }\n\n  function getServicesInEnvironment() {\n    return consulClientInstance.catalog.service.list();\n  }\n\n  function convertServiceObjectToListOfServices(services) {\n    if (services) return Object.keys(services).map(s => s);\n    else return [];\n  }\n\n  function getNodesForServices(serviceList) {\n    // [ service: listOfNodesInService ]\n    return Promise.all(serviceList.map((s) => {\n      return consulClientInstance.catalog.service.nodes(s);\n    }));\n  }\n}\n\nfunction stripPrefix(value) {\n  let prefixes = ['/^upstream_/', '/^slice_/'];\n  let result = '';\n  prefixes.forEach((p) => {\n    result = value.replace(p, '');\n  });\n  return result;\n}\n\n\nfunction createAddresses(hosts) {\n  return (nodesLists) => {\n    let addresses = [];\n    _.flatten(hosts).forEach((host) => {\n      let nodes = _.flatten(nodesLists).filter((n) => {\n        // todo: Configuration String endpoint to store these ignore strings\n        return stripPrefix(n.ServiceName).toLowerCase() === host.host.toLowerCase();\n      });\n      if (nodes) {\n        nodes.forEach((node) => {\n          let ip = node.Address;\n          addresses.push({\n            Address: `https://${ip}:${host.port}/diagnostics/cachereset`,\n            Host: host.host,\n            ServiceName: node.ServiceName\n          });\n        });\n      }\n    });\n    return addresses;\n  };\n}\n\nconst stripToken = (options) => {\n  if (options.body && options.body.token && !options.body.token.startsWith('[No Cache Reset Key Found]')) {\n    delete options.body.token;\n  }\n  return options;\n};\n\nfunction sendRequestToAddresses(token, addresses) {\n  let results = [];\n\n  addresses.forEach((address) => {\n    let options = {\n      method: 'POST',\n      uri: address.Address,\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      timeout: 10000,\n      body: {\n        token\n      },\n      json: true,\n      metadata: {\n        Host: address.Host,\n        ServiceName: address.ServiceName\n      }\n    };\n\n    results.push(new Promise((resolve) => {\n      request.post(options, (error, response) => {\n        if (response && response.statusCode === 401) {\n          let message = `401 received: ${JSON.stringify(stripToken(options))}`;\n          let result = ({ status: 'info', message });\n          resolve(result);\n          logger.error(message);\n        } else if (response && response.statusCode === 200) {\n          let message = `'200 received: ${JSON.stringify(stripToken(options))}`;\n          let result = ({ status: 'success', message });\n          logger.info(message);\n          resolve(result);\n        } else {\n          let message = `'Non 200-401 received: ${JSON.stringify(stripToken(options))}`;\n          let result = ({ status: 'default', message });\n          logger.info(message);\n          resolve(result);\n        }\n      });\n    }));\n  });\n\n  return Promise.all(results);\n}\n\nfunction getToken(EnvironmentName) {\n  let key = { EnvironmentName };\n  return configEnvironments.get(key)\n    .then(getEnvironmentTypeValue)\n    .then(getCacheResetKeyForEnvironment);\n\n  function getEnvironmentTypeValue(environment) {\n    return environment.Value.EnvironmentType;\n  }\n\n  function getCacheResetKeyForEnvironment(environmentType) {\n    try {\n      let value = config.getUserValue('local').CacheReset[environmentType].plain;\n      return value;\n    } catch (e) {\n      return `[No Cache Reset Key Found] :: ${environmentType}`;\n    }\n  }\n}\n\nmodule.exports = {\n  flush\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/remoteCacheFlush.js\n// module id = 376\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet express = require('express');\nlet co = require('co');\nlet _ = require('lodash');\n\nlet healthChecks = require('./health-checks');\n\nlet statusCodes = _.fromPairs([\n  [healthChecks.resultCodes.SUCCESS, 200],\n  [healthChecks.resultCodes.FAIL, 500]\n]);\n\nfunction buildRouter() {\n  let router = express.Router();\n  healthChecks.checks.forEach((check) => {\n    let middleware = toMiddleware(check.run);\n    router.get(check.url, middleware);\n  });\n  return router;\n}\n\nfunction toMiddleware(check) {\n  return (req, res) => {\n    co(function* () {\n      let checkReport = yield runCheck(check);\n      let statusCode = statusCodes[checkReport.result];\n      res.status(statusCode).json(checkReport);\n    });\n  };\n}\n\nfunction runCheck(check) {\n  try {\n    return check().catch(err => errorResult(err));\n  } catch (err) {\n    return Promise.resolve(errorResult(err));\n  }\n}\n\nfunction errorResult(error) {\n  return {\n    result: healthChecks.resultCodes.FAIL,\n    reason: 'An error occurred',\n    error: {\n      message: error.message,\n      stack: error.stack\n    }\n  };\n}\n\nmodule.exports = {\n  router: buildRouter()\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/httpHealthChecks.js\n// module id = 377\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet resultCodes = require('./resultCodes');\nconst ping = require('./library/ping');\nconst redis = require('./library/redis');\n\nlet checks = [\n  ping,\n  redis\n  // ... add more health checks here\n];\n\nmodule.exports = {\n  resultCodes,\n  checks\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/health-checks/index.js\n// module id = 378\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet HealthCheckResults = require('../resultCodes');\n\nmodule.exports = {\n  url: '/ping',\n  run: () => {\n    return Promise.resolve({\n      result: HealthCheckResults.SUCCESS\n    });\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/health-checks/library/ping.js\n// module id = 379\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet co = require('co');\n\nlet HealthCheckResults = require('../resultCodes');\nlet UserSessionStore = require('../../userSessionStore');\n\nfunction getResult(status) {\n  if (status === 'wait' || status === 'ready') {\n    return { result: HealthCheckResults.SUCCESS };\n  }\n\n  return {\n    result: HealthCheckResults.FAIL,\n    reason: `Redis connection status is '${status}'`\n  };\n}\n\nmodule.exports = {\n  url: '/redis',\n  run: () => {\n    return co(function* () {\n      let sessionStore = yield UserSessionStore.get();\n      return getResult(sessionStore.status());\n    });\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/health-checks/library/redis.js\n// module id = 380\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet config = require('../config');\nlet renderer = require('../modules/renderer');\n\nconst PUBLIC_DIR = config.get('PUBLIC_DIR');\n\nrenderer.register('home', `${PUBLIC_DIR}/index.html`);\n\nmodule.exports = function (request, response) {\n  renderer.render('home', {}, content => response.send(content));\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/routes/home.js\n// module id = 381\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n/* eslint-disable */\n/**\n * TODO: This file needs some attention/simplifying\n * Ignoring eslint until then.\n */\n'use strict';\n\nlet fileSystem = require('fs');\nlet compiler = require('es6-template-strings/compile');\nlet resolver = require('es6-template-strings/resolve-to-string');\n\nlet templateCatalog = [];\n\nfunction Template(name, path) {\n  let _name = name;\n  let _path = path;\n  let _template = null;\n\n  function getPath() { return _path; }\n\n  function getTemplate() { return _template; }\n\n  function setTemplate(value) { _template = value; }\n\n  function render(data, callback) {\n    let executeTemplating = function () {\n      let result = resolver(getTemplate(), data);\n      callback(result);\n    };\n\n    if (getTemplate()) {\n      executeTemplating();\n    } else {\n      fileSystem.readFile(getPath(), 'utf8', (error, content) => {\n        if (error) throw error;\n\n        setTemplate(compiler(content));\n        executeTemplating();\n      });\n    }\n  }\n\n  return {\n    render,\n  };\n}\n\nmodule.exports = {\n  register(name, path) {\n    templateCatalog[name] = new Template(name, path);\n  },\n  render(name, data, callback) {\n    templateCatalog[name].render(data, callback);\n  },\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/renderer.js\n// module id = 382\n// module chunks = 0","module.exports = require(\"es6-template-strings/compile\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"es6-template-strings/compile\"\n// module id = 383\n// module chunks = 0","module.exports = require(\"es6-template-strings/resolve-to-string\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"es6-template-strings/resolve-to-string\"\n// module id = 384\n// module chunks = 0","/* Copyright (c) Trainline Limited, 2016-2017. All rights reserved. See LICENSE.txt in the project root for license information. */\n\n'use strict';\n\nlet url = require('url');\nlet sender = require('../modules/sender');\nlet logger = require('../modules/logger');\nlet GetNodeDeploymentLog = require('../queryHandlers/deployments/GetNodeDeploymentLog');\n\nmodule.exports = (request, response) => {\n  let params = url.parse(request.url, true).query;\n\n  let query = {\n    name: 'GetNodeDeploymentLog',\n    accountName: params.account,\n    environment: params.environment,\n    deploymentId: params.deploymentId,\n    instanceId: params.node\n  };\n\n  sender.sendQuery(GetNodeDeploymentLog, { query, user: request.user }).then((data) => {\n    response.send(data.replace(/\\n/g,  '<br />'));\n  }).catch((err) => {\n    response.status(500).send('An error occurred. The log file might not be available. Please see logs for more details.');\n    logger.error('Error fetching node deployment log file.', err);\n  });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/routes/deploymentNodeLogs.js\n// module id = 385\n// module chunks = 0"],"sourceRoot":""}